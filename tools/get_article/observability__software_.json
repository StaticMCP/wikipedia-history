{
  "content": [
    {
      "type": "text",
      "text": "# Observability (software)\n\nIn software engineering, more specifically in distributed computing, observability is the ability to collect data about programs' execution, modules' internal states, and the communication among components. To improve observability, software engineers use a wide range of logging and tracing techniques to gather telemetry information, and tools to analyze and use it. Observability is foundational to site reliability engineering, as it is the first step in triaging a service outage.\nOne of the goals of observability is to minimize the amount of prior knowledge needed to debug an issue.\nEtymology, terminology and definition\nThe term is borrowed from control theory, where the \"observability\" of a system measures how well its state can be determined from its outputs. Similarly, software observability measures how well a system's state can be understood from the obtained telemetry (metrics, logs, traces, profiling).\nThe definition of observability varies by vendor:\n}}\n}}}}}}\n}}\n}}\nThe term is frequently referred to as its numeronym o11y (where 11 stands for the number of letters between the first letter and the last letter of the word). This is similar to other computer science abbreviations such as i18n and l10n and k8s.\nObservability vs. monitoring\nObservability and monitoring are sometimes used interchangeably. As tooling, commercial offerings and practices evolved in complexity, \"monitoring\" was re-branded as observability in order to differentiate new tools from the old.\nThe terms are commonly contrasted in that systems are monitored using predefined sets of telemetry, and monitored systems may be observable.\nMajors et al. suggest that engineering teams that only have monitoring tools end up relying on expert foreknowledge (seniority), whereas teams that have observability tools rely on exploratory analysis (curiosity).\nTelemetry types\nObservability relies on three main types of telemetry data: metrics, logs and traces. Those are often referred to as \"pillars of observability\".\nMetrics\nA metric is a point in time measurement (scalar) that represents some system state. Examples of common metrics include:\n* number of HTTP requests per second;\n* total number of query failures;\n* database size in bytes;\n* time in seconds since last garbage collection.\nMonitoring tools are typically configured to emit alerts when certain metric values exceed set thresholds. Thresholds are set based on knowledge about normal operating conditions and experience.\nMetrics are typically tagged to facilitate grouping and searchability.\nApplication developers choose what kind of metrics to instrument their software with, before it is released. As a result, when a previously unknown issue is encountered, it is impossible to add new metrics without shipping new code. Furthermore, their cardinality can quickly make the storage size of telemetry data prohibitively expensive. Since metrics are cardinality-limited, they are often used to represent aggregate values (for example: average page load time, or 5-second average of the request rate). Without external context, it is impossible to correlate between events (such as user requests) and distinct metric values.\nLogs\nLogs, or log lines, are generally free-form, unstructured text blobs that are intended to be human readable. Modern logging is structured to enable machine parsability. As with metrics, an application developer must instrument the application upfront and ship new code if different logging information is required.\nLogs typically include a timestamp and severity level. An event (such as a user request) may be fragmented across multiple log lines and interweave with logs from concurrent events.\nTraces\nDistributed traces\nA cloud native application is typically made up of distributed services which together fulfill a single request. A distributed trace is an interrelated series of discrete events (also called spans) that track the progression of a single user request. A trace shows the causal and temporal relationships between the services that interoperate to fulfill a request.\nInstrumenting an application with traces means sending span information to a tracing backend. The tracing backend correlates the received spans to generate presentable traces. To be able to follow a request as it traverses multiple services, spans are labeled with unique identifiers that enable constructing a parent-child relationship between spans. Span information is typically shared in the HTTP headers of outbound requests.\nContinuous profiling\nContinuous profiling is another telemetry type used to precisely determine how an application consumes resources.\nInstrumentation\nTo be able to observe an application, telemetry about the application's behavior needs to be collected or exported. Instrumentation means generating telemetry alongside the normal operation of the application. Telemetry is then collected by an independent backend for later analysis.\nInstrumentation can be automatic, or custom. Automatic instrumentation offers blanket coverage and immediate value; custom instrumentation brings higher value but requires more intimate involvement with the instrumented application.\nInstrumentation can be native - done in-code (modifying the code of the instrumented application) - or out-of-code (e.g. sidecar, eBPF).\nVerifying new features in production by shipping them together with custom instrumentation is a practice called \"observability-driven development\".\n\"Pillars of observability\"\nMetrics, logs and traces are most commonly listed as the pillars of observability. Majors et al. suggest that the pillars of observability are high cardinality, high-dimensionality, and explorability, arguing that runbooks and dashboards have little value because \"modern systems rarely fail in precisely the same way twice.\"\nSelf monitoring\nSelf monitoring is a practice where observability stacks monitor each other, in order to reduce the risk of inconspicuous outages. Self monitoring may be put in place in addition to high availability and redundancy to further avoid correlated failures.\nSee also\n* Application performance management (APM)\n* OpenTelemetry (OTel)\n* Real user monitoring (RUM)\n* Synthetic monitoring\n* DevOps\n* Site reliability engineering (SRE)\n* Sociotechnical system\nExternal links\n* [https://github.com/cncf/tag-observability CNCF Observability Technical Advisory Group (TAG)]\nBibliography\n*\n*\n*\n*\nReferences"
    }
  ]
}