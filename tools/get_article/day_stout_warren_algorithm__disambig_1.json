{
  "content": [
    {
      "type": "text",
      "text": "# Day–Stout–Warren algorithm__disambig_1\n\nThe Day–Stout–Warren (DSW) algorithm is a method for efficiently balancing binary search trees that is, decreasing their height to O(log n) nodes, where n is the total number of nodes. Unlike a self-balancing binary search tree, it does not do this incrementally during each operation, but periodically, so that its cost can be amortized over many operations. The algorithm was designed by Quentin F. Stout and Bette Warren in a 1986 CACM paper, based on work done by Colin Day in 1976.\nThe algorithm requires linear (O(n)) time and is in-place. The original algorithm by Day generates as compact a tree as possible: all levels of the tree are completely full except possibly the bottom-most. It operates in two phases. First, the tree is turned into a linked list by means of an in-order traversal, reusing the pointers in the (threaded) tree's nodes. A series of left-rotations forms the second phase.\nThe Stout–Warren modification generates a complete binary tree, namely one in which the bottom-most level is filled strictly from left to right.  This is a useful transformation to perform if it is known that no more inserts will be done. It does not require the tree to be threaded, nor does it require more than constant space to operate. Like the original algorithm, Day–Stout–Warren operates in two phases, the first entirely new, the second a modification of Day's rotation phase.\nA 2002 article by Timothy J. Rolfe brought attention back to the DSW algorithm; the naming is from the section title \"6.7.1:  The DSW Algorithm\" in Adam Drozdek's textbook. Rolfe cites two main advantages: \"in circumstances in which one generates an entire binary search tree at the beginning of processing, followed by item look-up access for the rest of processing\" and \"pedagogically within a course on data structures where one progresses from the binary search tree into self-adjusting trees, since it gives a first exposure to doing rotations within a binary search tree.\"\nPseudocode\nThe following is a presentation of the basic DSW algorithm in pseudocode, after the Stout–Warren paper. It consists of a main routine with three subroutines. The main routine is given by\n# Allocate a node, the \"pseudo-root\", and make the tree's actual root the right child of the pseudo-root.\n# Call tree-to-vine with the pseudo-root as its argument.\n# Call vine-to-tree on the pseudo-root and the size (number of elements) of the tree.\n# Make the tree's actual root equal to the pseudo-root's right child.\n# Dispose of the pseudo-root.\nThe subroutines are defined as follows:\nroutine tree-to-vine(root)\n// Convert tree to a \"vine\", i.e., a sorted linked list,\n// using the right pointers to point to the next node in the list\ntail ← root\nrest ← tail.right\nwhile rest ≠ nil\nif rest.left = nil\ntail ← rest\nrest ← rest.right\nelse\ntemp ← rest.left\nrest.left ← temp.right\ntemp.right ← rest\nrest ← temp\ntail.right ← temp\nroutine vine-to-tree(root, size)\nleaves ← size + 1 − 2⌊log2(size + 1)⌋\ncompress(root, leaves)\nsize ← size − leaves\nwhile size > 1\ncompress(root, ⌊size / 2⌋)\nsize ← ⌊size / 2⌋\nroutine compress(root, count)\nscanner ← root\nfor i ← 1 to count\nchild ← scanner.right\nscanner.right ← child.right\nscanner ← scanner.right\nchild.right ← scanner.left\nscanner.left ← child\nNotes\nReferences"
    }
  ]
}