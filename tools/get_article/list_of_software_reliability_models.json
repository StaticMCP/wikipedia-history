{
  "content": [
    {
      "type": "text",
      "text": "# List of software reliability models\n\nSoftware reliability is the probability of the software causing a system failure over some specified operating time. Software does not fail due to wear out but does fail due to faulty functionality, timing, sequencing, data, and exception handling.  The software fails as a function of operating time as opposed to calendar time.  Many models have been developed since early 1970s, however, several of them have similar if not identical assumptions.  The models have two basic types - prediction modeling and estimation modeling.\n1.0 Overview of Software Reliability Prediction Models\nThese models are derived from actual historical data from real software projects.  The user answers a list of questions which calibrate the historical data to yield a software reliability prediction.  The accuracy of the prediction depends on how many parameters (questions) and datasets are in the model, how current the data is, and how confident the user is of their inputs. One of the earliest prediction models was the Rome Laboratory TR-92-52.  It was developed in 1987 and last updated in 1992 and was geared towards software in avionics systems. The model wasn't updated after 1992.  However, the Full-scale model was deployed in 1997 which reused many of the factors in the TR-92-52 model.  New development factors were added to reflect new technologies and the empirical data included data from systems other than aircraft.\n2.0 Overview of Software Reliability Growth (Estimation) Models\nSoftware reliability growth (or estimation) models use failure data from testing to forecast the failure rate or MTBF into the future.  The models depend on the assumptions about the fault rate during testing which can either be increasing, peaking, decreasing or some combination of decreasing and increasing.  Some models assume that there is a finite and fixed number of inherent defects while others assume that it's infinite.  Some models require effort for parameter estimation while others have only a few parameters to estimate.  Some models require the exact time in between each failure found in testing, while others only need to have the number of failures found during any given time interval such as a day.\n{| class=\"wikitable\"\n! Model name\n! Inherent defect count\n! Effort required\n! Requires exact time between  failures\n|-\n|Increasing fault rate\n|\n|\n|\n|-\n|Weibull\n|Finite/not  fixed\n|High\n|NA\n|-\n|Peak\n|\n|\n|\n|-\n|Shooman  Constant Defect Removal Rate Model\n|Finite/fixed\n|Low\n|Yes\n|-\n|Decreasing fault rate\n|\n|\n|\n|-\n|Shooman  Constant Defect Removal Rate Model\n|Finite/fixed\n|Low\n|Yes\n|-\n| colspan=\"4\" |Linearly Decreasing\n|-\n|General  exponential models including:\n·          Goel-Okumoto (exponential)\n·          Musa Basic  Model\n·          Jelinski-Moranda\n|Finite/fixed\n|Medium\n|Yes\n|-\n|Shooman  Linearly Decreasing Model\n|Finite/fixed\n|Low\n|Yes\n|-\n|Duane\n|Infinite\n|Medium\n|No\n|-\n| colspan=\"4\" |Non-Linearly Decreasing\n|-\n|Musa-Okumoto  (logarithmic)\n|Infinite\n|Low\n|Yes\n|-\n|Shooman  Exponentially Decreasing Model\n|Finite/fixed\n|High\n|Yes\n|-\n|Log-logistic\n|Finite/fixed\n|High\n|Yes\n|-\n|Geometric\n|Infinite\n|High\n|Yes\n|-\n|Increasing and then decreasing\n|\n|\n|\n|-\n|Yamada  (Delayed)\nS-shaped\n|Infinite\n|High\n|Yes\n|-\n|Weibull\n|Finite/not  fixed\n|High\n|\n|}\n*\nReferences"
    }
  ]
}