{
  "content": [
    {
      "type": "text",
      "text": "# Software design__disambig_1\n\nSoftware design is the process of conceptualizing how a software system will work before it is implemented or modified.\nSoftware design also refers to the direct result of the design process  the concepts of how the software will work which may be formally  documented or may be maintained less formally, including via oral tradition.\nThe design process enables a designer to model aspects of a software system before it exists with the intent of making the effort of writing the code more efficiently. Creativity, past experience, a sense of what makes \"good\" software, and a commitment to quality are success factors for a competent design.\nA software design can be compared to an  architected plan for a house. High-level plans represent the totality of the house (e.g., a three-dimensional rendering of the house). Lower-level plans provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the software design model provides a variety of views of the proposed software solution.\nPart of the overall process\nIn terms of the waterfall development process, software design is the activity that occurs after requirements analysis and before coding. Requirements analysis determines what the system needs to do without determining how it will do it, and thus, multiple designs can be imagined that satisfy the requirements. The design can be created while coding, without a plan or requirements analysis, but for more complex projects this is less feasible. Completing a design prior to coding allows for multidisciplinary designers and subject-matter experts to collaborate with programmers to produce software that is useful and technically sound.\nSometimes, a simulation or prototype is created to model the system in an effort to determine a valid and good design.\nCode as design\nA common point of confusion with the term design in software is that the process applies at multiple levels of abstraction such as a high-level software architecture and lower-level components, functions and algorithms. A relatively formal process may occur at high levels of abstraction but at lower levels, the design process is almost always less formal where the only artifact of design may be the code itself. To the extent that this is true, software design refers to the design of the design.  Edsger W. Dijkstra referred to this layering of semantic levels as the \"radical novelty\" of computer programming, and Donald Knuth used his experience writing TeX to describe the futility of attempting to design a program prior to implementing it:\n}}\nArtifacts\nA design process may include the production of art Software design documentation such as flow chart, use case, Pseudocode, Unified Modeling Language model and other Fundamental modeling concepts. For  user centered software, design may involve user experience design yielding a storyboard to help determine those specifications. Documentation may be reviewed to allow constraints, specifications and even requirements to be adjusted prior to coding.\nIterative Design\nSoftware systems inherently deal with uncertainties, and the size of software components can significantly influence a system's outcomes, both positively and negatively. Neal Ford and Mark Richards propose an iterative approach to address the challenge of identifying and right-sizing components. This method emphasizes continuous refinement as teams develop a more nuanced understanding of system behavior and requirements.\nThe approach typically involves a cycle with several stages:\n* A high-level partitioning strategy is established, often categorized as technical or domain-based. Guidelines for the smallest meaningful deployable unit, referred to as \"quanta,\" are defined. While these foundational decisions are made early, they may be revisited later in the cycle if necessary.\n* Initial components are identified based on the established strategy.\n* Requirements are assigned to the identified components.\n* The roles and responsibilities of each component are analyzed to ensure clarity and minimize overlap.\n* Architectural characteristics, such as scalability, fault tolerance, and maintainability, are evaluated.\n* Components may be restructured based on feedback from development teams.\nThis cycle serves as a general framework and can be adapted to different domains.\nDesign principles\nDesign principles enable a software engineer to navigate the design process. Davis suggested principles which have been refined over time as:\n; The design process should not suffer from \"tunnel vision\": A good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job.\n; The design should be traceable to the analysis model: Because a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model.\n; The design should not reinvent the wheel: Systems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable).\n; The design should \"minimize the intellectual distance\" between the software and the problem as it exists in the real world: That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain.\n; The design should exhibit uniformity and integration: A design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components.\n; The design should be structured to accommodate change: The design concepts discussed in the next section enable a design to achieve this principle.\n; The design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered: Well-designed software should never \"bomb\"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner.\n; Design is not coding, coding is not design: Even when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded.\n; The design should be assessed for quality as it is being created, not after the fact: A variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process.\n; The design should be reviewed to minimize conceptual (semantic) errors: There is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model.\nDesign concepts\nDesign concepts provide a designer with a foundation from which more sophisticated methods can be applied. Design concepts include:\n; Abstraction: Reducing the information content of a concept or an observable phenomenon, typically to retain only information that is relevant for a particular purpose. It is an act of Representing essential features without including the background details or explanations.\n; Architecture: The overall structure of the software and the ways in which that structure provides conceptual integrity for a system. Good software architecture will yield a good return on investment with respect to the desired outcome of the project, e.g. in terms of performance, quality, schedule and cost.\n; Control hierarchy: A program structure that represents the organization of a program component and implies a hierarchy of control.\n; Data structure: Representing the logical relationship between elements of data.\n; Design pattern: A designer may identify a design aspect of the system that has solved in the past. The reuse of such patterns can increase software development velocity.\n; Information hiding: Modules should be specified and designed so that information contained within a module is inaccessible to other modules that have no need for such information.\n; Modularity: Dividing the solution into parts (modules).\n;  Refinement: The process of elaboration. A hierarchy is developed by decomposing a macroscopic statement of function in a step-wise fashion until programming language statements are reached. In each step, one or several instructions of a given program are decomposed into more detailed instructions. Abstraction and Refinement are complementary concepts.\n; Software procedure: Focuses on the processing of each module individually.\n; Structural partitioning: The program structure can be divided horizontally and vertically. Horizontal partitions define separate branches of modular hierarchy for each major program function. Vertical partitioning suggests that control and work should be distributed top-down in the program structure.\nGrady Booch mentions abstraction, encapsulation, modularization, and hierarchy as fundamental software design principles. The phrase principles of hierarchy, abstraction, modularization, and encapsulation (PHAME) refers to these principles.\nDesign considerations\nThere are many aspects to consider in the design of software. The importance of each should reflect the goals and expectations to which the software is being created. Notable aspects include:\n; Compatibility: The software is able to operate with other products that are designed for interoperability with another product.  For example, a piece of software may be backward-compatible with an older version of itself.\n; Extensibility: New capabilities can be added to the software without major changes to the underlying architecture.\n; Fault-tolerance: The software is resistant to and able to recover from component failure.\n; Maintainability: A measure of how easily bug fixes or functional modifications can be accomplished. High maintainability can be the product of modularity and extensibility.\n; Modularity: The resulting software comprises well defined, independent components which leads to better maintainability. The components could be then implemented and tested in isolation before being integrated to form a desired software system. This allows division of work in a software development project.\n; Overhead: How the consumption of resources required for overhead impacts the resources needed to achieve system requirements.\n; Performance: The software performs its tasks within a time-frame that is acceptable for the user, and does not require too much memory.\n; Portability: The software should be usable across a number of different conditions and environments.\n; Reliability:The software is able to perform a required function under stated conditions for a specified period of time.\n; Reusability: The ability to use some or all of the aspects of the preexisting software in other projects with little to no modification.\n; Robustness: The software is able to operate under stress or tolerate unpredictable or invalid input.  For example, it can be designed with resilience to low memory conditions.\n; Scalability: The software adapts well to increasing data or added features or number of users. According to Marc Brooker: \"a system is scalable in the range where marginal cost of additional workload is nearly constant.\" Serverless technologies fit this definition but you need to consider total cost of ownership not just the infra cost.\n; Security: The software is able to withstand and resist hostile acts and influences.\n; Usability: The software user interface must be usable for its target user/audience. Default values for the parameters must be chosen so that they are a good choice for the majority of the users.\nModeling language\nA modeling language can be used to express information, knowledge or systems in a structure that is defined by a consistent set of rules. These rules are used for interpretation of the components within the structure. A modeling language can be graphical or textual. Examples of graphical modeling languages for software design include:\n; Architecture description language (ADL): A language used to describe and represent the software architecture of a software system.\n; Business Process Modeling Notation (BPMN): An example of a Process Modeling language.\n; EXPRESS and EXPRESS-G (ISO 10303-11): An international standard general-purpose data modeling language.\n; Extended Enterprise Modeling Language (EEML): Commonly used for business process modeling across a number of layers.\n; Flowchart: Schematic representations of algorithms or other step-wise processes.\n; Fundamental Modeling Concepts (FMC): A modeling language for software-intensive systems.\n; IDEF: A family of modeling languages, the most notable of which include IDEF0 for functional modeling, IDEF1X for information modeling, and IDEF5 for modeling ontologies.\n; Jackson Structured Programming (JSP): A method for structured programming based on correspondences between data stream structure and program structure.\n; LePUS3: An object-oriented visual Design Description Language and a formal specification language that is suitable primarily for modeling large object-oriented (Java, C++, C#) programs and design patterns.\n; Unified Modeling Language (UML): A general modeling language to describe software both structurally and behaviorally.  It has a graphical notation and allows for extension with a Profile (UML).\n; Alloy (specification language): A general purpose specification language for expressing complex structural constraints and behavior in a software system. It provides a concise language base on first-order relational logic.\n; Systems Modeling Language (SysML): A general-purpose modeling language for systems engineering.\n; Service-oriented modeling framework (SOMF)\nSee also\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nReferences\n^"
    }
  ]
}