{
  "content": [
    {
      "type": "text",
      "text": "# Software deployment\n\nSoftware deployment is all of the activities that make a software system available for use.\nDeployment can involve activities on the producer (software developer) side or on the consumer (user) side or both. Deployment to consumers is a hard task because the target systems are diverse and unpredictable.\nSoftware as a service avoids these difficulties by deploying only to dedicated servers that are typically under the producer's control.\nBecause every software system is unique, the precise processes or procedures within each activity can hardly be defined. Therefore, \"deployment\" should be interpreted as a general process that has to be customized according to specific requirements or characteristics.\nHistory\nWhen computers were extremely large, expensive, and bulky (mainframes and minicomputers), the software was often bundled together with the hardware by manufacturers and provided for free. A pivotal moment occurred in 1969 when IBM, influenced by antitrust lawsuits, began charging for software and services separately from hardware. This \"unbundling\" effectively created the modern software industry, turning software into a commercial product. Early deployment processes were highly structured; the Lincoln Labs Phased Model, developed in 1956 for the SAGE air defense system, introduced sequential phases that influenced later methodologies. This approach was formalized in the waterfall model, which became dominant after being described by Winston Royce in 1970. It led to infrequent, costly, and lengthy release cycles, often taking years. If business software needed to be installed, it often required an expensive, time-consuming visit by a systems architect or a consultant. For complex, on-premises installation of enterprise software today, this is sometimes still the case.\nThe development of mass-market software for the new age of microcomputers in the 1980s brought new forms of software distributionfirst cartridges, then Compact Cassettes, then floppy disks, and later (in the 1990s and beyond) optical media, the internet and flash drives. This shift meant that software deployment could be left to the customer. During this period, alternatives to the rigid waterfall model emerged. The Spiral Model, proposed by Barry Boehm in 1988, introduced a risk-driven, iterative approach that challenged waterfall's linear structure and paved the way for more flexible, agile methodologies. As customer-led deployment became standard, it was recognized that configuration should be user-friendly. In the 1990s, tools like InstallShield became popular, providing installer wizards that eliminated the need for users to perform complex tasks like editing registry entries.\nIn pre-internet software deployments, releases were by nature expensive and infrequent affairs. The spread of the internet fundamentally transformed software distribution and made end-to-end agile software development viable by enabling rapid collaboration and digital delivery. The foundations for modern rapid deployment were laid in the 1990s when Kent Beck developed Continuous Integration as a core practice of Extreme Programming, advocating for developers to integrate their work daily. The advent of cloud computing and software as a service (SaaS) in the 2000s further accelerated this trend, allowing software to be deployed to a large number of customers in minutes. This shift also meant deployment schedules were now typically determined by the software supplier, not the customers. Such flexibility led to the rise of continuous delivery as a viable option, especially for web applications.\nModern deployment strategies that build upon these principles include blue–green deployment and canary release deployment.\nDeployment activities\n; Release: The release activity follows from the completed the development process and is sometimes classified as part of the development process rather than deployment process. It includes all the operations to prepare a system for assembly and transfer to the computer system(s) on which it will be run in production. Therefore, it sometimes involves determining the resources required for the system to operate with tolerable performance and planning and/or documenting subsequent activities of the deployment process.\n; Installation and activation: For simple systems, installation involves establishing some form of a command, shortcut, script or service for executing the software (manually or automatically). For complex systems it may involve configuration of the system possibly by asking the end-user questions about its intended use, or directly asking them how they would like it to be configured and/or making all the required subsystems ready to use. Activation is the activity of starting up the executable component of software for the first time (not to be confused with the common use of the term activation concerning a software license, which is a function of Digital Rights Management systems.)\n: In larger software deployments on servers, the main copy of the software to be used by users - \"production\" - might be installed on a production server in a production environment.  Other versions of the deployed software may be installed in a test environment, development environment and disaster recovery environment.\n: In complex continuous delivery environments and/or software as a service system, differently-configured versions of the system might even exist simultaneously in the production environment for different internal or external customers (this is known as a multi-tenant architecture), or even be gradually rolled out in parallel to different groups of customers, with the possibility of canceling one or more of the parallel deployments. For example, Twitter is known to use the latter approach for A/B testing of new features and user interface changes. A \"hidden live\" group can also be created within a production environment, consisting of servers that are not yet connected to the production load balancer, for the purposes of blue–green deployment.\n; Deactivation: Deactivation is the inverse of activation and refers to shutting down any already-executing components of a system. Deactivation is often required to perform other deployment activities, e.g., a software system may need to be deactivated before an update can be performed.  The practice of removing infrequently used or obsolete systems from service is often referred to as application retirement or application decommissioning.\n; Uninstallation: Uninstallation is the inverse of installation. It is the removal of a system that is no longer required. It may also involve some reconfiguration of other software systems to remove the uninstalled system's dependencies.\n; Update: The update process replaces an earlier version of all or part of a software system with a newer release. It commonly consists of deactivation followed by installation. On some systems, such as on Linux when using the system's package manager, the old version of a software application is typically also uninstalled as an automatic part of the process. (This is because Linux package managers do not typically support installing multiple versions of a software application at the same time unless the software package has been specifically designed to work around this limitation.)\n; Built-in update: Mechanisms for installing updates are built into some software systems (or, in the case of some operating systems such as Linux, Android and iOS, into the operating system itself). Automation of these update processes ranges from fully automatic to user-initiated and controlled. Norton Internet Security is an example of a system with a semi-automatic method for retrieving and installing updates to both the antivirus definitions and other components of the system. Other software products provide query mechanisms for determining when updates are available.\n; Version tracking: Version tracking systems help the user find and install updates to software systems. For example: The Software Catalog stores the version and other information for each software package installed on a local system. One-click of a button launches a browser window to the upgrade web page for the application, including auto-filling of the user name and password for sites that require a login. On Linux, Android and iOS this process is even easier because a standardized process for version tracking (for software packages installed in the officially supported way) is built into the operating system, so no separate login, download and execute steps are required so the process can be configured to be fully automated. Some third-party software also supports automated version tracking and upgrading for certain Windows software packages.\nDeployment roles\nThe complexity and variability of software products have fostered the emergence of specialized roles for coordinating and engineering the deployment process.  For desktop systems, end-users frequently also become the \"software deployers\" when they install a software package on their machine. The deployment of enterprise software involves many more roles, and those roles typically change as the application progresses from the test (pre-production) to production environments.  Typical roles involved in software deployments for enterprise applications may include:\n* in pre-production environments:\n** application developers: see Software development process\n** build-and-release engineers: see Release engineering\n** release managers: see Release management\n** deployment coordinators: see DevOps\n* in production environments:\n** system administrator\n** database administrator\n** release coordinators: see DevOps\n** operations project managers: see ITIL\nSee also\n* Application lifecycle management\n* Product lifecycle management\n* Systems management\n* System deployment\n* Software release\n* Definitive Media Library\n* Readme\n* Release management\n*Deployment environment\nReferences\nExternal links\n* Standardization efforts\n** [http://www.w3.org/Submission/2004/04/ Solution Installation Schema Submission request to W3C]\n** [http://www.oasis-open.org/committees/sdd/charter.php OASIS Solution Deployment Descriptor TC]\n** [http://www.info.fundp.ac.be/~ven/CIS/OMG/Deployment%20and%20Configuration%20of%20Component-based%20Distributed%20Applications.pdf OMG Specification for Deployment and Configuration of Component-based Distributed Applications] (OMG D&C)\n** [http://jcp.org/en/jsr/detail?id=88 JSR 88: Java EE Application Deployment]\n* Articles\n**\n* Resources\n**[https://www.visualstudio.com/en-us/features/release-management-vs.aspx/ Visual Studio Release Management]"
    }
  ]
}