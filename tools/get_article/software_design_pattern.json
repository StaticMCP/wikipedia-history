{
  "content": [
    {
      "type": "text",
      "text": "# Software design pattern\n\nIn software engineering, a software design pattern or design pattern is a general, reusable solution to a commonly occurring problem in many contexts in software design. A design pattern is not a rigid structure to be transplanted directly into source code. Rather, it is a description or a template for solving a particular type of problem that can be deployed in many different situations. Design patterns can be viewed as formalized best practices that the programmer may use to solve common problems when designing a software application or system.\nObject-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. Patterns that imply mutable state may be unsuited for functional programming languages. Some patterns can be rendered unnecessary in languages that have built-in support for solving the problem they are trying to solve, and object-oriented patterns are not necessarily suitable for non-object-oriented languages.\nDesign patterns may be viewed as a structured approach to computer programming intermediate between the levels of a programming paradigm and a concrete algorithm.\nHistory\nPatterns originated as an architectural concept by Christopher Alexander as early as 1977 in A Pattern Language (cf. his article, \"The Pattern of Streets,\" JOURNAL OF THE AIP, September, 1966, Vol. 32, No. 5, pp.&nbsp;273–278). In 1987, Kent Beck and Ward Cunningham began experimenting with the idea of applying patterns to programming – specifically pattern languages – and presented their results at the OOPSLA conference that year. In the following years, Beck, Cunningham and others followed up on this work.\nDesign patterns gained popularity in computer science after the book Design Patterns: Elements of Reusable Object-Oriented Software was published in 1994  by the so-called \"Gang of Four\" (Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides), which is frequently abbreviated as \"GoF\". That same year, the first Pattern Languages of Programming Conference was held, and the following year the Portland Pattern Repository was set up for documentation of design patterns. The scope of the term remains a matter of dispute. Notable books in the design pattern genre include:\n*\n*\n*\n*\n*\n*\n*\n*\n*\nAlthough design patterns have been applied practically for a long time, formalization of the concept of design patterns languished for several years.\nPractice\nDesign patterns can speed up the development process by providing proven development paradigms. Effective software design requires considering issues that may not become apparent until later in the implementation. Freshly written code can often have hidden, subtle issues that take time to be detected; issues that sometimes can cause major problems down the road. Reusing design patterns can help to prevent such issues, and enhance code readability for those familiar with the patterns.\nSoftware design techniques are difficult to apply to a broader range of problems. Design patterns provide general solutions, documented in a format that does not require specifics tied to a particular problem.\nIn 1996, Christopher Alexander was invited to give a [https://www.patternlanguage.com/archive/ieee.html Keynote Speech] to the 1996 OOPSLA Convention.  Here he reflected on how his work on Patterns in Architecture had developed and his hopes for how the Software Design community could help Architecture extend Patterns to create living structures that use generative schemes that are more like computer code.\nMotif\nA pattern describes a design motif, a.k.a. prototypical micro-architecture, as a set of program constituents (e.g., classes, methods...) and their relationships. A developer adapts the motif to their codebase to solve the problem described by the pattern. The resulting code has structure and organization similar to the chosen motif.\nDomain-specific patterns\nEfforts have also been made to codify design patterns in particular domains, including the use of existing design patterns as well as domain-specific design patterns. Examples include user interface design patterns, information visualization, secure design, \"secure usability\", Web design  and business model design.\nThe annual Pattern Languages of Programming Conference proceedings  include many examples of domain-specific patterns.\nObject-oriented programming\nObject-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. Patterns that imply mutable state may be unsuited for functional programming languages. Some patterns can be rendered unnecessary in languages that have built-in support for solving the problem they are trying to solve, and object-oriented patterns are not necessarily suitable for non-object-oriented languages.\nExamples\nDesign patterns can be organized into groups based on what kind of problem they solve. Creational patterns create objects. Structural patterns organize classes and objects to form larger structures that provide new functionality. Behavioral patterns describe collaboration between objects.\nCreational patterns\n{| class=\"wikitable\"\n|-\n! Name\n! Description\n! In Design Patterns\n! In Code Complete\n! Other\n|-\n| Abstract factory\n| Provide an interface for creating families of related or dependent objects without specifying their concrete classes.\n|\n|\n|\n|-\n| Builder\n| Separate the construction of a complex object from its representation, allowing the same construction process to create various representations.\n|\n|\n|\n|-\n| Dependency Injection\n| A class accepts the objects it requires from an injector instead of creating the objects directly.\n|\n|\n|\n|-\n| Factory method\n| Define an interface for creating a single object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n|\n|\n|\n|-\n| Lazy initialization\n| Tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. This pattern appears in the GoF catalog as \"virtual proxy\", an implementation strategy for the Proxy pattern.\n|\n|\n| }}\n|-\n| Multiton\n| Ensure a class has only named instances, and provide a global point of access to them.\n|\n|\n|\n|-\n| Object pool\n| Avoid expensive acquisition and release of resources by recycling objects that are no longer in use. Can be considered a generalisation of connection pool and thread pool patterns.\n|\n|\n|\n|-\n| Prototype\n| Specify the kinds of objects to create using a prototypical instance, and create new objects from the 'skeleton' of an existing object, thus boosting performance and keeping memory footprints to a minimum.\n|\n|\n|\n|-\n| Resource acquisition is initialization (RAII)\n| Ensure that resources are properly released by tying them to the lifespan of suitable objects.\n|\n|\n|\n|-\n| Singleton\n| Ensure a class has only one instance, and provide a global point of access to it.\n|\n|\n|\n|}\nStructural patterns\n{| class=\"wikitable\"\n|-\n! Name\n! Description\n! In Design Patterns\n! In Code Complete\n! Other\n|-\n| Adapter, Wrapper, or Translator\n| Convert the interface of a class into another interface clients expect. An adapter lets classes work together that could not otherwise because of incompatible interfaces. The enterprise integration pattern equivalent is the translator.\n|\n|\n|\n|-\n| Bridge\n| Decouple an abstraction from its implementation allowing the two to vary independently.\n|\n|\n|\n|-\n| Composite\n| Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n|\n|\n|\n|-\n| Decorator\n| Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionality.\n|\n|\n|\n|-\n| Delegation\n| Extend a class by composition instead of subclassing. The object handles a request by delegating to a second object (the delegate)\n|\n|\n|\n|-\n| Extension object\n| Adding functionality to a hierarchy without changing the hierarchy.\n|\n|\n|\n|-\n| Facade\n| Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\n|\n|\n|\n|-\n| Flyweight\n| Use sharing to support large numbers of similar objects efficiently.\n|\n|\n|\n|-\n| Front controller\n| The pattern relates to the design of Web applications. It provides a centralized entry point for handling requests.\n|\n|\n|\n}}\n|-\n| Marker\n| Empty interface to associate metadata with a class.\n|\n|\n| }}\n|-\n| Module\n| Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity.\n|\n|\n|\n|-\n| Proxy\n| Provide a surrogate or placeholder for another object to control access to it.\n|\n|\n|\n|-\n| Twin\n| Twin allows modeling of multiple inheritance in programming languages that do not support this feature.\n|\n|\n|\n|}\nBehavioral patterns\n{| class=\"wikitable\"\n|-\n! Name\n! Description\n! In Design Patterns\n! In Code Complete\n! Other\n|-\n| Blackboard\n| Artificial intelligence pattern for combining disparate sources of data (see blackboard system)\n|\n|\n|\n|-\n| Chain of responsibility\n| Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\n|\n|\n|\n|-\n| Command\n| Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations.\n|\n|\n|\n|-\n|Fluent interface\n| Design an API to be method chained so that it reads like a DSL. Each method call returns a context through which the next logical method call(s) are made available.\n|\n|\n|\n|-\n| Interpreter\n| Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.\n|\n|\n|\n|-\n| Iterator\n| Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.\n|\n|\n|\n|-\n| Mediator\n| Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it allows their interaction to vary independently.\n|\n|\n|\n|-\n| Memento\n| Without violating encapsulation, capture and externalize an object's internal state allowing the object to be restored to this state later.\n|\n|\n|\n|-\n| Null object\n| Avoid null references by providing a default object.\n|\n|\n|\n|-\n| Observer or Publish/subscribe\n| Define a one-to-many dependency between objects where a state change in one object results in all its dependents being notified and updated automatically.\n|\n|\n|\n|-\n| Servant\n| Define common functionality for a group of classes. The servant pattern is also frequently called helper class or utility class implementation for a given set of classes. The helper classes generally have no objects hence they have all static methods that act upon different kinds of class objects.\n|\n|\n|\n|-\n| Specification\n| Recombinable business logic in a Boolean fashion.\n|\n|\n|\n|-\n| State\n| Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.\n|\n|\n|\n|-\n| Strategy\n| Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n|\n|\n|\n|-\n| Template method\n| Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\n|\n|\n|\n|-\n| Visitor\n| Represent an operation to be performed on instances of a set of classes. Visitor lets a new operation be defined without changing the classes of the elements on which it operates.\n|\n|\n|\n|}\nConcurrency patterns\n{| class=\"wikitable\"\n|-\n! Name\n! Description\n! In POSA2\n! Other\n|-\n| Active Object\n| Decouples method execution from method invocation that reside in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.\n|\n|\n|-\n| Balking\n| Only execute an action on an object when the object is in a particular state.\n|\n|\n|-\n| Binding properties\n| Combining multiple observers to force properties in different objects to be synchronized or coordinated in some way.[http://c2.com/cgi/wiki?BindingProperties Binding Properties]\n|\n|\n|-\n| Compute kernel\n| The same calculation many times in parallel, differing by integer parameters used with non-branching pointer math into shared arrays, such as GPU-optimized Matrix multiplication or Convolutional neural network.\n|\n|\n|-\n| Double-checked locking\n| Reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe manner; only if that succeeds does the actual locking logic proceed.\nCan be unsafe when implemented in some language/hardware combinations. It can therefore sometimes be considered an anti-pattern.\n|\n|\n|-\n| Event-based asynchronous\n| Addresses problems with the asynchronous pattern that occur in multithreaded programs.\n|\n|\n|-\n| Guarded suspension\n| Manages operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed.\n|\n|\n|-\n| Join\n| Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared to the use of threads and locks, this is a high-level programming model.\n|\n|\n|-\n| Lock\n| One thread puts a \"lock\" on a resource, preventing other threads from accessing or modifying it.[http://c2.com/cgi/wiki?LockPattern Lock Pattern]\n|\n|\n|-\n| Messaging design pattern (MDP)\n| Allows the interchange of information (i.e. messages) between components and applications.\n|\n|\n|-\n| Monitor object\n| An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time.\n|\n|\n|-\n| Reactor\n| A reactor object provides an asynchronous interface to resources that must be handled synchronously.\n|\n|\n|-\n| Read-write lock\n| Allows concurrent read access to an object, but requires exclusive access for write operations. An underlying semaphore might be used for writing, and a Copy-on-write mechanism may or may not be used.\n|\n|\n|-\n| Scheduler\n| Explicitly control when threads may execute single-threaded code.\n|\n|\n|-\n| Service handler pattern\n| For each request, a server spawns a dedicated client handler to handle a request. Also referred to as thread-per-session.\n|\n|\n|-\n| Thread pool\n| A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads. Can be considered a special case of the object pool pattern.\n|\n|\n|-\n| Thread-specific storage\n| Static or \"global\" memory local to a thread.\n|\n|\n|-\n| Safe Concurrency with Exclusive Ownership\n| Avoiding the need for runtime concurrent mechanisms, because exclusive ownership can be proven. This is a notable capability of the Rust language, but compile-time checking isn't the only means, a programmer will often manually design such patterns into code - omitting the use of locking mechanism because the programmer assesses that a given variable is never going to be concurrently accessed.\n|\n|\n|-\n| CPU atomic operation\n| x86 and other CPU architectures support a range of atomic instructions that guarantee memory safety for modifying and accessing primitive values (integers). For example, two threads may both increment a counter safely. These capabilities can also be used to implement the mechanisms for other concurrency patterns as above. The C# language uses the [https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0 Interlocked] class for these capabilities.\n|\n|\n|}\nDocumentation\nThe documentation for a design pattern describes the context in which the pattern is used, the forces within the context that the pattern seeks to resolve, and the suggested solution. There is no single, standard format for documenting design patterns. Rather, a variety of different formats have been used by different pattern authors. However, according to Martin Fowler, certain pattern forms have become more well-known than others, and consequently become common starting points for new pattern-writing efforts. One example of a commonly used documentation format is the one used by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides in their book Design Patterns. It contains the following sections:\n*Pattern Name and Classification: A descriptive and unique name that helps in identifying and referring to the pattern.\n*Intent: A description of the goal behind the pattern and the reason for using it.\n*Also Known As: Other names for the pattern.\n*Motivation (Forces): A scenario consisting of a problem and a context in which this pattern can be used.\n*Applicability: Situations in which this pattern is usable; the context for the pattern.\n*Structure: A graphical representation of the pattern. Class diagrams and Interaction diagrams may be used for this purpose.\n*Participants: A listing of the classes and objects used in the pattern and their roles in the design.\n*Collaboration: A description of how classes and objects used in the pattern interact with each other.\n*Consequences: A description of the results, side effects, and trade offs caused by using the pattern.\n*Implementation: A description of an implementation of the pattern; the solution part of the pattern.\n*Sample Code: An illustration of how the pattern can be used in a programming language.\n*Known Uses: Examples of real usages of the pattern.\n*Related Patterns: Other patterns that have some relationship with the pattern; discussion of the differences between the pattern and similar patterns.\nCriticism\nSome suggest that design patterns may be a sign that features are missing in a given programming language (Java or C++ for instance). Peter Norvig demonstrates that 16 out of the 23 patterns in the Design Patterns book (which is primarily focused on C++) are simplified or eliminated (via direct language support) in Lisp or Dylan. Related observations were made by Hannemann and Kiczales who implemented several of the 23 design patterns using an aspect-oriented programming language (AspectJ) and showed that code-level dependencies were removed from the implementations of 17 of the 23 design patterns and that aspect-oriented programming could simplify the implementations of design patterns.\nSee also Paul Graham's essay \"Revenge of the Nerds\".\nInappropriate use of patterns may unnecessarily increase complexity. [https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition FizzBuzzEnterpriseEdition] offers a humorous example of over-complexity introduced by design patterns.\nBy definition, a pattern must be programmed anew into each application that uses it. Since some authors see this as a step backward from software reuse as provided by components, researchers have worked to turn patterns into components. Meyer and Arnout were able to provide full or partial componentization of two-thirds of the patterns they attempted.\nIn order to achieve flexibility, design patterns may introduce additional levels of indirection, which may complicate the resulting design and decrease runtime performance.\nRelationship to other topics\nSoftware design patterns offer finer granularity compared to software architecture patterns and software architecture styles, as design patterns focus on solving detailed, low-level design problems within individual components or subsystems. Examples include Singleton, Factory Method, and Observer.\nSoftware Architecture Pattern refers to a reusable, proven solution to a recurring problem at the system level, addressing concerns related to the overall structure, component interactions, and quality attributes of the system. Software architecture patterns operate at a higher level of abstraction than design patterns, solving broader system-level challenges. While these patterns typically affect system-level concerns, the distinction between architectural patterns and architectural styles can sometimes be blurry. Examples include Circuit Breaker.\nSoftware Architecture Style refers to a high-level structural organization that defines the overall system organization, specifying how components are organized, how they interact, and the constraints on those interactions. Architecture styles typically include a vocabulary of component and connector types, as well as semantic models for interpreting the system's properties. These styles represent the most coarse-grained level of system organization. Examples include Layered Architecture, Microservices, and Event-Driven Architecture.\nSee also\n*Abstraction principle\n*Algorithmic skeleton\n*Anti-pattern\n*Architectural pattern\n*Canonical protocol pattern\n*Debugging patterns\n*Design pattern\n*Distributed design patterns\n*Enterprise Architecture framework\n*GRASP (object-oriented design)\n*Helper class\n*Idiom in programming\n*Interaction design pattern\n*List of software architecture styles and patterns\n*List of software development philosophies\n*List of software engineering topics\n*Pattern language\n*Pattern theory\n*Pedagogical patterns\n*Portland Pattern Repository\n*Refactoring\n*Software development methodology\nReferences\nFurther reading\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*"
    }
  ]
}