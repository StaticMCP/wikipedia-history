{
  "content": [
    {
      "type": "text",
      "text": "# Software fault tolerance__disambig_1\n\nSoftware fault tolerance is the ability of computer software to continue its normal operation despite the presence of system or hardware faults. Fault-tolerant software has the ability to satisfy requirements despite failures.\nFollowing design patterns should be combined to make the system more fault tolerant: retry, fallback, timeout, circuit breaker, and bulkhead pattern.\nTo make your system more fault tolerant, you should measure 99th percentile latency and keep the remaining 1% (aka tail latencies) in check through self healing mechanisms.\nIntroduction\nThe only thing constant is change. This is certainly more true of software systems than almost any phenomenon, not all software change in the same way so software fault tolerance methods are designed to overcome execution errors by modifying variable values to create an acceptable program state. The need to control software fault is one of the most rising challenges facing software industries today. Fault tolerance must be a key consideration in the early stage of software development.\nThere exist different mechanisms for software fault tolerance, among which:\n* Recovery blocks\n* N-version software\n* Self-checking software\nOperating system failure\nComputer applications make a call using the application programming interface (API) to access shared resources, like the keyboard, mouse, screen, disk drive, network, and printer. These can fail in two ways.\n* Blocked Calls\n* Faults\nBlocked calls\nA blocked call is a request for services from the operating system that halts the computer program until results are available.\nAs an example, the TCP call blocks until a response becomes available from a remote server. This occurs every time you perform an action with a web browser. Intensive calculations cause lengthy delays with the same effect as a blocked API call.\nThere are two methods used to handle blocking.\n* Threads\n* Timers\nThreading allows a separate sequence of execution for each API call that can block. This can prevent the overall application from stalling while waiting for a resource. This has the benefit that none of the information about the state of the API call is lost while other activities take place.\nThreaded languages include the following.\n{| class=\"wikitable\"\n|-\n| Ada || Afnix || C++ || C# || CILK || Eiffel || Erlang\n|-\n| Java || Lisp || Magenta || Modula 3 || Napier 88 || Oz || Presto\n|-\n| pSather || Perl 5.8.7+ || PHP || Python || R || Ruby || Smalltalk\n|-\n| Tcl/Tk || V || Unicon || Ballerina || D || ||\n|}\nTimers allow a blocked call to be interrupted. A periodic timer allows the programmer to emulate threading. Interrupts typically destroy any information related to the state of a blocked API call or intensive calculation, so the programmer must keep track of this information separately.\nUn-threaded languages include the following.\n{| class=\"wikitable\"\n|-\n| Bash || JavaScript || SQL || Visual Basic\n|}\nCorrupted state will occur with timers. This is avoided with the following.\n* Track software state\n* Semaphore\n* Blocking\nFaults\nFault are induced by signals in POSIX compliant systems, and these signals originate from API calls, from the operating system, and from other applications.\nAny signal that does not have handler code becomes a fault that causes premature application termination.\nThe handler is a function that is performed on-demand when the application receives a signal. This is called exception handling.\nThe termination signal is the only signal that cannot be handled. All other signals can be directed to a handler function.\nHandler functions come in two broad varieties.\n* Initialized\n* In-line\nInitialized handler functions are paired with each signal when the software starts. This causes the handler function to startup when the corresponding signal arrives. This technique can be used with timers to emulate threading.\nIn-line handler functions are associated with a call using specialized syntax. The most familiar is the following used with C++ and Java.\n:try\n:{\n::API_call();\n:}\n:catch\n:{\n::signal_handler_code;\n:}\nHardware failure\nHardware fault tolerance for software requires the following.\n* Backup\n* Redundancy\nBackup maintains information in the event that hardware must be replaced. This can be done in one of two ways.\n* Automatic scheduled backup using software\n* Manual backup on a regular schedule\n* Information restore\nBackup requires an information-restore strategy to make backup information available on a replacement system. The restore process is usually time-consuming, and information will be unavailable until the restore process is complete.\nRedundancy relies on replicating information on more than one computer computing device so that the recovery delay is brief. This can be achieved using continuous backup to a live system that remains inactive until needed (synchronized backup).\nThis can also be achieved by replicating information as it is created on multiple identical systems, which can eliminate recovery delay.\nSee also\n*Built-in self-test\n*Built-in test equipment\n*Logic built-in self-test\n*N-version programming\n*Safety engineering\n*OpenSAF - Service Availability API\nReferences\nFurther reading\n* [http://www.ece.cmu.edu/~koopman/des_s99/sw_fault_tolerance Software fault tolerance, by Chris Inacio at Carnegie Mellon University  (1998)]"
    }
  ]
}