{
  "content": [
    {
      "type": "text",
      "text": "# History of software configuration management\n\n}}\nThe history of software configuration management (SCM) can be traced back as early as the 1950s, when CM (configuration management), originally for hardware development and production control, was being applied to software development. Early software had a physical footprint, such as cards, tapes, and other media. The first software configuration management was a manual operation. With the advances in language and complexity, software engineering, involving configuration management and other methods, became a major concern due to issues like schedule, budget, and quality. Practical lessons, over the years, had led to the definition, and establishment, of procedures and tools. Eventually, the tools became systems to manage software changes. Industry-wide practices were offered as solutions, either in an open or proprietary manner (such as Revision Control System). With the growing use of computers, systems emerged that handled a broader scope, including requirements management, design alternatives, quality control, and more; later tools followed the guidelines of organizations, such as the Capability Maturity Model of the Software Engineering Institute.\nTimeline\n* Early 1960s or even late 1950s: CDC UPDATE and IBM IEB_UPDATE.\n* Late 1960s into 1970s: The Librarian is released by Applied Data Research and provides an alternative to keeping programs on punched card decks for the IBM mainframe market.\n* Late 1960s, early 1970s: Professor Leon Pressor at the University of California, Santa Barbara produced a thesis on change and configuration control.  This concept was a response to a contract he was working on with a defense contractor who made aircraft engines for the US Navy.\n* Early 1970s: Unix make.\n* By 1970 CDC update was an advanced product.\n* Circa 1972: Bell Labs paper describing the original diff algorithm.\n* 1972, with an IEEE paper in 1975: source code control system, SCCS, Marc Rochkind Bell Labs. Originally programmed in SNOBOL for OS/360; subsequently rewritten in C for Unix (used diff for comparing files).\n* 1970s: Lisle, Illinois-based Pansophic Systems offered PANVALET, which was an early source code control system for the mainframe market.\n* 1975: Professor Pressor's work eventually grew into a commercially available product called Change and Configuration Control (CCC) which was sold by the SoftTool corporation.\n* Revision Control System (RCS, Walter Tichy).\n* Early 1980s: patch (around 1985, Larry Wall).\n* 1984: Aide-de-Camp\n* 1986: Concurrent Version System (CVS).\n* 2000: Subversion initiated by CollabNet.\n* Early 2000s (decade): distributed revision control systems like BitKeeper and GNU arch become viable.\nBackground\nUntil the 1980s, SCM could only be understood as CM applied to software development. Some basic concepts such as identification and baseline (well-defined point in the evolution of a project) were already clear, but what was at stake was a set of techniques oriented towards the control of the activity, and using formal processes, documents, request forms, control boards etc.\nIt is only after this date that the use of software tools applying directly to software artefacts representing the actual resources, has allowed SCM to grow as an autonomous entity (from traditional CM).\nThe use of different tools has actually led to very distinct emphases.\n* traditional CM for Software, typically around Change Management (examples: Continuus, CVS or ClearCase UCM)\n* line oriented management, based on patches or Change Sets\n* focused on Derived Objects and Build Management (example: Base ClearCase/clearmake)\nEvolution\nFirst generation\nSCCS (first released in 1973) and DSEE (considered a predecessor of Atria ClearCase), described in 1984, are two other notable VCS software tools. These tools, along with Revision Control System (RCS), are generally considered the first generation of VCS as automated software tools.\nSecond generation\nAfter the first generation VCS, tools such as CVS and Subversion, which feature a locally centralized repository, could be considered as the second generation VCS. Specifically, CVS (Concurrent Versions System) was developed on top of RCS structure, improving scalability of the tool for larger groups, and later PRCS, a simpler CVS-like tool which also uses RCS-like files, but improves upon the delta compression by using Xdelta instead.\nBy 2006 or so, Subversion was considered to be the most popular and widely in use VCS tool from this generation and filled important weaknesses of CVS. Later SVK developed with the goal of remote contribution feature, but still the foundation of its design were similar to its predecessors.\nThird generation\nAs Internet connectivity improved and geographically distributed software development became more common, tools emerged that did not rely on a shared central project repository. These allow users to maintain independent repositories (or forks) of a project and communicate revisions via changesets.\nBitKeeper, Git, Monotone, darcs, Mercurial, and bzr\nare some examples of third generation version control systems.\nSee also\n*\nReferences"
    }
  ]
}