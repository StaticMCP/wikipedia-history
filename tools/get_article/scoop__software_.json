{
  "content": [
    {
      "type": "text",
      "text": "# SCOOP (software)\n\nSCOOP (Simple Concurrent Object Oriented Programming) is a concurrency model designed for the Eiffel programming language, conceived by Eiffel's creator and designer, Bertrand Meyer.\nSCOOP defines a way for an object oriented program to be written without the concept of threads, locks, or other typical multiprogramming methods.  This allows the compiler or runtime environment to optimize the amount of concurrency as well as eliminate typical design flaws such as deadlock.\nThe model was first designed in the early 1990s and published in 1993 in the Communications of the ACM An updated version was described in chapter 30 of the book Object-Oriented Software Construction.\nA prototype implementation was developed in 1995 by Eiffel Software. An article by Compton and Walker provides an overview of SCOOP and describes another early implementation. Nienaltowski, Arslan and Meyer have published a description of the model as of 2003. Work on SCOOP proceeded at the Chair of Software Engineering at ETH Zurich. SCOOP became available as a standard part of EiffelStudio early in 2011.\nTechnical overview\nSCOOP works by allowing references to certain objects to be declared as separate. In the code below, an entity local_inventory is declared as a separate type, by specifying the Eiffel language keyword separate in the declaration.\nlocal_inventory: separate INVENTORY\nA separate object may be handled by a SCOOP processor that is different from the processor handling the referencing object. A SCOOP processor is the abstract notion of an autonomous thread of control that handles the execution of operations on one or more objects. SCOOP processors are independent of underlying concurrency mechanisms like processor threads, multiple processor cores, and distributed computer systems.\nIn addition to the concept of separateness, SCOOP exploits the principles of design by contract as part of the SCOOP strategy for synchronizing access to shared separate resources. For example, a precondition for a consumer wishing to access an item in the inventory example above, might be that such an item does currently exist. This would be expressed with a contract on the feature of class INVENTORY which returns the item.\nitem: PRODUCT\n-- Current item\nrequire\ninventory_has_item: has_item\nIn traditional, sequential processing, a client intending to call local_inventory.item would be responsible for making certain that the precondition local_inventory.has_item holds before making the call. If the call to item were made in a state in which has_item did not hold, the caller would incur a precondition violation exception.\nIn the presence of SCOOP and given the separateness of local_inventory, making the check on has_item before calling item would not be reliable. This is because the state of local_inventory could have been changed by requests from other SCOOP processors between the time that the check was made and the time that item could be called.\nAs a result, when SCOOP is enabled, the precondition has_item is transformed from a correctness condition, which will cause an exception in the case of a violation, to a wait condition. The wait condition will cause the execution of item to be delayed until such time as has_item holds. In the Eiffel Software implementation, if SCOOP is not enabled, the separate keyword is ignored and sequential processing is assumed.\nSee also\n*Eiffel\n*Object-Oriented Software Construction\nReferences\nExternal links\n* Eiffel Software [http://docs.eiffel.com/book/solutions/concurrent-eiffel-scoop online documentation for SCOOP].\n* The [http://se.ethz.ch/research/scoop SCOOP research page at ETH Zurich].\nes:Computación concurrente\nfr:Programmation concurrente\nnl:Multiprogrammeren\npt:Programação concorrente"
    }
  ]
}