{
  "content": [
    {
      "type": "text",
      "text": "# Software archaeology\n\nSoftware archaeology or source code archeology is the study of poorly documented or undocumented legacy software implementations, as part of software maintenance. Software archaeology, named by analogy with archaeology, includes the reverse engineering of software modules, and the application of a variety of tools and processes for extracting and understanding program structure and recovering design information. Software archaeology may reveal dysfunctional team processes which have produced poorly designed or even unused software modules, and in some cases deliberately obfuscatory code may be found. The term has been in use for decades.\nSoftware archaeology has continued to be a topic of discussion at more recent software engineering conferences.\nTechniques\nA workshop on Software Archaeology at the 2001 OOPSLA (Object-Oriented Programming, Systems, Languages & Applications) conference identified the following software archaeology techniques, some of which are specific to object-oriented programming:\n*Scripting languages to build static reports and for filtering diagnostic output\n*Ongoing documentation in HTML pages or Wikis\n*Synoptic signature analysis, statistical analysis, and software visualization tools\n*Reverse-engineering tools\n*Operating-system-level tracing via truss or strace\n*Search engines and tools to search for keywords in source files\n*IDE file browsing\n*Unit testing frameworks such as JUnit and CppUnit\n*API documentation generation using tools such as Javadoc and Doxygen\n*Debuggers\nMore generally, Andy Hunt and Dave Thomas note the importance of version control, dependency management, text indexing tools such as GLIMPSE and SWISH-E, and \"[drawing] a map as you begin exploring.\"\nLike true archaeology, software archaeology involves investigative work to understand the thought processes of one's predecessors. At the OOPSLA workshop, Ward Cunningham suggested a synoptic signature analysis technique which gave an overall \"feel\" for a program by showing only punctuation, such as semicolons and curly braces. In the same vein, Cunningham has suggested viewing programs in 2 point font in order to understand the overall structure. Another technique identified at the workshop was the use of aspect-oriented programming tools such as AspectJ to systematically introduce tracing code without directly editing the legacy program.\nNetwork and temporal analysis techniques can reveal the patterns of collaborative activity by the developers of legacy software, which in turn may shed light on the strengths and weaknesses of the software artifacts produced.\nMichael Rozlog of Embarcadero Technologies has described software archaeology as a six-step process which enables programmers to answer questions such as \"What have I just inherited?\" and \"Where are the scary sections of the code?\" These steps, similar to those identified by the OOPSLA workshop, include using visualization to obtain a visual representation of the program's design, using software metrics to look for design and style violations, using unit testing and profiling to look for bugs and performance bottlenecks, and assembling design information recovered by the process. Software archaeology can also be a service provided to programmers by external consultants.\nIn popular culture\nThe profession of \"programmerâ€“archaeologist\" features prominently in Vernor Vinge's 1999 sci-fi novel A Deepness in the Sky.\nSee also\n*\n*\n*\n*\n*\n*\n*\nReferences\nExternal links\n*\n*\n*\n*"
    }
  ]
}