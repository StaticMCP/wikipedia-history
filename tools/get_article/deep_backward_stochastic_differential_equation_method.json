{
  "content": [
    {
      "type": "text",
      "text": "# Deep backward stochastic differential equation method\n\nDeep backward stochastic differential equation method is a numerical method that combines deep learning with Backward stochastic differential equation (BSDE). This method is particularly useful for solving high-dimensional problems in financial derivatives pricing and risk management. By leveraging the powerful function approximation capabilities of deep neural networks, deep BSDE addresses the computational challenges faced by traditional numerical methods in high-dimensional settings.\nHistory\nBackwards stochastic differential equations\nBSDEs were first introduced by Pardoux and Peng in 1990 and have since become essential tools in stochastic control and financial mathematics. In the 1990s, Étienne Pardoux and Shige Peng established the existence and uniqueness theory for BSDE solutions, applying BSDEs to financial mathematics and control theory. For instance, BSDEs have been widely used in option pricing, risk measurement, and dynamic hedging.\nDeep learning\nDeep Learning is a machine learning method based on multilayer neural networks. Its core concept can be traced back to the neural computing models of the 1940s. In the 1980s, the proposal of the backpropagation algorithm made the training of multilayer neural networks possible. In 2006, the Deep Belief Networks proposed by Geoffrey Hinton and others rekindled interest in deep learning. Since then, deep learning has made groundbreaking advancements in image processing, speech recognition, natural language processing, and other fields.\nLimitations of traditional numerical methods\nTraditional numerical methods for solving stochastic differential equations include the Euler–Maruyama method, Milstein method, Runge–Kutta method (SDE) and methods based on different representations of iterated stochastic integrals.\nBut as financial problems become more complex, traditional numerical methods for BSDEs (such as the Monte Carlo method, finite difference method, etc.) have shown limitations such as high computational complexity and the curse of dimensionality.\n#In high-dimensional scenarios, the Monte Carlo method requires numerous simulation paths to ensure accuracy, resulting in lengthy computation times. In particular, for nonlinear BSDEs, the convergence rate is slow, making it challenging to handle complex financial derivative pricing problems.\n#The finite difference method, on the other hand, experiences exponential growth in the number of computation grids with increasing dimensions, leading to significant computational and storage demands. This method is generally suitable for simple boundary conditions and low-dimensional BSDEs, but it is less effective in complex situations.\nDeep BSDE method\nThe combination of deep learning with BSDEs, known as deep BSDE, was proposed by Han, Jentzen, and E in 2018 as a solution to the high-dimensional challenges faced by traditional numerical methods. The Deep BSDE approach leverages the powerful nonlinear fitting capabilities of deep learning, approximating the solution of BSDEs by constructing neural networks. The specific idea is to represent the solution of a BSDE as the output of a neural network and train the network to approximate the solution.\nModel\nMathematical method\nBackward Stochastic Differential Equations (BSDEs) represent a powerful mathematical tool extensively applied in fields such as stochastic control, financial mathematics, and beyond. Unlike traditional Stochastic differential equations (SDEs), which are solved forward in time, BSDEs are solved backward, starting from a future time and moving backwards to the present. This unique characteristic makes BSDEs particularly suitable for problems involving terminal conditions and uncertainties.\nA backward stochastic differential equation (BSDE) can be formulated as:\n: Y_t = \\xi + \\int_t^T f(s, Y_s, Z_s) \\, ds - \\int_t^T Z_s \\, dW_s, \\quad t \\in [0, T]\nIn this equation:\n*  \\xi  is the terminal condition specified at time  T .\n* f:[0,T]\\times\\mathbb{R}\\times\\mathbb{R}\\to\\mathbb{R} is called the generator of the BSDE\n*(Y_t,Z_t)_{t\\in[0,T]} is the solution consists of stochastic processes (Y_t)_{t\\in[0,T]} and (Z_t)_{t\\in[0,T]} which are adapted to the filtration (\\mathcal{F}_t)_{t\\in [0,T]}\n*  W_s  is a standard Brownian motion.\nThe goal is to find adapted processes  Y_t  and  Z_t  that satisfy this equation. Traditional numerical methods struggle with BSDEs due to the curse of dimensionality, which makes computations in high-dimensional spaces extremely challenging.\nMethodology overview\nSource:\n1. Semilinear parabolic PDEs\nWe consider a general class of PDEs represented by\n\\frac{\\partial u}{\\partial t}(t,x) + \\frac{1}{2} \\text{Tr}\\left(\\sigma\\sigma^T(t,x)\\left(\\text{Hess}_x u(t,x)\\right)\\right) + \\nabla u(t,x) \\cdot \\mu(t,x) + f\\left(t,x,u(t,x),\\sigma^T(t,x)\\nabla u(t,x)\\right) = 0\nIn this equation:\n*  u(T,x) = g(x)  is the terminal condition specified at time  T .\n*  t  and  x  represent the time and  d -dimensional space variable, respectively.\n*  \\sigma  is a known vector-valued function,  \\sigma^T  denotes the transpose associated to  \\sigma , and  \\text{Hess}_x u  denotes the Hessian of function  u  with respect to  x .\n*  \\mu  is a known vector-valued function, and  f  is a known nonlinear function.\n2. Stochastic process representation\nLet  \\{W_t\\}_{t \\geq 0}  be a  d -dimensional Brownian motion and  \\{X_t\\}_{t \\geq 0}  be a  d -dimensional stochastic process which satisfies\nX_t = \\xi + \\int_0^t \\mu(s, X_s) \\, ds + \\int_0^t \\sigma(s, X_s) \\, dW_s\n3. Backward stochastic differential equation (BSDE)\nThen the solution of the PDE satisfies the following BSDE:\nu(t, X_t) - u(0, X_0)\n:= - \\int_0^t f\\left(s, X_s, u(s, X_s), \\sigma^T(s, X_s)\\nabla u(s, X_s)\\right) \\, ds + \\int_0^t \\nabla u(s, X_s) \\cdot \\sigma(s, X_s) \\, dW_s\n4. Temporal discretization\nDiscretize the time interval  [0, T]  into steps  0 = t_0 :\nX_{t_{n+1}} - X_{t_n} \\approx \\mu(t_n, X_{t_n}) \\Delta t_n + \\sigma(t_n, X_{t_n}) \\Delta W_n\nu(t_n, X_{t_{n+1}}) - u(t_n, X_{t_n})\n:\\approx - f\\left(t_n, X_{t_n}, u(t_n, X_{t_n}), \\sigma^T(t_n, X_{t_n}) \\nabla u(t_n, X_{t_n})\\right) \\Delta t_n + \\left[\\nabla u(t_n, X_{t_n}) \\sigma(t_n, X_{t_n})\\right] \\Delta W_n\nwhere  \\Delta t_n = t_{n+1} - t_n  and  \\Delta W_n = W_{t_{n+1}} - W_n .\n5. Neural network approximation\nUse a multilayer feedforward neural network to approximate:\n\\sigma^T(t_n, X_n) \\nabla u(t_n, X_n) \\approx (\\sigma^T \\nabla u)(t_n, X_n; \\theta_n)\nfor  n = 1, \\ldots, N , where  \\theta_n  are parameters of the neural network approximating  x \\mapsto \\sigma^T(t, x) \\nabla u(t, x)  at  t = t_n .\n6. Training the neural network\nStack all sub-networks in the approximation step to form a deep neural network. Train the network using paths  \\{X_{t_n}\\}_{0 \\leq n \\leq N}  and  \\{W_{t_n}\\}_{0 \\leq n \\leq N}  as input data, minimizing the loss function:\nl(\\theta) = \\mathbb{E} \\left| g(X_{t_N}) - \\hat{u}\\left(\\{X_{t_n}\\}_{0 \\leq n \\leq N}, \\{W_{t_n}\\}_{0 \\leq n \\leq N}; \\theta \\right) \\right|^2\nwhere  \\hat{u}  is the approximation of  u(t, X_t) .\nNeural network architecture\nSource:\nDeep learning encompass a class of machine learning techniques that have transformed numerous fields by enabling the modeling and interpretation of intricate data structures. These methods, often referred to as deep learning, are distinguished by their hierarchical architecture comprising multiple layers of interconnected nodes, or neurons. This architecture allows deep neural networks to autonomously learn abstract representations of data, making them particularly effective in tasks such as image recognition, natural language processing, and financial modeling. The core of this method lies in designing an appropriate neural network structure (such as fully connected networks or recurrent neural networks) and selecting effective optimization algorithms.\nThe choice of deep BSDE network architecture, the number of layers, and the number of neurons per layer are crucial hyperparameters that significantly impact the performance of the deep BSDE method. The deep BSDE method constructs neural networks to approximate the solutions for  Y  and  Z , and utilizes stochastic gradient descent and other optimization algorithms for training.\nThe fig illustrates the network architecture for the deep BSDE method. Note that  \\nabla u(t_n, X_{t_n})  denotes the variable approximated directly by subnetworks, and  u(t_n, X_{t_n})  denotes the variable computed iteratively in the network. There are three types of connections in this network:\ni)  X_{t_n} \\rightarrow h_1^n \\rightarrow h_2^n \\rightarrow \\ldots \\rightarrow h_H^n \\rightarrow \\nabla u(t_n, X_{t_n})  is the multilayer feedforward neural network approximating the spatial gradients at time  t = t_n . The weights  \\theta_n  of this subnetwork are the parameters optimized.\nii)  (u(t_n, X_{t_n}), \\nabla u(t_n, X_{t_n}), W_{t_n+1} - W_{t_n}) \\rightarrow u(t_{n+1}, X_{t_{n+1}})  is the forward iteration providing the final output of the network as an approximation of  u(t_N, X_{t_N}) , characterized by Eqs. 5 and 6. There are no parameters optimized in this type of connection.\niii)  (X_{t_n}, W_{t_n+1} - W_{t_n}) \\rightarrow X_{t_{n+1}}  is the shortcut connecting blocks at different times, characterized by Eqs. 4 and 6. There are also no parameters optimized in this type of connection.\nAlgorithms\nAdam optimizer\nThis function implements the Adam algorithm for minimizing the target function \\mathcal{G}(\\theta).\nFunction: ADAM(\\alpha, \\beta_1, \\beta_2, \\epsilon, \\mathcal{G}(\\theta), \\theta_0) is\nm_0 := 0 // Initialize the first moment vector\nv_0 := 0 // Initialize the second moment vector\nt := 0   // Initialize timestep\n// Step 1: Initialize parameters\n\\theta_t := \\theta_0\n// Step 2: Optimization loop\nwhile \\theta_t has not converged do\nt := t + 1\ng_t := \\nabla_\\theta \\mathcal{G}_t(\\theta_{t-1}) // Compute gradient of \\mathcal{G} at timestep t\nm_t := \\beta_1 \\cdot m_{t-1} + (1 - \\beta_1) \\cdot g_t // Update biased first moment estimate\nv_t := \\beta_2 \\cdot v_{t-1} + (1 - \\beta_2) \\cdot g_t^2 // Update biased second raw moment estimate\n\\widehat{m}_t := \\frac{m_t}{(1 - \\beta_1^t)} // Compute bias-corrected first moment estimate\n\\widehat{v}_t := \\frac{v_t}{(1 - \\beta_2^t)} // Compute bias-corrected second moment estimate\n\\theta_t := \\theta_{t-1} - \\frac{\\alpha \\cdot \\widehat{m}_t}{(\\sqrt{\\widehat{v}_t} + \\epsilon)} // Update parameters\nreturn \\theta_t\n* With the ADAM algorithm described above, we now present the pseudocode corresponding to a multilayer feedforward neural network:\nBackpropagation algorithm\nThis function implements the backpropagation algorithm for training a multi-layer feedforward neural network.\nFunction: BackPropagation(set D=\\left\\{(\\mathbf{x}_k,\\mathbf{y}_k)\\right\\}_{k=1}^{m}) is\n// Step 1: Random initialization\n// Step 2: Optimization loop\nrepeat until termination condition is met:\nfor each (\\mathbf{x}_k,\\mathbf{y}_k) \\in D:\n\\hat{\\mathbf{y}}_k := f(\\beta_j - \\theta_j) // Compute output\n// Compute gradients\nfor each output neuron j:\ng_j := \\hat{y}_{j}^{k} (1 - \\hat{y}_{j}^{k}) (\\hat{y}_{j}^{k} - y_{j}^{k}) // Gradient of output neuron\nfor each hidden neuron h:\ne_h := b_h (1 - b_h) \\sum_{j=1}^{\\ell} w_{hj} g_{j} // Gradient of hidden neuron\n// Update weights\nfor each weight w_{hj}:\n\\Delta w_{hj} := \\eta g_j b_h // Update rule for weight\nfor each weight v_{ih}:\n\\Delta v_{ih} := \\eta e_h x_i // Update rule for weight\n// Update parameters\nfor each parameter \\theta_j:\n\\Delta \\theta_j := -\\eta g_j // Update rule for parameter\nfor each parameter \\gamma_{h}:\n\\Delta \\gamma_{h} := -\\eta e_h // Update rule for parameter\n// Step 3: Construct the trained multi-layer feedforward neural network\nreturn trained neural network\n* Combining the ADAM algorithm and a multilayer feedforward neural network, we provide the following pseudocode for solving the optimal investment portfolio:\nNumerical solution for optimal investment portfolio\nSource:\nThis function calculates the optimal investment portfolio using the specified parameters and stochastic processes.\nfunction OptimalInvestment(W_{t_{i+1}} - W_{t_i}, x, \\theta=(X_{0}, H_{0}, \\theta_{1}, \\theta_{2}, \\dots, \\theta_{N-1})) is\n// Step 1: Initialization\nfor k := 0 to maxstep do\nM_0^{k, m} := 0, X_0^{k, m} := X_0^k // Parameter initialization\nfor i := 0 to N-1 do\nH_{t_i}^{k, m} := \\mathcal{NN}(M_{t_i}^{k, m}; \\theta_i^k) // Update feedforward neural network unit\nM_{t_{i+1}}^{k, m} := M_{t_{i}}^{k, m} + \\big((1 - \\phi)(\\mu_{t_{i}} - M_{t_{i}}^{k, m})\\big)(t_{i+1} - t_{i}) + \\sigma_{t_{i}}(W_{t_{i+1}} - W_{t_{i}})\nX_{t_{i+1}}^{k, m} := X_{t_{i}}^{k, m} + \\big[H_{t_{i}}^{k, m}(\\phi (M_{t_{i}}^{k, m} - \\mu_{t_{i}}) + \\mu_{t_{i}})\\big](t_{i+1} - t_{i}) + H_{t_{i}}^{k, m} (W_{t_{i+1}} - W_{t_{i}})\n// Step 2: Compute loss function\n\\mathcal{L}(t) := \\frac{1}{M} \\sum_{m=1}^M \\left| X_{t_N}^{k, m} - g(M_{t_N}^{k, m}) \\right|^2\n// Step 3: Update parameters using ADAM optimization\n\\theta^{k+1} := \\operatorname{ADAM}(\\theta^k, \\nabla \\mathcal{L}(t))\nX_0^{k+1} := \\operatorname{ADAM}(X_0^k, \\nabla \\mathcal{L}(t))\n// Step 4: Return terminal state\nreturn (M_{t_N}, X_{t_N})\nApplication\nDeep BSDE is widely used in the fields of financial derivatives pricing, risk management, and asset allocation. It is particularly suitable for:\n* High-Dimensional Option Pricing: Pricing complex derivatives like basket options and Asian options, which involve multiple underlying assets. Traditional methods such as finite difference methods and Monte Carlo simulations struggle with these high-dimensional problems due to the curse of dimensionality, where the computational cost increases exponentially with the number of dimensions. Deep BSDE methods utilize the function approximation capabilities of deep neural networks to manage this complexity and provide accurate pricing solutions. The deep BSDE approach is particularly beneficial in scenarios where traditional numerical methods fall short. For instance, in high-dimensional option pricing, methods like finite difference or Monte Carlo simulations face significant challenges due to the exponential increase in computational requirements with the number of dimensions. Deep BSDE methods overcome this by leveraging deep learning to approximate solutions to high-dimensional PDEs efficiently.\n* Risk Measurement: Calculating risk measures such as Conditional Value-at-Risk (CVaR) and Expected shortfall (ES). These risk measures are crucial for financial institutions to assess potential losses in their portfolios. Deep BSDE methods enable efficient computation of these risk metrics even in high-dimensional settings, thereby improving the accuracy and robustness of risk assessments. In risk management, deep BSDE methods enhance the computation of advanced risk measures like CVaR and ES, which are essential for capturing tail risk in portfolios. These measures provide a more comprehensive understanding of potential losses compared to simpler metrics like Value-at-Risk (VaR). The use of deep neural networks enables these computations to be feasible even in high-dimensional contexts, ensuring accurate and reliable risk assessments.\n* Dynamic Asset Allocation: Determining optimal strategies for asset allocation over time in a stochastic environment. This involves creating investment strategies that adapt to changing market conditions and asset price dynamics. By modeling the stochastic behavior of asset returns and incorporating it into the allocation decisions, deep BSDE methods allow investors to dynamically adjust their portfolios, maximizing expected returns while managing risk effectively. For dynamic asset allocation, deep BSDE methods offer significant advantages by optimizing investment strategies in response to market changes. This dynamic approach is critical for managing portfolios in a stochastic financial environment, where asset prices are subject to random fluctuations. Deep BSDE methods provide a framework for developing and executing strategies that adapt to these fluctuations, leading to more resilient and effective asset management.\nAdvantages and disadvantages\nAdvantages\nSources:\n# High-dimensional capability: Compared to traditional numerical methods, deep BSDE performs exceptionally well in high-dimensional problems.\n# Flexibility: The incorporation of deep neural networks allows this method to adapt to various types of BSDEs and financial models.\n# Parallel computing: Deep learning frameworks support GPU acceleration, significantly improving computational efficiency.\nDisadvantages\nSources:\n# Training time: Training deep neural networks typically requires substantial data and computational resources.\n# Parameter sensitivity: The choice of neural network architecture and hyperparameters greatly impacts the results, often requiring experience and trial-and-error.\nSee also\n* Bellman equation\n* Dynamic programming\n* Applications of artificial intelligence\n* List of artificial intelligence projects\n* Backward stochastic differential equation\n* Stochastic process\n* Stochastic volatility\n* Stochastic partial differential equations\n* Diffusion process\n* Stochastic difference equation\nReferences\nFurther reading\n*\n*\n* Evans, Lawrence C. (2013). [https://bookstore.ams.org/mbk-82 An Introduction to Stochastic Differential Equations] American Mathematical Society.\n*\n* Desmond Higham and Peter Kloeden: \"An Introduction to the Numerical Simulation of Stochastic Differential Equations\", SIAM,  (2021)."
    }
  ]
}