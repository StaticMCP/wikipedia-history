{
  "content": [
    {
      "type": "text",
      "text": "# Forwarding (object-oriented programming)\n\nIn object-oriented programming, forwarding means that using a member of an object (either a property or a method) results in actually using the corresponding member of a different object: the use is forwarded to another object. Forwarding is used in a number of design patterns, where some members are forwarded to another object, while others are handled by the directly used object. The forwarding object is frequently called a wrapper object, and explicit forwarding members are called wrapper functions.\nDelegation\nForwarding is often confused with delegation; formally, they are complementary concepts. In both cases, there are two objects, and the first (sending, wrapper) object uses the second (receiving, wrapped) object, for example to call a method. They differ in what self refers to on the receiving object (formally, in the evaluation environment of the method on the receiving object): in delegation it refers to the sending object, while in forwarding it refers to the receiving object. Note that self is often used implicitly as part of dynamic dispatch (method resolution: which function a method name refers to).\n}}\nFor example, given the following code:\n// Sender\nvoid n() {\nprint(\"n1\");\n}\n// Receiver\nvoid m() {\nprint(\"m2, \");\nn();\n}\nvoid n() {\nprint(\"n2\");\n}\nUnder delegation, m() will output m2, n1 because n() is evaluated in the context of the original (sending) object, while under forwarding, it will output m2, n2 because n() is evaluated in the context of the receiving object.\nIn casual use, forwarding is often referred to as \"delegation\", or considered a form of delegation, but in careful usage they are clearly distinguished by what self refers to. While delegation is analogous to inheritance, allowing behavioral reuse (and concretely code reuse) without changing evaluation context, forwarding is analogous to composition, as execution depends only on the receiving (member) object, not the (original) sending object. In both cases, reuse is dynamic, meaning determined at run time (based on the object to which use is delegated or forwarded), rather than static, meaning determined at compile/link time (based on the class which is inherited from). Like inheritance, delegation allows the sending object to modify the original behavior, but is susceptible to problems analogous to the fragile base class; while forwarding provides stronger encapsulation and avoids these problems; see composition over inheritance.\nExamples\nA simple example of explicit forwarding in Java: an instance of B forwards calls to the foo method of its a field:\nclass B {\nA a;\nT foo() { return a.foo(); }\n}\nNote that when executing a.foo(), the this object is a (a subtype of A), not the original object (an instance of B). Further, a need not be an instance of A: it may be an instance of a subtype. Indeed, A need not even be a class: it may be an interface/protocol.\nContrast with inheritance, in which foo is defined in a superclass A (which must be a class, not an interface), and when called on an instance of a subclass B, it uses the code defined in A, but the this object is still an instance of B:\nclass A {\nT foo() { /* ... */ };\n}\nclass B extends A {\n}\nIn this Python example, class B forwards the foo method and the x property to the object in its a field: using these on b (an instance of B) is the same as using them on b.a (the instance of A to which these are forwarded).\nclass A:\ndef __init__(self, x) -> None:\nself.x = x\ndef foo(self):\nprint(self.x)\nclass B:\ndef __init__(self, a) -> None:\nself.a = a\ndef foo(self):\nself.a.foo()\n@property\ndef x(self):\nreturn self.a.x\n@x.setter\ndef x(self, x):\nself.a.x = x\n@x.deleter\ndef x(self):\ndel self.a.x\na = A(42)\nb = B(a)\nb.foo()  # Prints '42'.\nb.x  # Has value '42'\nb.x = 17   # b.a.x now has value 17\ndel b.x  # Deletes b.a.x.\nSimple\nIn this Java example, the  class has a  method. This print method, rather than performing the print itself, forwards to an object of class . To the outside world it appears that the  object is doing the print, but the  object is the one actually doing the work.\nForwarding is simply passing a duty off to someone/something else. Here is a simple example:\nclass RealPrinter { // the \"receiver\"\nvoid print() {\nSystem.out.println(\"Hello world!\");\n}\n}\nclass Printer { // the \"sender\"\nRealPrinter p = new RealPrinter(); // create the receiver\nvoid print() {\np.print(); // calls the receiver\n}\n}\npublic class Main {\npublic static void main(String[] arguments) {\n// to the outside world it looks like Printer actually prints.\nPrinter printer = new Printer();\nprinter.print();\n}\n}\nComplex\nThe more complex case is a Decorator Pattern that by using interfaces, forwarding can be made more flexible and typesafe. \"Flexibility\" here means that  need not refer to  or  in any way, as the switching of forwarding is abstracted from . In this example, class  can forward to any class that implements an interface . Class  has a method to switch to another forwarder. Including the  clauses improves type safety, because each class must implement the methods in the interface. The main tradeoff is more code.\ninterface I {\nvoid f();\nvoid g();\n}\nclass A implements I {\npublic void f() { System.out.println(\"A: doing f()\"); }\npublic void g() { System.out.println(\"A: doing g()\"); }\n}\nclass B implements I {\npublic void f() { System.out.println(\"B: doing f()\"); }\npublic void g() { System.out.println(\"B: doing g()\"); }\n}\n// changing the implementing object in run-time (normally done in compile time)\nclass C implements I {\nI i = null;\n// forwarding\npublic C(I i){ setI(i); }\npublic void f() { i.f(); }\npublic void g() { i.g(); }\n// normal attributes\npublic void setI(I i) { this.i = i; }\n}\npublic class Main {\npublic static void main(String[] arguments) {\nC c = new C(new A());\nc.f();\t// output: A: doing f()\nc.g();\t// output: A: doing g()\nc.setI(new B());\nc.f();\t// output: B: doing f()\nc.g();\t// output: B: doing g()\n}\n}\nApplications\nForwarding is used in many design patterns. Forwarding is used directly in several patterns:\n* Chain-of-responsibility pattern\n* Decorator pattern: decorator object adds its own members, forwarding others to the decorated object.\n* Proxy pattern: proxy object forwards member use to real object.\nForwarding may be used in other patterns, but often use is modified; for example, a method call on one object results in several different methods being called on another:\n* Adapter pattern\n* Bridge pattern\n* Facade pattern\nReferences"
    }
  ]
}