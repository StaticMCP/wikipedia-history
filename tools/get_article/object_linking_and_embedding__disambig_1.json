{
  "content": [
    {
      "type": "text",
      "text": "# Object Linking and Embedding__disambig_1\n\nObject Linking and Embedding  (OLE) is a proprietary technology developed by Microsoft that allows embedding and linking to documents and other objects. For developers, it brought OLE Control Extension (OCX), a way to develop and use custom user interface elements. On a technical level, an OLE object is any object that implements the IOleObject interface, possibly along with a wide range of other interfaces, depending on the object's needs.\nOverview\nOLE allows an editing application to export part of a document to another editing application and then import it with additional content. For example, a desktop publishing system might send some text to a word processor or a picture to a bitmap editor using OLE. The main benefit of OLE is to add different kinds of data to a document from different applications, like a text editor and an image editor. This creates a Compound File Binary Format document and a master file to which the document makes reference. Changes to data in the master file immediately affect the document that references it. This is called \"linking\" (instead of \"embedding\").\nOLE can also be used to transfer data between different applications using drag and drop or clipboard operations.\nHistory\nOLE 1.0\nOLE 1.0, released in 1990, was an evolution of the original Dynamic Data Exchange (DDE) concept that Microsoft developed for earlier versions of Windows.  While DDE was limited to transferring limited amounts of data between two running applications, OLE was capable of maintaining active links between two documents or even embedding one type of document within another.\nOLE servers and clients communicate with system libraries using virtual function tables, or VTBLs.  The VTBL consists of a structure of function pointers that the system library can use to communicate with the server or client.  The server and client libraries,  and , were originally designed to communicate between themselves using the  message.\nOLE 1.0 later evolved to become an architecture for software components known as the Component Object Model (COM), and later DCOM.\nWhen an OLE object is placed on the clipboard or embedded in a document, both a visual representation in native Windows formats (such as a bitmap or metafile) is stored, as well as the underlying data in its own format. This allows applications to display the object without loading the application used to create the object, while also allowing the object to be edited, if the appropriate application is installed.\nThe Object Packager, a component of OLE, shipping from Windows 3.1 up to Windows XP allows a non-OLE object to be \"packaged\" so it can be embedded into an OLE client.\nOLE 2.0\nOLE 2.0 was the next evolution of OLE, sharing many of the same goals as version 1.0, but was re-implemented on top of the COM instead of using VTBLs directly. New features were OLE automation, drag-and-drop, in-place activation and structured storage. Monikers evolved from OLE 1 object names, and provided a hierarchical object and resource naming system similar to URLs or URIs, which were independently invented. Windows now has merged the two technologies supporting a URL Moniker type, and a Moniker URL scheme. OLE 2.0 introduced UUID to label API objects.\nOLE custom controls\nOLE custom controls were introduced in 1994 as a replacement for the now deprecated Visual Basic Extension controls. Instead of upgrading these, the new architecture was based on OLE. In particular, any container that supported OLE 2.0 could already embed OLE custom controls, although these controls cannot react to events unless the container supports this. OLE custom controls are usually shipped in the form of a dynamic link library with the .ocx extension. In 1996 all interfaces for controls (except IUnknown) were made optional to keep the file size of controls down, so they would download faster; these were then called ActiveX Controls.\nTechnical details\nOLE objects and containers are implemented on top of the Component Object Model; they are objects that can implement interfaces to export their functionality. Only the IOleObject interface is compulsory, but other interfaces may also need to be implemented if the functionality exported by those interfaces is required.\nTo ease understanding of what follows, some terminology has to be explained. The view status of an object is whether the object is transparent, opaque, or opaque with a solid background, and whether it supports drawing with a specified aspect. The site of an object is an object representing the location of the object in its container. A container supports a site object for every object contained.\nWhat follows is a list of interfaces, grouped by the object that usually needs to implement them. Interfaces usually implemented by the OLE object are usually called on by the OLE container, and vice versa. Note that in the following list indentation indicates interface inheritance. All non-indented interfaces derive from IUnknown.\nOLE object\n;DataObject\n:When implemented, enables the transfer of data, and notification of data changes. It must be implemented by objects that are to support drag-and-drop, being copied to or pasted from the clipboard, or being linked or embedded in a containing document.\n;ObjectWithSite\n:Allows the caller to inform the OLE object of its site. This functionality is also provided by OleObject, but ObjectWithSite can be used, when supported, if OleObject is not used for other matters.\n;OleCache\n:Allows visual presentations from a DataObject to be cached. This allows an embedded object to store its visual representation, thus enabling it to be displayed later without needing to start the application that was used to create the object.\n:Usually the stock implementation is used.\n:;OleCache2\n::Provides more fine-grained control over caching.\n::Usually the stock implementation is used.\n;OleCacheControl\n:This interface is not called by the container, but internally by the object to allow it to receive notifications of when its DataObject is running, thereby allowing it to subscribe to notifications of data changes of that object and thus allowing it to update the cached presentation properly.\n:Usually the stock implementation is used.\n;OleDocument\n:Allows the OLE object to support multiple views of its data, as well as a few related functions.\n;OleDocumentView\n:A document object (an object that implements OleDocument) implements this interface for every view. It allows the caller to set the site of the object, query and set the size of the object and to show and activate it, as well as some related functions.\n;OleWindow\n:;OleInPlaceActiveObject\n::Called by the outermost container of an object to interact with it while it's active, e.g. to process accelerator keys in the container's message queue that are meant for the contained object.\n:;OleInPlaceObject\n::Called by the container to activate or deactivate the object.\n::;IOleInPlaceObjectWindowless\n:::A windowless object is an object that doesn't have its own window but it instead displayed in its container's window. It is used by the container to relay messages received by the container's window that are intended for the contained object. For example, if the mouse is moved over a window, Windows places a mouse move message along with the mouse coordinates in the message queue of the window. If this window contains windowless embedded objects, the message may have to be relayed to such an object if the coordinates of the mouse-pointer are over this object. For similar reasons this interface also provides access to the object's DropTarget interface.\n;OleLink\n:Allows the object to support linking, e.g. by allowing the container to set the source of a linked object.\n:Usually the stock implementation is used.\n;OleObject\n:Arguably the most important interface for an OLE object. For example, it allows the container to inform the object of its site, initialize the object from data, to open and close it, to query and set the size of the object, to ask for notifications on the container's AdviseSink and to execute objects defined as \"verbs\" on the object. These verbs often include \"Open\" or \"Edit\", but can also include other verbs. One of the verbs is defined to be the principal verb, and it is executed when the user double-clicks an object.\n;ViewObject\n:Allows an object to draw itself directly, without passing a DataObject to the container. For objects that support both DataObject and this interface, the underlying implementation is usually shared.\n:;ViewObject2\n::Additionally allows the caller to query the size of the object.\n::;ViewObjectEx\n:::Adds support for flicker-free drawing of transparent objects, hit-testing for objects with irregular shapes and setting the size of an object.\nOLE container\n;IAdviseSink\n:Allows the implementer to receive notifications when the object is saved, closed, or renamed, or when its data or visual presentation changes.\n:;IAdviseSink2\n::Additionally allows the implementer to receive notifications when the link source of the OLE object changes.\n:;IAdviseSinkEx\n::Additionally allows the implementer to receive notifications when the view status of the OLE object changes.\n;IOleClientSite\n:This interface allows the caller to obtain information on the container and location of an object, as well requesting that the object be saved, resized, shown, hidden, et cetera.\n;IOleDocumentSite\n:Allows the caller to ask for the object on this site to be activated immediately. If this interface is implemented, IOleClientSite, IOleInPlaceSite and IAdviseSink must be implemented as well.\n;IOleContainer\n:This interface allows the caller to enumerate embedded objects in a container, or to find such objects by name. It is primarily useful if the container wishes to support links to embedded objects.\n;IOleWindow\n:;IOleInPlaceUIWindow\n::Enables embedded objects to negotiate space for toolbars on the container's window.\n::;IOleInPlaceFrame\n:::Allows the caller to ask the container to insert its menu items in an empty menu that will become the cooperative menu. Also allows the caller to ask the container to show or hide this menu, to show or hide dialog boxes, and to process accelerator keys received by the contained object intended for the container.\n:;IOleInPlaceSite\n::If a container implements this interface, it allows embedded objects to be activated in place, i.e. without opening in a separate window. It provides access to the container's IOleInPlaceUIWindow.\n::;IOleInPlaceSiteEx\n:::If a container implements this interface, it allows embedded objects to check whether they need to redraw on activation or deactivation. It also allows them to request their UI to activate.\n:::;IOleInPlaceSiteWindowless\n::::If a container wishes to support windowless embedded objects, it needs to provide functionality to embedded objects to replace the functionality normally provided by an embedded object's window. For example this interface provides a way to access the container's window's device context, thereby enabling the embedded object to draw in the container's window.\n;IOleUILinkContainer\n:Contains the methods that the standard OLE dialog boxes that manage linked objects use to update linked objects in a container, or to query and change their sources. Used by the \"Links\", \"Change source\", \"Update links\" and \"Object properties\" dialog boxes.\n:;IOleUILinkInfo\n::Additionally allows the dialog boxes to query when linked objects were last updated, and whether this was done automatically or manually.\n:;IOleUIObjInfo\n::Contains the methods needed by the \"Object properties\" dialog box. For example if the user opens the \"Object properties\" dialog box and asks for the object to be converted to another type, a method on this interface is called.\n;IOleUndoManager\n:Provides a centralized undo service to both the container itself and to embedded objects. When an undoable action is performed, an IOleUndoUnit is created and added to the IOleUndoManager\nOther\n;IDataAdviseHolder\n:The methods of IDataObject that pertain to data change notifications can be implemented by calling the methods of this interface.\n:Usually the stock implementation is used.\n;IOleAdviseHolder\n:The methods of IOleObject that pertain to notifications can be implemented by calling the methods of this interface.\n:Usually the stock implementation is used.\n;IDropSource\n:Implemented by objects that can be dragged, i.e. that can be the source of a drag-and-drop operations. When implemented it allows the object to draw drag-and-drop effects, and to specify when the object is dropped, or the drag-and-drop operation is cancelled.\n;IDropTarget\n:Implemented by objects that accept dropped objects, i.e. that can be the target of drag-and-drop operations. When implemented it allows the target to specify if a dropped object will be accepted, and what happens to an object after it is dropped.\n;IOleCommandTarget\n:Can be implemented by objects (OLE objects, OLE containers, and other objects) that wish to support certain standard commands. It allows callers to query if commands are supported, and to execute commands. Commands that an object might typically wish to implement may include things like \"delete\", \"cut\", \"copy\", \"paste\", \"undo\", \"find\", \"print\", \"save\", \"zoom\", and so on. Currently 58 standard commands have been defined, and they include commands commonly used by office software, web browsers and similar applications.\n;IOleUndoUnit\n:Represents an action that can be undone. It contains all information necessary to undo an action. It is created by objects and containers, so that undoable actions can be added to the container's IOleUndoManager.\n:;IOleParentUndoUnit\n::Allows an undo unit to contain other undo units. In essence this allows the undo unit to act as an undo stack, grouping undo units together. For example, if a macro is run, all undo-able actions performed by the macro may be grouped together in one undo unit.\n;IOleWindow\n:This interface represents a window of a container or contained object. It allows callers to obtain the handle of the window, and to toggle the context-sensitive help function. When the context-sensitive help function is turned on, typically the mouse-pointer changes to an arrow with a question mark to indicate that clicking a user interface element will result in opening a help window.\nCompetition\nOpenDoc technology tried to compete with OLE. Some of Microsoft's competitors considered OpenDoc to be more robust and easier to use. OpenDoc allowed users to view and edit information across applications, directly in competition with Microsoft's proprietary OLE standard. In 1993 some Microsoft competitors established a consortium called the Component Integration Laboratories (\"CIL\") to develop OpenDoc as an open standard for cross-platform linking and embedding.\nMicrosoft required OLE compatibility as a condition of Microsoft's certification of an application's compatibility with Windows 95. Microsoft initially announced that applications using OpenDoc would be deemed compatible with OLE, and would receive certification for Windows 95. Microsoft later reversed the decision and said that applications using OpenDoc might not receive certification at all. Microsoft withheld specifications and debugged versions of OLE until after it had released its competing applications.\nInteroperability\nUse of OLE objects limits interoperability, because these objects are not widely supported in programs for viewing or editing files outside of Microsoft Windows (e.g., embedding of other files inside the file, such as tables or charts from a spreadsheet application in a text document or presentation file). If software that understands an OLE object is not available, the object is usually replaced by a picture (bitmap representation of the object) or not displayed at all.\nSee also\n*OLE Automation\n*OLE for process control (OPC)\n*Component Object Model (COM)\n*Distributed Component Object Model (DCOM)\n*Dynamic Data Exchange (DDE)\n*Publish and Subscribe (Mac OS)\n*Internet media type\n*Multipurpose Internet Mail Extensions (MIME)\n*Transclusion\n*Shscrap.dll (shell scrap files)\nReferences\nExternal links\n* [https://pldaniels.com/ripole/ ripOLE] - extracts attachments from OLE documents\n* [https://docs.microsoft.com/en-us/cpp/mfc/ole-background OLE Background] from docs.microsoft.com"
    }
  ]
}