{
  "content": [
    {
      "type": "text",
      "text": "# Software pipelining\n\nIn computer science, software pipelining is a technique used to optimize loops, in a manner that parallels hardware pipelining.  Software pipelining is a type of out-of-order execution, except that the reordering is done by a compiler (or in the case of hand written assembly code, by the programmer) instead of the processor.  Some computer architectures have explicit support for software pipelining, notably Intel's IA-64 architecture.\nIt is important to distinguish software pipelining, which is a target code technique for overlapping loop iterations, from modulo scheduling, the currently most effective known compiler technique for generating software pipelined loops.\nSoftware pipelining has been known to assembly language programmers of machines with instruction-level parallelism since such architectures existed. Effective compiler generation of such code dates to the invention of modulo scheduling by Rau and Glaeser.\nLam showed that special hardware is unnecessary for effective modulo scheduling. Her technique, modulo variable expansion is widely used in practice.\nGao et al. formulated optimal software pipelining in integer linear programming, culminating in validation of advanced heuristics in an evaluation paper. This paper has a\ngood set of references on the topic.\nExample\nConsider the following loop:\nfor i = 1 to bignumber\nA(i)\nB(i)\nC(i)\nend\nIn this example, let A(i), B(i), C(i) be instructions, each operating on data i, that are dependent on each other.  In other words, A(i) must complete before B(i) can start.  For example, A could load data from memory into a register, B could perform some arithmetic operation on the data, and C could store the data back into memory.  However, let there be no dependence between operations for different values of i.  In other words, A(2) can begin before A(1) finishes.\nWithout software pipelining, the operations execute in the following sequence:\nA(1) B(1) C(1) A(2) B(2) C(2) A(3) B(3) C(3) ...\nAssume that each instruction takes 3 clock cycles to complete (ignore for the moment the cost of the looping control flow).  Also assume (as is the case on most modern systems) that an instruction can be dispatched every cycle, as long as it has no dependencies on an instruction that is already executing.  In the unpipelined case, each iteration thus takes 9 cycles to complete: 3 clock cycles for A(1), 3 clock cycles for B(1), and 3 clock cycles for C(1).\nNow consider the following sequence of instructions with software pipelining:\nA(1) A(2) A(3) B(1) B(2) B(3) C(1) C(2) C(3) ...\nIt can be easily verified that an instruction can be dispatched each cycle, which means that the same 3 iterations can be executed in a total of 9 cycles, giving an average of 3 cycles per iteration.\nImplementation\nSoftware pipelining is often used in combination with loop unrolling, and this combination of techniques is often a far better optimization than loop unrolling alone.  In the example above, we could write the code as follows (assume for the moment that bignumber is divisible by 3):\nfor i = 1 to (bignumber - 2) step 3\nA(i)\nA(i+1)\nA(i+2)\nB(i)\nB(i+1)\nB(i+2)\nC(i)\nC(i+1)\nC(i+2)\nend\nOf course, matters are complicated if (as is usually the case) we can't guarantee that the total number of iterations will be divisible by the number of iterations we unroll.  See the article on loop unrolling for more on solutions to this problem, but note that software pipelining prevents the use of Duff's device.\nIn the general case, loop unrolling may not be the best way to implement software pipelining.  Consider a loop containing instructions with a high latency.  For example, the following code:\nfor i = 1 to bignumber\nA(i) ; 3 cycle latency\nB(i) ; 3\nC(i) ; 12(perhaps a floating point operation)\nD(i) ; 3\nE(i) ; 3\nF(i) ; 3\nend\nwould require 12 iterations of the loop to be unrolled to avoid the bottleneck of instruction C.  This means that the code of the loop would increase by a factor of 12 (which not only affects memory usage, but can also affect cache performance, see code bloat).  Even worse, the prologue (code before the loop for handling the case of bignumber not divisible by 12) will likely be even larger than the code for the loop, and very probably inefficient because software pipelining cannot be used in this code (at least not without a significant amount of further code bloat).  Furthermore, if bignumber is expected to be moderate in size compared to the number of iterations unrolled (say 10-20), then the execution will spend most of its time in this inefficient prologue code, rendering the software pipelining optimization ineffectual.\nBy contrast, here is the software pipelining for our example (the prologue and epilogue will be explained later):\nprologue\nfor i = 1 to (bignumber - 6)\nA(i+6)\nB(i+5)\nC(i+4)\nD(i+2) ; note that we skip i+3\nE(i+1)\nF(i)\nend\nepilogue\nBefore getting to the prologue and epilogue, which handle iterations at the beginning and end of the loop, let's verify that this code does the same thing as the original for iterations in the middle of the loop.  Specifically, consider iteration 7 in the original loop.  The first iteration of the pipelined loop will be the first iteration that includes an instruction from iteration 7 of the original loop.  The sequence of instructions is:\n:Iteration 1: A(7) B(6) C(5) D(3) E(2) F(1)\n:Iteration 2: A(8) B(7) C(6) D(4) E(3) F(2)\n:Iteration 3: A(9) B(8) C(7) D(5) E(4) F(3)\n:Iteration 4: A(10) B(9) C(8) D(6) E(5) F(4)\n:Iteration 5: A(11) B(10) C(9) D(7) E(6) F(5)\n:Iteration 6: A(12) B(11) C(10) D(8) E(7) F(6)\n:Iteration 7: A(13) B(12) C(11) D(9) E(8) F(7)\nHowever, unlike the original loop, the pipelined version avoids the bottleneck at instruction C.  Note that there are 12 instructions between C(7) and the dependent instruction D(7), which means that the latency cycles of instruction C(7) are used for other instructions instead of being wasted.\nThe prologue and epilogue handle iterations at the beginning and end of the loop.  Here is a possible prologue for our example above:\n; loop prologue (arranged on lines for clarity)\nA(1)\nA(2), B(1)\nA(3), B(2), C(1)\nA(4), B(3), C(2) ; cannot start D(1) yet\nA(5), B(4), C(3), D(1)\nA(6), B(5), C(4), D(2), E(1)\nEach line above corresponds to an iteration of the main pipelined loop, but without the instructions for iterations that have not yet begun.  Similarly, the epilogue progressively removes instructions for iterations that have completed:\n; loop epilogue (arranged on lines for clarity)\nB(bignumber), C(bignumber-1), D(bignumber-3), E(bignumber-4), F(bignumber-5)\nC(bignumber), D(bignumber-2), E(bignumber-3), F(bignumber-4)\nD(bignumber-1), E(bignumber-2), F(bignumber-3)\nD(bignumber), E(bignumber-1), F(bignumber-2)\nE(bignumber), F(bignumber-1)\nF(bignumber)\nDifficulties of implementation\nThe requirement of a prologue and epilogue is one of the major difficulties of implementing software pipelining.  Note that the prologue in this example is 18 instructions, 3 times as large as the loop itself.  The epilogue would also be 18 instructions.  In other words, the prologue and epilogue together are 6 times as large as the loop itself.  While still better than attempting loop unrolling for this example, software pipelining requires a trade-off between speed and memory usage.  Keep in mind, also, that if the code bloat is too large, it will affect speed anyway via a decrease in cache performance.\nA further difficulty is that on many architectures, most instructions use a register as an argument, and that the specific register to use must be hard-coded into the instruction.  In other words, on many architectures, it is impossible to code such an instruction as \"multiply the contents of register X and register Y and put the result in register Z\", where X, Y, and Z are numbers taken from other registers or memory.  This has often been cited as a reason that software pipelining cannot be effectively implemented on conventional architectures.\nIn fact, Monica Lam presents an elegant solution to this problem in her thesis, A Systolic Array Optimizing Compiler (1989) ().  She calls it modulo variable expansion.  The trick is to replicate the body of the loop after it has been scheduled, allowing different registers to be used for different values of the same variable when they have to be live at the same time.  For the simplest possible example, let's suppose that A(i) and B(i) can be issued in parallel and that the latency of the former is 2 cycles.  The pipelined body could then be:\nA(i+2); B(i)\nRegister allocation of this loop body runs into the problem that the result of A(i+2) must stay live for two iterations.  Using the same register for the result of A(i+2) and the input of B(i) will result in incorrect results.\nHowever, if we replicate the scheduled loop body, the problem is solved:\nA(i+2); B(i)\nA(i+3); B(i+1)\nNow a separate register can be allocated to the results of A(i+2) and A(i+3).  To be more concrete:\nr1 = A(i+2); B(i) = r1\nr2 = A(i+3); B(i+1) = r2\ni = i + 2 // Just to be clear\nOn the assumption that each instruction bundle reads its input registers before writing its output registers, this code is correct.  At the start of the replicated loop body, r1 holds the value of A(i+2) from the previous replicated loop iteration.  Since i has been incremented by 2 in the meantime, this is actually the value of A(i) in this replicated loop iteration.\nOf course, code replication increases code size and cache pressure just as the prologue and epilogue do.  Nevertheless, for loops with large trip counts on architectures with enough instruction level parallelism, the technique easily performs well enough to be worth any increase in code size.\nIA-64 implementation\nIntel's IA-64 architecture provides an example of an architecture designed with the difficulties of software pipelining in mind.  Some of the architectural support for software pipelining includes:\n* A \"rotating\" register bank; instructions can refer to a register number that is redirected to a different register each iteration of the loop (eventually looping back around to the beginning).  This makes the extra instructions inserted in the previous example unnecessary.\n* Predicates (used to \"predicate\" instructions; see Branch predication) that take their value from special looping instructions.  These predicates turn on or off certain instructions in the loop, making a separate prologue and epilogue unnecessary.\nReferences"
    }
  ]
}