{
  "content": [
    {
      "type": "text",
      "text": "# Karmarkar–Karp bin packing algorithms\n\n}}\nThe Karmarkar–Karp (KK) bin packing algorithms are several related approximation algorithm for the bin packing problem. The bin packing problem is a problem of packing items of different sizes into bins of identical capacity, such that the total number of bins is as small as possible. Finding the optimal solution is computationally hard. Karmarkar and Karp devised an algorithm that runs in polynomial time and finds a solution with at most \\mathrm{OPT} + \\mathcal{O}(\\log^2(OPT)) bins, where OPT is the number of bins in the optimal solution. They also devised several other algorithms with slightly different approximation guarantees and run-time bounds.\nThe KK algorithms were considered a breakthrough in the study of bin packing: the previously-known algorithms found multiplicative approximation, where the number of bins was at most r\\cdot \\mathrm{OPT}+s for some constants r>1, s>0, or at most (1+\\varepsilon)\\mathrm{OPT} + 1. The KK algorithms were the first ones to attain an additive approximation.\nInput\nThe input to a bin-packing problem is a set of items of different sizes, a1,...an. The following notation is used:\n* n - the number of items.\n* m - the number of different item sizes. For each i in 1,...,m:\n**si is the i-th size;\n**ni is the number of items of size si.\n* B - the bin size.\nGiven an instance I, we denote:\n*OPT(I) = the optimal solution of instance I.\n*FOPT(I) = (a1+...+an)/B = the theoretically-optimal number of bins, when all bins are completely filled with items or item fractions.\nObviously, FOPT(I) ≤ OPT(I).\nHigh-level scheme\nThe KK algorithms essentially solve the configuration linear program:\\text{minimize}~~\\mathbf{1}\\cdot \\mathbf{x}~~~\\text{s.t.}~~ A \\mathbf{x}\\geq \\mathbf{n}~~~\\text{and}~~  \\mathbf{x}\\geq 0~~~\\text{and}~~  \\mathbf{x}~\\text{is an integer}~.Here, A is a matrix with m rows. Each column of A represents a feasible configuration - a multiset of item-sizes, such that the sum of all these sizes is at most B. The set of configurations is C. x is a vector of size C. Each element xc of x represents the number of times configuration c is used.\n* Example: suppose the item sizes are 3,3,3,3,3,4,4,4,4,4, and B=12. Then there are C=10 possible configurations: 3333; 333; 33, 334; 3, 34, 344; 4, 44, 444. The matrix A has two rows: [4,3,2,2,1,1,1,0,0,0] for s=3 and [0,0,0,1,0,1,2,1,2,3] for s=4. The vector n is [5,5] since there are 5 items of each size. A possible optimal solution is x=[1,0,0,0,0,0,1,0,0,1], corresponding to using three bins with configurations 3333, 344, 444.\nThere are two main difficulties in solving this problem. First, it is an integer linear program, which is computationally hard to solve. Second, the number of variables is C - the number of configurations, which may be enormous. The KK algorithms cope with these difficulties using several techniques, some of which were already introduced by de-la-Vega and Lueker. Here is a high-level description of the algorithm (where  I is the original instance):\n*1-a. Let J be an instance constructed from I by removing small items.\n**2-a. Let K be an instance constructed from J by grouping items and rounding the size of items in each group to the highest item in the group.\n***3-a. Construct the configuration linear program for K, without the integrality constraints.\n****4. Compute a (fractional) solution x for the relaxed linear program.\n***3-b. Round x to an integral solution for K.\n**2-b. \"Un-group\" the items to get a solution for J.\n*1-b. Add the small items to get a solution for I.\nBelow, we describe each of these steps in turn.\nStep 1. Removing and adding small items\nThe motivation for removing small items is that, when all items are large, the number of items in each bin must be small, so the number of possible configurations is (relatively) small. We pick some constant g\\in(0,1), and remove from the original instance I all items smaller than g\\cdot B. Let J be the resulting instance. Note that in J, each bin can contain at most 1/g items. We pack J and get a packing with some b_J bins.\nNow, we add the small items into the existing bins in an arbitrary order, as long as there is room. When there is no more room in the existing bins, we open a new bin (as in next-fit bin packing). Let b_I be the number of bins in the final packing. Then: b_I \\leq \\max(b_J, (1+2 g)\\cdot OPT(I) + 1).Proof. If no new bins are opened, then the number of bins remains b_J. If a new bin is opened, then all bins except maybe the last one contain a total size of at least B - g\\cdot B, so the total instance size is at least (1-g)\\cdot B\\cdot (b_I-1). Therefore, FOPT \\geq (1-g)\\cdot  (b_I-1), so the optimal solution needs at least (1-g)\\cdot  (b_I-1) bins. So b_I  \\leq OPT/(1-g) + 1 = (1+g+g^2+\\ldots) OPT+1 \\leq (1+2g) OPT+1.\nIn particular, by taking g=1/n, we get:b_I \\leq \\max(b_J, OPT +2 \\cdot OPT(I)/n + 1)\\leq \\max(b_J, OPT +3),since OPT(I)\\leq n. Therefore, it is common to assume that all items are larger than 1/n.\nStep 2. Grouping and un-grouping items\nThe motivation for grouping items is to reduce the number of different item sizes, to reduce the number of constraints in the configuration LP. The general grouping process is:\n* Order the items by descending size.\n* Partition the items into groups.\n* For each group, modify the size of all items in the group to the largest size in the group.\nThere are several different grouping methods.\nLinear grouping\nLet k>1 be an integer parameter. Put the largest k items in group 1; the next-largest k items in group 2; and so on (the last group might have fewer than k items). Let J be the original instance. Let K' be the first group (the group of the k largest items), and K the grouped instance without the first group. Then:\n* In K' all items have the same size. In K the number of different sizes is m(K) \\leq  n/k + 1.\n*OPT(K) \\leq OPT(J) - since group 1 in J dominates group 2 in K (all k items in group 1 are larger than the k items in group 2); similarly, group 2 in J dominates group 3 in K, etc.\n* OPT(K') \\leq k - since it is possible to pack each item in K' into a single bin.\nTherefore, OPT(J) \\leq OPT(K\\cup K') \\leq OPT(K)+OPT(K') \\leq OPT(K)+k. Indeed, given a solution to K with b_K bins, we can get a solution to J with at most b_K+k bins.\nGeometric grouping\nLet k>1 be an integer parameter. Geometric grouping proceeds in two steps:\n* Partition the instance J into several instances J_0, J_1, \\ldots such that, in each instance J_r, all sizes are in the interval [B/2^{r+1}, B/2^r). Note that, if all items in J have size at least g\\cdot B, then the number of instances is at most \\log_2(1/g).\n* On each instance J_r, perform linear rounding with parameter k\\cdot 2^r.  Let K_r, K'_r be the resulting instances. Let K := \\cup _r K_r and K' := \\cup _r K'_r.\nThen, the number of different sizes is bounded as follows:\n* For all r, m(K'_r) = 1 and m(K_r) \\leq n(J_r)/(k\\cdot 2^r) + 1. Since all items in J_r are larger than B/2^{r+1}, we have n(J_r)\\leq 2^{r+1} \\cdot FOPT(J_r), so m(K_r) \\leq 2 FOPT(J_r)/k + 1. Summing over all r gives m(K) \\leq 2 FOPT(J)/k + \\log_2(1/g).\nThe number of bins is bounded as follows:\n* For all r, OPT(K'_r) \\leq k - since K'_r has k\\cdot 2^r items, and all of them are smaller than B/2^r, so they can be packed into at  most k bins.\n* Therefore, OPT(K') \\leq k\\cdot \\log_2(1/g).\n* Therefore, OPT(J) \\leq OPT(K)+OPT(K')\\leq OPT(K)+k\\cdot \\log_2(1/g).\nAlternative geometric grouping\nLet k>1 be an integer parameter.  Order the items by descending size. Partition them into groups such that the total size in each group is at least k\\cdot B. Since the size of each item is less than B, The number of items in each group is at least k+1. The number of items in each group is weakly-increasing. If all items are larger than g\\cdot B, then the number of items in each group is at most k/g. In each group, only the larger items are rounded up. This can be done such that:\n* m(K) \\leq FOPT(J)/k + \\ln(1/g).\n* OPT(J) \\leq OPT(K)+2 k\\cdot (2 + \\ln(1/g)).\nStep 3. Constructing the LP and rounding the solution\nWe consider the configuration linear program without the integrality constraints:\\text{minimize}~~\\mathbf{1}\\cdot \\mathbf{x}~~~\\text{s.t.}~~ A \\mathbf{x}\\geq \\mathbf{n}~~~\\text{and}~~  \\mathbf{x}\\geq 0.Here, we are allowed to use a fractional number of each configuration.\n* Example: suppose there are 31 items of size 3 and 7 items of size 4, and the bin-size is 10. The configurations are: 4, 44, 34, 334, 3, 33, 333. The constraints are [0,0,1,2,1,2,3]*x=31 and [1,2,1,1,0,0,0]*x=7. An optimal solution to the fractional LP is [0,0,0,7,0,0,17/3] That is: there are 7 bins of configuration 334 and 17/3 bins of configuration 333. Note that only two different configurations are needed.\nDenote the optimal solution of the linear program by LOPT. The following relations are obvious:\n* FOPT(I) ≤ LOPT(I), since FOPT(I) is the (possibly fractional) number of bins when all bins are completely filled with items or fractions of items. Clearly, no solution can be more efficient.\n* LOPT(I) ≤ OPT(I), since LOPT(I) is a solution to a minimization problem with fewer constraints.\n* OPT(I) \\sum_{c\\in C} x_c = b_L bins (note that b_L may be a fractional number). Since the fractional LP has m constraints (one for each distinct size), x has at most m nonzero variables, that is, at most m different configurations are used. We construct from x an integral packing consisting of a principal part and a residual part.\n* The principal part contains floor(xc) bins of each configuration c for which xc > 0.\n* For the residual part (denoted by R), we construct two candidate packings:\n** A single bin of each configuration c for which xc > 0; all in all m bins are needed.\n** A greedy packing, with fewer than 2*FOPT(R) bins (since if there are at least 2*FOPT(R) bins, the two smallest ones can be combined).\n* The smallest of these packings requires min(m, 2*FOPT(R))  ≤ average(m, 2*FOPT(R)) = FOPT(R) + m/2.\n* Adding to this the rounded-down bins of the principal part yields at most b_L+m/2 bins.\n* The execution time of this conversion algorithm is O(n log n).\nThis also implies that OPT(I)\\leq LOPT(I)+m/2.\nStep 4. Solving the fractional LP\nThe main challenge in solving the fractional LP is that it may have a huge number of variables - a variable for each possible configuration.\nThe dual LP\nThe dual linear program of the fractional LP is:\\text{maximize}~~\\mathbf{n}\\cdot \\mathbf{y}~~~\\text{s.t.}~~ A^T \\mathbf{y} \\leq \\mathbf{1}~~~\\text{and}~~  \\mathbf{y}\\geq 0.It has m variables y_1,\\ldots,y_m, and C constraints - a constraint for each configuration. It has the following economic interpretation. For each size s, we should determine a nonnegative price y_i. Our profit is the total price of all items. We want to maximize the profit n y subject to the constraints that the total price of items in each configuration is at most 1. This LP now has only m variables, but a huge number of constraints. Even listing all the constraints is infeasible.\nFortunately, it is possible to solve the problem up to any given precision without listing all the constraints, by using a variant of the ellipsoid method. This variant gets as input, a separation oracle: a function that, given a vector y ≥ 0, returns one of the following two options:\n* Assert that y is feasible, that is, A^T \\mathbf{y} \\leq \\mathbf{1}; or -\n* Assert that y is infeasible, and return a specific constraint that is violated, that is, a vector a such that \\mathbf{a}\\cdot \\mathbf{y} > 1.\nThe ellipsoid method starts with a large ellipsoid, that contains the entire feasible domain A^T \\mathbf{y} \\leq \\mathbf{1}. At each step t, it takes the center \\mathbf{y}_t of the current ellipsoid, and sends it to the separation oracle:\n* If the oracle says that \\mathbf{y}_t is feasible, then we do an \"optimality cut\": we cut from the ellipsoid all points y for which \\mathbf{n}\\cdot \\mathbf{y} . These points are definitely not optimal.\n* If the oracle says that \\mathbf{y}_t is infeasible and violates the constraint a, then we do a \"feasibility cut\": we cut from the ellipsoid all points y for which \\mathbf{a}\\cdot \\mathbf{y} > 1. These points are definitely not feasible.\nAfter making a cut, we construct a new, smaller ellipsoid. It can be shown that this process converges to an approximate solution, in time polynomial in the required accuracy.\nA separation oracle for the dual LP\nWe are given some m non-negative numbers  y_1,\\ldots,y_m. We have to decide between the following two options:\n* For every feasible configuration, the sum of y_i corresponding to this configuration is at most 1; this means that y is feasible.\n* There exists a feasible configuration for which the sum of y_i is larger than 1; this means that y is infeasible. In this case, we also have to return the configuration.\nThis problem can be solved by solving a knapsack problem, where the item values are y_1,\\ldots,y_m, the item weights are s_1,\\ldots,s_m, and the weight capacity is B (the bin size).\n* If the total value of the optimal knapsack solution is at most 1, then we say that y is feasible.\n* If the total value of the optimal knapsack solution is larger than 1, then we say that y is infeasible, and the items in the optimal knapsack solution correspond to a configuration that violates a constraint (since \\mathbf{a}\\cdot \\mathbf{y} > 1 for the vector a that corresponds to this configuration).\nThe knapsack problem can be solved by dynamic programming in pseudo-polynomial time: O(m\\cdot V), where m is the number of inputs and V is the number of different possible values. To get a polynomial-time algorithm, we can solve the knapsack problem approximately, using input rounding. Suppose we want a solution with tolerance \\delta. We can round each of y_1,\\ldots,y_m down to the nearest multiple of \\delta/n. Then, the number of possible values between 0 and 1 is n/\\delta, and the run-time is  O(m n /\\delta). The solution is at least the optimal solution minus \\delta/n.\nEllipsoid method with an approximate separation oracle\nThe ellipsoid method should be adapted to use an approximate separation oracle. Given the current ellipsoid center \\mathbf{y}_t:\n* If the approximate oracle returns a solution with value larger than 1, then \\mathbf{y}_t is definitely infeasible, and the solution correspond to a configuration that violates a constraint a. We do a \"feasibility cut\" in \\mathbf{y}_t, cutting the ellipsoid all points y for which \\mathbf{a}\\cdot \\mathbf{y} > 1.\n* If the approximate oracle returns a solution with value at most 1, then \\mathbf{y}_t may or may not be feasible, but \\mathbf{y}_t rounded down (denote it by \\mathbf{z}_t) is feasible. By definition of the rounding, we know that \\mathbf{n}\\cdot \\mathbf{z}_t \\geq \\mathbf{n}\\cdot \\mathbf{y}_t - \\mathbf{n}\\cdot \\mathbf{1}\\cdot (\\delta/n) =  \\mathbf{n}\\cdot \\mathbf{y}_t -  \\delta. We still do an \"optimality cut\" in \\mathbf{y}_t: we cut from the ellipsoid all points y for which \\mathbf{n}\\cdot \\mathbf{y} . Note that  \\mathbf{y}_t might be infeasible, so its value might be larger than OPT. Therefore, we might remove some points whose objective is optimal. However, the removed points satisfy \\mathbf{n}\\cdot \\mathbf{y} ; no point is removed if its value exceeds the value at \\mathbf{z}_tby more than \\delta.\nUsing the approximate separation oracle gives a feasible solution y* to the dual LP, with \\mathbf{n}\\cdot \\mathbf{y^*} \\geq LOPT-\\delta, after at most Q iterations, where Q = 4m^2 \\ln(mn/g\\delta). The total run-time of the ellipsoid method with the approximate separation oracle is O(Q m n /\\delta).\nEliminating constraints\nDuring the ellipsoid method, we use at most Q constraints of the form \\mathbf{a}\\cdot \\mathbf{y} \\leq 1. All the other constraints can be eliminated, since they have no effect on the outcome y* of the ellipsoid method. We can eliminate even more constraints. It is known that, in any LP with m variables, there is a set of m constraints that is sufficient for determining the optimal solution (that is, the optimal value is the same even if only these m constraints are used). We can repeatedly run the ellipsoid method as above, each time trying to remove a specific set of constraints. If the resulting error is at most \\delta, then we remove these constraints permanently. It can be shown that we need at most \\approx (Q/m) + m\\ln(Q/m) eliminations, so the accumulating error is at most \\approx \\delta\\cdot [(Q/m) + m\\ln(Q/m)]. If we try sets of constraints deterministically, then in the worst case, one out of m trials succeeds, so we need to run the ellipsoid method at most \\approx m\\cdot[(Q/m) + m\\ln(Q/m)]\n= Q+m^2\\ln(Q/m)\ntimes. If we choose the constraints to remove at random, then the expected number of iterations is  O(m)\\cdot[1 + \\ln(Q/m)].\nFinally, we have a reduced dual LP, with only m variables and m constraints. The optimal value of the reduced LP is at least  LOPT-h, where h \\approx \\delta\\cdot [(Q/m) + m\\ln(Q/m)].\nSolving the primal LP\nBy the LP duality theorem, the minimum value of the primal LP equals the maximum value of the dual LP, which we denoted by LOPT. Once we have a reduced dual LP, we take its dual, and take a reduced primal LP. This LP has only m variables - corresponding to only m out of C configurations. The maximum value of the reduced dual LP is at least  LOPT-h. It can be shown that the optimal solution of the reduced primal LP is at most  LOPT+h. The solution gives a near-optimal bin packing, using at most m configurations.\nThe total run-time of the deterministic algorithm, when all items are larger than g\\cdot B, is:\nO\\left(\\frac{Q m n}{\\delta}\n\\cdot( Q+m^2\\ln\\frac{Q}{m})\n\\right)\n=\nO\n\\left(\\frac{Q^2 m n + Q m^3 n\\ln\\frac{Q}{m}}{\\delta}\n\\right)\n\\approx\nO\\left(m^8 \\ln{m} \\ln^2(\\frac{m n}{g h}) + \\frac{m^4 n \\ln{m}}{h}\\ln(\\frac{m n}{g h}) \\right),\nThe expected total run-time of the randomized algorithm is: O\\left(m^7 \\log{m} \\log^2(\\frac{m n}{g h}) + \\frac{m^4 n \\log{m}}{h}\\log(\\frac{m n}{g h}) \\right).\nEnd-to-end algorithms\nKarmarkar and Karp presented three algorithms, that use the above techniques with different parameters. The run-time of all these algorithms depends on a function T(\\cdot,\\cdot), which is a polynomial function describing the time it takes to solve the fractional LP with tolerance h=1, which is, for the deterministic version,T(m,n)\\in O(m^8\\log{m}\\log^2{n} + m^4 n \\log{m}\\log{n} ).\nAlgorithm 1\nLet  \\epsilon>0 be a constant representing the desired approximation accuracy.\n*1-a. Set g = \\max(1/n, \\epsilon/2). Let J be an instance constructed from I by removing all items smaller than g.\n**2-a. Set k = n\\cdot \\epsilon^2.  Let K be an instance constructed from J by linear grouping with parameter k, and let ''K' be the remaining instance (the group of k largest items).  Note that m(K) \\leq  n/k + 1 \\approx 1/\\epsilon^2.\n***3-a. Construct the configuration linear program for K, without the integrality constraints.\n****4. Compute a solution x for K, with tolerance h=1. The result is a fractional bin packing with  b_L\\leq LOPT(K)+1 bins. The run-time is T(m(K),n(K)) \\leq T(\\epsilon^{-2},n) .\n***3-b. Round x to an integral solution for K. Add at most m(K)/2 bins for the fractional part. The total number of bins is b_K\\leq b_L + m(K)/2 \\leq LOPT(K)+1 + 1/2\\epsilon^2.\n**2-b. Pack the items in K' using at most k bins; get a packing of J. The number of bins is  b_J\\leq b_K+k \\leq LOPT(K)+1 + 1/2\\epsilon^2 + n\\cdot \\epsilon^2.\n*1-b. Add the items smaller than g to get a solution for I.  The number of bins is: b_I \\leq \\max(b_J, (1+2 g)\\cdot OPT(I) + 1)\\leq (1+\\epsilon)OPT(I) + 1/2\\epsilon^2 + 3.\nAll in all, the number of bins is in (1+\\epsilon)OPT + O(\\epsilon^{-2}) and the run-time is in O(n\\log n + T(\\epsilon^{-2},n)). By choosing \\epsilon = OPT^{-1/3} we get OPT + O(OPT^{2/3}).\nAlgorithm 2\nLet  g>0 be a real parameter and k>0 an integer parameter to be determined later.\n*1-a. Let J be an instance constructed from I by removing all items smaller than g.\n*2. While FOPT(J) > 1+\\frac{k}{k-1}\\ln(1/g) do:\n**2-a. Do the Alternative Geometric Grouping with parameter k. Let K be the resulting instance, and let K' be the remaining instance. We have m(K) \\leq FOPT(J)/k + \\ln(1/g).\n***3-a. Construct the configuration linear program for K, without the integrality constraints.\n****4. Compute a solution x for K, with tolerance h=1. The result is a fractional bin packing with  b_L\\leq LOPT(K)+1 bins. The run-time is T(m(K),n(K)) \\leq T(FOPT(J)/k + \\ln(1/g) ,n) .\n***3-b. Round x to an integral solution for K. Do not add bins for the fractional part. Instead, just remove the packed items from J.\n**2-b. Pack the items in K' in at most 2 k\\cdot (2 + \\ln(1/g)) bins.\n*2. Once FOPT(J) \\leq 1+\\frac{k}{k-1}\\ln(1/g), pack the remaining items greedily into at most 2 FOPT(J) \\leq 2+\\frac{2 k}{k-1}\\ln(1/g) bins.\n**At each iteration of the loop in step 2, the fractional part of x has at most m(K) patterns, so  FOPT(J_{t+1}) \\leq m(K_{t}) \\leq FOPT(J_{t})/k + \\ln(1/g). The FOPT drops by a factor of k in each iteration, so the number of iterations is at most \\frac{\\ln FOPT(I)}{\\ln k}+1.\n**Therefore, the total number of bins used for J is: b_J \\leq OPT(I) + \\left[1+\\frac{\\ln FOPT(I)}{\\ln k}\\right]\\left[1 + 4k + 2k\\ln(1/g)\\right]+ 2 + \\frac{2k}{k-1}\\ln(1/g).\n*1-b. Add the items smaller than g to get a solution for I.  The number of bins is: b_I \\leq \\max(b_J, (1+2 g)\\cdot OPT(I) + 1).\nThe run-time is in O(n\\log n + T(FOPT(J)/k + \\ln(1/g),n)).\nNow, if we choose k=2 and g=1/FOPT(I), we get:b_J \\leq OPT + O(\\log^2(FOPT)) , and hence:b_I \\leq \\max(b_J, OPT+2OPT /FOPT+1)  \\leq \\max(b_J, OPT+5) \\in OPT+\\log^2(OPT), so the total number of bins is in OPT + O(\\log^2(FOPT)). The run-time is  O(n\\log n) + T(FOPT/2 + \\ln(FOPT) ,n)\\in O(n\\log{n} + T(FOPT, n)) .\nThe same algorithm can be used with different parameters to trade-off run-time with accuracy. For some parameter \\alpha\\in(0,1), choose  k=FOPT^{\\alpha} and g=1/FOPT^{1-\\alpha}. Then, the packing needs at most \\mathrm{OPT} + \\mathcal{O}(OPT^\\alpha) bins, and the run-time is in O(n\\log{n} + T(FOPT^{(1-\\alpha)},n)).\nAlgorithm 3\nThe third algorithm is useful when the number of sizes m is small (see also high-multiplicity bin packing).\n*1-a. Set g = \\frac{\\log^2(m)}{FOPT(I)}. Let K be an instance constructed from I by removing all items smaller than g.\n*If m(K)\\leq FOPT(K) then:\n**3-a. Construct the configuration linear program for K, without the integrality constraints.\n***4. Compute a solution x for K, with tolerance h=1. The result is a fractional bin packing with  b_L\\leq LOPT(K)+1 bins. The run-time is T(m(K),n(K)) \\leq T(\\epsilon^{-2},n) .\n**3-b. Round x to an integral solution for K. Do not add bins for the fractional part. Instead, just remove the packed items from K.\n* Run step 2 of Algorithm 2 on the remaining pieces.\n*1-b. Add the items smaller than g'' to get a solution for I.  The number of bins is: b_I \\leq \\max(b_J, (1+2 g)\\cdot OPT(I) + 1).\nIt uses at most \\mathrm{OPT} + \\mathcal{O}(\\log^2 m) bins, and the run-time is in O(n\\log{n} + T(m,n)).\nImprovements\nThe KK techniques were improved later, to provide even better approximations.\nRothvoss uses the same scheme as Algorithm 2, but with a different rounding procedure in Step 2. He introduced a \"gluing\" step, in which small items are glued together to yield a single larger item. This gluing can be used to increase the smallest item size to about B/\\log^{12}(n). When all sizes are at least B/\\log^{12}(n), we can substitute g = 1/\\log^{12}(n) in the guarantee of Algorithm 2, and get:b_J \\leq OPT(I) + O(\\log(FOPT)\\log(\\log(n))), which yields a \\mathrm{OPT} + O(\\log(\\mathrm{OPT})\\cdot \\log\\log(\\mathrm{OPT})) bins.\nHoberg and Rothvoss use a similar scheme in which the items are first packed into \"containers\", and then the containers are packed into bins. Their algorithm needs at most b_J \\leq OPT(I) + O(\\log(OPT)) bins.\nReferences"
    }
  ]
}