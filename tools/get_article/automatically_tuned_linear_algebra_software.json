{
  "content": [
    {
      "type": "text",
      "text": "# Automatically Tuned Linear Algebra Software\n\n-->\n| ver layout =\n| discontinued =\n| latest release version = 3.10.3\n| latest release date =\n| latest preview version =\n| latest preview date =\n| repo =\n| qid =\n| programming language = C, FORTRAN 77\n| middleware =\n| engine =\n| operating system =\n| platform =\n| included with =\n| replaces =\n| replaced_by =\n| service_name =\n| size =\n| standard =\n| language =\n| language count =\n| language footnote =\n| genre = Software library\n| license = BSD License\n| website =\n| AsOf =\n}}\nAutomatically Tuned Linear Algebra Software (ATLAS) is a software library for linear algebra. It provides a mature open source implementation of BLAS APIs for C and FORTRAN 77.\nATLAS is often recommended as a way to automatically generate an optimized BLAS library. While its performance often trails that of specialized libraries written for one specific hardware platform, it is often the first or even only optimized BLAS implementation available on new systems and is a large improvement over the generic BLAS available at Netlib. For this reason, ATLAS is sometimes used as a performance baseline for comparison with other products.\nATLAS runs on most Unix-like operating systems and on Microsoft Windows (using Cygwin). It is released under a BSD-style license without advertising clause, and many well-known mathematics applications including MATLAB, Mathematica, Scilab, SageMath, and some builds of GNU Octave may use it.\nFunctionality\nATLAS provides a full implementation of the BLAS APIs as well as some additional functions from LAPACK, a higher-level library built on top of BLAS. In BLAS, functionality is divided into three groups called levels 1, 2 and 3.\n* Level 1 contains vector operations of the form\n::\\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\mathbf{y} \\!\n:as well as scalar dot products and vector norms, among other things.\n* Level 2 contains matrix-vector operations of the form\n::\\mathbf{y} \\leftarrow \\alpha A \\mathbf{x} + \\beta \\mathbf{y} \\!\n:as well as solving T \\mathbf{x} = \\mathbf{y} for \\mathbf{x} with T being triangular, among other things.\n* Level 3 contains matrix-matrix operations such as the widely used General Matrix Multiply (GEMM) operation\n::C \\leftarrow \\alpha A B + \\beta C \\!\n:as well as solving B \\leftarrow \\alpha T^{-1} B for triangular matrices T, among other things.\nOptimization approach\nThe optimization approach is called Automated Empirical Optimization of Software (AEOS), which identifies four fundamental approaches to computer assisted optimization of which ATLAS employs three:\n# Parameterization—searching over the parameter space of a function, used for blocking factor, cache edge, etc.\n# Multiple implementation—searching through various approaches to implementing the same function, e.g., for SSE support before intrinsics made them available in C code\n# Code generation—programs that write programs incorporating what knowledge they can about what will produce the best performance for the system\n* Optimization of the level 1 BLAS uses parameterization and multiple implementation\n: Every ATLAS level 1 BLAS function has its own kernel. Since it would be difficult to maintain thousands of cases in ATLAS there is little architecture specific optimization for Level 1 BLAS. Instead multiple implementation is relied upon to allow for compiler optimization to produce high performance implementation for the system.\n* Optimization of the level 2 BLAS uses parameterization and multiple implementation\n: With N^2 data and N^2 operations to perform the function is usually limited by bandwidth to memory, and thus there is not much opportunity for optimization\n: All routines in the ATLAS level 2 BLAS are built from two Level 2 BLAS kernels:\n:* GEMV—matrix by vector multiply update:\n:::\\mathbf{y} \\leftarrow \\alpha A \\mathbf{x} + \\beta \\mathbf{y} \\!\n:* GER—general rank 1 update from an outer product:\n:::A \\leftarrow \\alpha \\mathbf{x} \\mathbf{y}^T + A \\!\n* Optimization of the level 3 BLAS uses code generation and the other two techniques\n: Since we have N^3 ops with only N^2 data, there are many opportunities for optimization\nLevel 3 BLAS\nMost of the Level 3 BLAS is derived from GEMM, so that is the primary focus of the optimization.\n:O(n^3) operations vs. O(n^2) data\nThe intuition that the n^3 operations will dominate over the n^2 data accesses only works for roughly square matrices.\nThe real measure should be some kind of surface area to volume.\nThe difference becomes important for very non-square matrices.\nCan it afford to copy?\nCopying the inputs allows the data to be arranged in a way that provides optimal access for the kernel functions,\nbut this comes at the cost of allocating temporary space, and an extra read and write of the inputs.\nSo the first question GEMM faces is, can it afford to copy the inputs?\nIf so,\n* Put into block major format with good alignment\n* Take advantage of user contributed kernels and cleanup\n* Handle the transpose cases with the copy: make everything into TN (transpose - no-transpose)\n* Deal with &alpha; in the copy\nIf not,\n* Use the nocopy version\n* Make no assumptions on the stride of matrix A and B in memory\n* Handle all transpose cases explicitly\n* No guarantee about alignment of data\n* Support &alpha; specific code\n* Run the risk of TLB issues, bad strides, etc.\nThe actual decision is made through a simple heuristic which checks for \"skinny cases\".\nCache edge\nFor 2nd Level Cache blocking a single cache edge parameter is used.\nThe high level choose an order to traverse the blocks: ijk, jik, ikj, jki, kij, kji.\nThese need not be the same order as the product is done within a block.\nTypically chosen orders are ijk or jik.\nFor jik the ideal situation would be to copy A and the NB wide panel of B.\nFor ijk swap the role of A and B.\nChoosing the bigger of M or N for the outer loop reduces the footprint of the copy.\nBut for large K ATLAS does not even allocate such a large amount of memory.\nInstead it defines a parameter, Kp, to give best use of the L2 cache.\nPanels are limited to Kp in length.\nIt first tries to allocate (in the jik case) M\\cdot p + NB\\cdot Kp + NB\\cdot NB.\nIf that fails it tries 2\\cdot Kp\\cdot NB + NB\\cdot NB.\n(If that fails it uses the no-copy version of GEMM, but this case is unlikely for reasonable choices of cache edge.)\nKp is a function of cache edge and NB.\nLAPACK\nWhen integrating the ATLAS BLAS with LAPACK an important consideration is the choice of blocking factor for LAPACK. If the ATLAS blocking factor is small enough the blocking factor of LAPACK could be set to match that of ATLAS.\nTo take advantage of recursive factorization, ATLAS provides replacement routines for some LAPACK routines. These simply overwrite the corresponding LAPACK routines from Netlib.\nNeed for installation\nInstalling ATLAS on a particular platform is a challenging process which is typically done by a system vendor or a local expert and made available to a wider audience.\nFor many systems, architectural default parameters are available; these are essentially saved searches plus the results of hand tuning.\nIf the arch defaults work they will likely get 10–15% better performance than the install search. On such systems the installation process is greatly simplified.\nReferences\nExternal links\n*\n*[https://math-atlas.sourceforge.net/devel/atlas_contrib/ User contribution to ATLAS]\n*[https://math-atlas.sourceforge.net/devel/atlas_devel/ A Collaborative guide to ATLAS Development]\n*The [https://math-atlas.sourceforge.net/faq.html#doc FAQ] has links to the Quick reference guide to BLAS and Quick reference to ATLAS LAPACK API reference\n*[http://www.terborg.net/research/kml/installation.html Microsoft Visual C++ Howto]  for ATLAS"
    }
  ]
}