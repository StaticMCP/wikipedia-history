{
  "content": [
    {
      "type": "text",
      "text": "# Region (model checking)__disambig_1\n\n}}\nIn model checking, a field of computer science, a region is a convex polytope in \\mathbb R^d for some dimension d, and more precisely a zone, satisfying some minimality property. The regions partition \\mathbb R^d.\nThe set of zones depends on a set K of constraints of the form x\\le c, x\\ge c, x_1\\le x_2+c and x_1\\ge x_2+c, with x_1 and x_2 some variables, and c a constant. The regions are defined such that if two vectors \\vec x and \\vec x' belong to the same region, then they satisfy the same constraints of K. Furthermore, when those vectors are considered as a tuple of clocks, both vectors have the same  set of possible futures. Intuitively, it means that any timed propositional temporal logic-formula, or timed automaton or signal automaton using only the constraints of K can not distinguish both vectors.\nThe set of region allows to create the region automaton, which is a directed graph in which each node is a region, and each edge r\\to r' ensure that r' is a possible future of r. Taking a product of this region automaton and of a timed automaton \\mathcal A which accepts a language L creates a finite automaton or a B端chi automaton which accepts untimed L. In particular, it allows to reduce the emptiness problem for \\mathcal A to the emptiness problem for a finite or B端chi automaton. This technique is used for example by the software UPPAAL.\nDefinition\nLet C=\\{x_1,\\dots,x_d\\} a set of clocks. For each x\\in\\mathbb N let c_x\\in\\mathbb N. Intuitively, this number represents an upper bound on the values to which the clock x can be compared. The definition of a region over the clocks of C uses those numbers c_x's.  Three equivalent definitions are now given.\nGiven a clock assignment \\nu,  [\\nu] denotes the region in which  \\nu belongs. The set of regions is denoted by \\mathcal R.\nEquivalence of clocks assignment\nThe first definition allow to easily test whether two assignments belong to the same region.\nA region may be defined as an equivalence class for some equivalence relation. Two clocks assignments \\nu_1 and \\nu_2 are equivalent if they satisfy the following constraints:\n* \\nu_1(x)\\sim c iff \\nu_2(x)\\sim c, for each x\\in C and 0\\le c\\le c_x an integer, and ~ being one of the following relation =, &lt; or &le;.\n* \\{\\nu_1(x)\\}\\sim \\{\\nu_1(y)\\} iff \\{\\nu_2(x)\\}\\sim \\{\\nu_2(y)\\}, for each x,y\\in C, \\nu_1(x)\\le c_x, \\nu_1(y)\\le c_y, \\{r\\} being the fractional part of  the real r,  and ~ being one of the following relation =, &lt; or &le;.\nThe first kind of constraints ensures that \\nu_1 and \\nu_2 satisfies the same constraints. Indeed, if \\nu_1(x)=0.5 and \\nu_2(x)=1, then only the second assignment satisfies x=1. On the other hand, if \\nu_1(x)=0.5 and \\nu_2(x)=0.6, both assignment satisfies exactly the same set of constraint, since the constraints use only integral constants.\nThe second kind of constraints ensures that the future of two assignments satisfy  the  same constraints. For example, let \\nu_1=\\{x\\mapsto 0.5, y\\mapsto 0.6\\} and \\nu_2=\\{x\\mapsto 0.5, y\\mapsto 0.4\\}. Then, the constraint y=1\\land x is eventually satisfied by the future of \\nu_1  without clock reset, but not by the future of \\nu_2 without clock reset.\nExplicit definition of a region\nWhile the previous definition allow to test whether two assignments belong to the same region, it does not allow to easily represents a region as a data structure. The third definition given below allow to give a canonical encoding of a region.\nA region can be explicitly defined as a zone, using a set S of equations and inequations satisfying the following constraints:\n* for each x\\in C, S contains either:\n** x=c for some integer 0\\le c\\le c_x\n** x\\in(c,c+1) for some integer 0\\le c,\n** x> c_x,\n* furthermore, for each pair of clocks x,y\\in C, where S contains constraints of the form x\\in (c,c+1) and y\\in (c',c'+1), then S contains an (in) equality of the form  \\{x\\}\\sim \\{y\\} with \\sim being either =, &lt; or &le;.\nSince, when c and c' are fixed, the last constraint is equivalent to x\\sim y+c-c'.\nThis definition allow to encode a region as a data structure. It suffices, for each clock, to state to which interval it belongs and to recall the order of the fractional part of the  clocks which belong in an open interval of length 1. It follows that the size of this structure is O\\left(\\sum\\log(c_k)+|C|\\log(|C|)\\right) with |C| the number of clocks.\nTimed bisimulation\nLet us now give a third definition of regions. While this definition is more abstract, it is also the reason why regions are used in model checking. Intuitively, this definition states that two clock assignments belong to the same region if the differences between  them  are  such that no timed automaton can notice them.  Given any run r starting with a clock assignment \\nu, for any other assignment \\nu' in the same region, there is a run r', going through the same locations, reading the same letters, where the only difference is that the time waited between two successive transition may be different, and thus the successive clock variations are different.\nThe formal definition is now given. Given a set of clock C, two assignments two clocks assignments \\nu_1 and \\nu_2 belongs to the same region if for each timed automaton \\mathcal A in which the guards never compare a clock x to a number greater than c_x, given any location \\ell of \\mathcal A, there is a timed bisimulation between the extended states (\\ell,\\nu_1) and (\\ell,\\nu_2). More precisely, this bisimulation preserves letters and locations but not the exact clock assignments.\nOperation on regions\nSome operations are now defined over regions: Resetting some of its clock, and letting time pass.\nResetting clocks\nGiven a region \\alpha defined by a set of (in)equations S, and a set of clocks C'\\subseteq C, the region similar to \\alpha in which the clocks of C' are restarted is now defined. This region is denoted by \\alpha[C'\\mapsto 0], it is defined by the following constraints:\n* each constraints of S not containing the clock x,\n* the constraints x=0 for x\\in C'.\nThe set of assignments defined by \\alpha[C'\\mapsto 0] is exactly the set of assignments \\nu[C'\\mapsto0] for \\nu\\in\\alpha.\nTime-successor\nGiven a region \\alpha, the regions which can be attained without resetting a clock are called the time-successors of \\alpha. Two equivalent definitions are now given.\nDefinition\nA clock region \\alpha' is a time-successor of another clock region \\alpha if for each assignment \\nu\\in\\alpha, there exists some positive real t_{\\nu,\\alpha'}>0 such that \\nu+t_{\\nu,\\alpha'}\\in\\alpha'.\nNote that it does not mean that \\alpha+t_{\\nu,\\alpha'}=\\alpha'. For example, the region \\alpha defined by the set of constraint \\{0 has the time-successor \\alpha' defined by the set of constraint \\{0. Indeed, for each \\nu\\in\\alpha, it suffices to take t_{\\nu,\\alpha'}=1-\\nu(y).  However, there exists no real t such that \\alpha+t=\\alpha' or even such that \\alpha+t\\subseteq\\alpha'; indeed, \\alpha defines a triangle while \\alpha' defines a segment.\nComputable definition\nThe second definition now given allow to explicitly compute the set of time-successor of a region, given by its set of constraints.\nGiven a region \\alpha defined as a set of constraints S, let us define its set of time-successors. In order to do so, the following variables are required. Let  T\\subseteq S the set of constraints of S of the form x_i=c_i. Let Y\\subseteq C the set of clocks y such that S contains the constraint y>c_y. Let Z\\subseteq C\\setminus Y the set of clocks \\{z\\} such that there are no constraints  of the form \\{x\\} in S.\nIf T is empty, \\alpha is its own time successor. If Y=C, then \\alpha is the only time-successor of \\alpha. Otherwise, there is a least time-successor of \\alpha not equal to \\alpha. The least time-successor, if T is non-empty, contains:\n* the constraints of S\\setminus T\n* x_i>c_i,\n* \\{x_i\\}=\\{x_j\\}, and\n* for each y such that y>c_y does not belong to S, the constraint x_i.\nIf T is empty,  the least time-successor is defined by the following constraints:\n* the constraints of S not using the clocks of Z,\n* the constraint z=c+1, for each constraint c in S, with z\\in Z.\nProperties\nThere are at most |C|!2^{|C|}\\prod_{x\\in C}(2c_x+2) regions, where |C| is the number of clocks.\nRegion automaton\nGiven a timed automaton \\mathcal A, its region automaton is a finite automaton or a B端chi automaton which accepts untimed L. This automaton is similar to \\mathcal A, where clocks are replaced by region. Intuitively, the region automaton is contructude as a product of \\mathcal A and of the region graph. This region graph is defined first.\nRegion graph\nThe region graph is a rooted directed graph which models the set of possible clock valuations during a run of a timed-autoamton. It is defined as follows:\n* its nodes are regions,\n* its root is the initial region \\alpha_0, defined by the set of constraints \\{x=0\\mid x\\in C\\},\n* the set of edges are (\\alpha,\\alpha'[C'\\mapsto 0]), for \\alpha' a time-successor of \\alpha.\nRegion automaton\nLet \\mathcal A=\\langle \\Sigma,L,L_0,C,F,E\\rangle a timed automaton. For each clock x\\in C, let c_x the greatest number c such that there exists a guard of the form x\\sim c in \\mathcal A. The region automaton of \\mathcal A, denoted by R(\\mathcal A) is a finite or B端chi automaton which is essentially a product of \\mathcal A and of the region graph defined above.  That is, each state of the region automaton is a pair containing a location of \\mathcal A and a region. Since two clocks assignment belonging to the same region satisfies the same guard, each region contains enough information to decide which transitions can be taken.\nFormally, the region automaton is defined as follows:\n* its alphabet is \\Sigma,\n* its set of states is L\\times\\mathcal R,\n* its set of states is L_0\\times\\{\\alpha_0\\} with \\alpha_0 the initial region,\n* its set of accepting states is F\\times\\mathcal R,\n* its transition relation \\delta contains  ((\\ell,\\alpha),a,(\\ell',\\alpha'[C'\\mapsto0])), for (\\ell,a,g,C',\\ell')\\in E, such that \\gamma\\models\\alpha' and \\alpha' is a time-successor of \\alpha.\nGiven any run r=(\\ell_0,\\nu_0)\\xrightarrow[t_1]{\\sigma_1}(\\ell_1,\\nu_1)\\dots of \\mathcal A, the sequence (\\ell_0,[\\nu_0])\\xrightarrow{\\sigma_1}(\\ell_1,[\\nu_1])\\dots is denoted [r], it is a run of R(\\mathcal A) and is accepting if and only if r is accepting. It follows that L(R(\\mathcal A))=\\operatorname{Untime}(L(\\mathcal A)). In particular, \\mathcal A accepts a timed-word if and only if R(\\mathcal A) accepts a word. Furthermore, an accepting run of \\mathcal A can be computed from an accepting run of R(\\mathcal A).\nReferences"
    }
  ]
}