{
  "content": [
    {
      "type": "text",
      "text": "# List of software development philosophies\n\nThis is a list of approaches, styles, methodologies, and philosophies in software development and engineering. It also contains programming paradigms, software development methodologies, software development processes, and single practices, principles, and laws.\nSome of the mentioned methods are more relevant to a specific field than another, such as automotive or aerospace. The trend towards agile methods in software engineering is noticeable, however the need for improved studies on the subject is also paramount. Also note that some of the methods listed might be newer or older or still in use or out-dated, and the research on software design methods is not new and on-going.\nSoftware development methodologies, guidelines, strategies\nLarge-scale programming styles\n* Behavior-driven development\n* Design-driven development\n* Domain-driven design\n* Secure by design\n* Test-driven development\n** Acceptance test-driven development\n** Continuous test-driven development\n** Specification by example\n* Data-driven development\n* Data-oriented design\nSpecification-related paradigms\n* Iterative and incremental development\n* Waterfall model\n* Formal methods\nComprehensive systems\n* Agile software development\n** Lean software development\n* Lightweight methodology\n** Adaptive software development\n** Extreme programming\n** Feature-driven development\n** ICONIX\n* Kanban (development)\n*Unified Process\n**Rational Unified Process\n**Agile Unified Process\nRules of thumb, laws, guidelines and principles\n* [https://www.managingtheunmanageable.net/morerulesofthumb.html 300 Rules of Thumb and Nuggets of Wisdom] (excerpt from Managing the Unmanageable - Rules, Tools, and Insights for Managing Software People and Teams by Mickey W. Mantle, Ron Lichty)\n*ACID\n*Big ball of mud\n*Brooks's law\n*C++ Core Guidelines (Stroustrup/Sutter) P1 - P13 Philosophy rules\n*CAP theorem\n*Code reuse\n*Command–query separation (CQS)\n*Conway's law\n*Cowboy coding\n*Do what I mean (DWIM)\n*Don't repeat yourself (DRY)\n*Egoless programming\n*Fail-fast\n*Gall's law\n*General Responsibility Assignment Software Patterns (GRASP)\n*If it ain't broke, don't fix it\n*Inheritance (OOP)\n*KISS principle\n*Law of Demeter, also known as the principle of least knowledge\n*Law of conservation of complexity, also known as Tesler's Law\n*Lehman's laws of software evolution\n* Loose coupling\n* Minimalism (computing)\n*Ninety–ninety rule\n* Open–closed principle\n* Package principles\n*Pareto principle\n* Parkinson's law\n*Principle of least astonishment (POLA)\n* Release early, release often\n* Robustness principle, also known as Postel's law\n* Rule of least power\n* SEMAT\n* Separation of concerns\n*Separation of mechanism and policy\n* Single source of truth (SSOT)\n* Single version of the truth (SVOT)\n* SOLID (object-oriented design)\n*There's more than one way to do it\n*Uniform access principle\n*Unix philosophy\n*Worse is better\n*You aren't gonna need it (YAGNI)\nOther\n* Davis 201 Principles of Software Development\n* ''Don't Make Me Think'' (Principles of intuitive navigation and information design)\n*The Art of Computer Programming (general computer-science masterpiece by Donald E. Knuth)\n*The Cathedral and the Bazaar - book comparing top-down vs. bottom-up open-source software\n*The Philosophy of Computer Science\n*Where's the Theory for Software Engineering?\n*The Yo-yo problem\nProgramming paradigms\n* Agent-oriented programming\n* Aspect-oriented programming (AOP)\n*Convention over configuration\n* Component-based software engineering\n* Functional programming (FP)\n*Hierarchical object-oriented design (HOOD)\n* Literate programming\n* Logic programming\n* Modular programming\n* Object-oriented programming (OOP)\n*Procedural programming\n* Reactive programming\nSoftware development methodologies\n* Agile Unified Process (AUP)\n* Constructionist design methodology (CDM)\n* Dynamic systems development method (DSDM)\n* Extreme programming (XP)\n* Iterative and incremental development\n* Kanban\n* Lean software development\n* Model-based system engineering (MBSE)\n* Pair programming\n* Mob programming\n* Rapid application development (RAD)\n* Rational Unified Process (RUP)\n* Rubber duck debugging\n* Scrum\n* Structured systems analysis and design method (SSADM)\n* Unified Process (UP)\nSoftware development processes\n* Active-Admin-driven development (AADD)\n* Behavior-driven development (BDD)\n* Bug-driven development (BgDD)\n* Configuration-driven development (CDD)\n* Readme-driven development (RDD)\n* Design-driven development (D3)\n* Domain-driven design (DDD)\n* Feature-driven development (FDD)\n* Test-driven development (TDD)\n* User-centered design (UCD) (User-Driven Development (UDD))\n* Value-driven design (VDD)\n*Software review\n*Software quality assurance\nSee also\n* Anti-pattern\n*Coding conventions\n* Design pattern\n* Programming paradigm\n* Software development methodology\n* Software development process\n* Outline of computer science\n* Outline of software engineering\n* Outline of computer engineering\n* Outline of computer programming\n* Outline of software development\n* Outline of web design and web development\n* Outline of computers\n* :Category:Programming principles\nFurther reading\n* ISO/IEC/IEEE 26515:2018(E) - ISO/IEC/IEEE International Standard - Systems and software engineering — Developing information for users in an agile environment\nOther materials, books, articles, etc.\n* ''Don't Make Me Think'' (book by Steve Krug about human computer interaction and web usability)\nReferences"
    }
  ]
}