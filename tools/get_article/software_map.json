{
  "content": [
    {
      "type": "text",
      "text": "# Software map\n\nA software map represents static, dynamic, and evolutionary information of software systems and their software development processes by means of 2D or 3D map-oriented information visualization. It constitutes a fundamental concept and tool in software visualization, software analytics, and software diagnosis. Its primary applications include risk analysis for and monitoring of code quality, team activity, or software development progress  and, generally, improving effectiveness of software engineering with respect to all related artifacts, processes, and stakeholders throughout the software engineering process and software maintenance.\nMotivation and concepts\nSoftware maps are applied in the context of software engineering: Complex, long-term software development projects are commonly faced by manifold difficulties such as the friction between completing system features and, at the same time, obtaining a high degree of code quality and software quality to ensure software maintenance of the system in the future. In particular, \"Maintaining complex software systems tends to be costly because developers spend a significant part of their time with trying to understand the systemâ€™s structure and behavior.\" The key idea of software maps is to cope with that challenge and optimization problems by providing effective communication means to close the communication gap among the various stakeholders and information domains within software development projects and obtaining insights in the sense of information visualization.\nSoftware maps take advantage of well-defined cartographic map techniques using the virtual 3D city model metaphor to express the underlying complex, abstract information space. The metaphor is required \"since software has no physical shape, there is no natural mapping of software to a two-dimensional space\". Software maps are non-spatial maps that have to convert the hierarchy data and its attributes into a spatial representation.\nApplications\nSoftware maps generally allow for comprehensible and effective communication of course, risks, and costs of software development projects to various stakeholders such as management and development teams. They communicate the status of applications and systems currently being developed or further developed to project leaders and management at a glance. \"A key aspect for this decision-making is that software maps provide the structural context required for correct interpretation of these performance indicators\". As an instrument of communication, software maps act as open, transparent information spaces which enable priorities of code quality and the creation of new functions to be balanced against one another and to decide upon and implement necessary measures to improve the software development process.\nFor example, they facilitate decisions as to where in the code an increase in quality would be beneficial both for speeding up current development activities and for reducing risks of future maintenance problems.\nDue to their high degree of expressiveness (e.g., information density) and their instantaneous, automated generation, the maps additionally serve to reflect the current status of system and development processes, bridging an essential information gap between management and development teams, improve awareness about the status, and serve as early risk detection instrument.\nContents\nSoftware maps are based on objective information as determined by the KPI driven code analysis as well as by imported information from software repository systems, information from the source codes, or software development tools and programming tools. In particular, software maps are not bound to a specific programming language, modeling language, or software development process model.\nSoftware maps use the hierarchy of the software implementation artifacts such as source code files as a base to build a tree mapping, i.e., a rectangular area that represents the whole hierarchy, subdividing the area into rectangular sub-areas. A software map, informally speaking, looks similar to a virtual 3D city model, whereby artifacts of the software system appear as virtual, rectangular 3D buildings or towers, which are placed according to their position in the software implementation hierarchy.\nSoftware maps can express and combine information about software development, software quality, and system dynamics by mapping that information onto visual variables of the tree map elements such as footprint size, height, color or texture. They can systematically be specified, automatically generated, and organized by templates.\nMapping software system example\nSoftware maps \"combine thematic information about software development processes (evolution), software quality, structure, and dynamics and display that information in a cartographic manner\". For example:\n* The height of a virtual building can be proportional to the complexity of the code unit (e.g., single or combined software metrics).\n* The ground area of a virtual 3D building can be proportional to the number of lines of code in the module or (e.g., non-comment lines-of-code NCLOC).\n* The color can express the current development status, i.e., how many developers are changing/editing the code unit.\nWith this exemplary configuration, the software map shows crucial points in the source code with relations to aspects of the software development process. For example, it becomes obvious at a glance what to change in order to:\n* implement changes quickly;\n* evaluate quickly the impact of changes in one place on functionality elsewhere;\n* reduce entanglements that lead to uncontrolled processes in the application;\n* find errors faster;\n* discover and eliminate bad programming style.\nSoftware maps represent key tools in the scope of automated software diagnosis [http://www.softwarediagnostics.com software diagnostics].\nAs business intelligence tools and recommendation systems\nSoftware maps can be used, in particular, as analysis and presentation tool of business intelligence systems, specialized in the analysis of software related data. Furthermore, software maps \"serve as recommendation systems for software engineering\".\nSoftware maps are not limited by software-related information: They can include any hierarchical system information as well, for example, maintenance information about complex technical artifacts.\nVisualization techniques\nSoftware maps are investigated in the domain of software visualization. The visualization of software maps is commonly based on tree mapping, \"a space-filling approach to the visualization of hierarchical information structures\" or other hierarchy mapping approaches.\nLayout algorithms\nTo construct software maps, different layout approaches are used to generate the basic spatial mapping of components, such as:\n* Tree-map algorithms that initially map the software hierarchy into a recursively nested rectangular area.\n* Voronoi-map algorithms that initially map the software hierarchy by generating a Voronoi map.\nLayout stability\nThe spatial arrangement computed by layouts such as defined by tree maps strictly depends on the hierarchy. If software maps have to be generated frequently for an evolving or changing system, the usability of software maps is affected by non-stable layouts, that is, minor changes to the hierarchy may cause significant changes to the layout.\nIn contrast to regular Voronoi treemap algorithms, which do not provide deterministic layouts, the layout algorithm for Voronoi treemaps can be extended to provides a high degree of layout similarity for varying hierarchies. Similar approaches exist for the tree-map based case.\nHistory\nSoftware maps methods and techniques belong to the scientific discipline of software visualization and information visualization. They form a key concept and technique within the fields of software diagnosis. They also have applications in software mining and software analytics. Software maps have been extensively developed and researched by, e.g., at the Hasso Plattner Institute for IT systems engineering, in particular for large-scale, complex IT systems and applications.\nReferences\nExternal links\n* Scientific conference VISSOFT (IEEE Working Conference on Software Visualization) [http://vissoft.iro.umontreal.ca]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2013/2193/TSD2013.html Interactive Rendering of Complex 3D-Treemaps]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2013/2272/TDT2013.html Multiscale Visual Comparison of Execution Traces]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2013/2275/LWTD2013.html Interactive Software Maps for Web-Based Source Code Analysis]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2012/2076/TD2012.html Extending Recommendation Systems with Software Maps]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2012/2113/TBD2012.html A Visual Analysis Approach to Support Perfective Software Maintenance]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2012/2126/TTD2012.html ViewFusion: Correlating Structure and Activity Views for Execution Traces]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2011/2071/BTD2011.html A Visual Analysis and Design Tool for Planning Software Reengineerings]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2011/2033/LTD2011.html Interactive Areal Annotations for 3D Treemaps of Large-Scale Software Systems]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2011/2048/BOH11.html Visualization of Execution Traces and its Application to Software Maintenance]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2010/1219/TBD10.html Understanding Complex Multithreaded Software Systems by Using Trace Visualization]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2010/1218/TBVD10.html Visualization of Multithreaded Behavior to Facilitate Maintenance of Complex Software Systems]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2009/812/BKD09.html Visualizing Massively Pruned Execution Traces to Facilitate Trace Exploration]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2009/825/BVD09.html Projecting Code Changes onto Execution Traces to Support Localization of Recently Introduced Bugs]\n* [http://www.hpi.uni-potsdam.de/doellner/publications/year/2013/2284/KTD2013.html SyncTrace: Visual Thread-Interplay Analysis]"
    }
  ]
}