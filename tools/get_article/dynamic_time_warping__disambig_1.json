{
  "content": [
    {
      "type": "text",
      "text": "# Dynamic time warping__disambig_1\n\nIn time series analysis, dynamic time warping (DTW) is an algorithm for measuring similarity between two temporal sequences, which may vary in speed.  For instance, similarities in walking could be detected using DTW, even if one person was walking faster than the other, or if there were accelerations and decelerations during the course of an observation. DTW has been applied to temporal sequences of video, audio, and graphics data — indeed, any data that can be turned into a one-dimensional sequence can be analyzed with DTW. A well-known application has been automatic speech recognition, to cope with different speaking speeds. Other applications include speaker recognition and online signature recognition. It can also be used in partial shape matching applications.\nIn general, DTW is a method that calculates an optimal match between two given sequences (e.g. time series) with certain restriction and rules:\n* Every index from the first sequence must be matched with one or more indices from the other sequence, and vice versa\n* The first index from the first sequence must be matched with the first index from the other sequence (but it does not have to be its only match)\n* The last index from the first sequence must be matched with the last index from the other sequence (but it does not have to be its only match)\n* The mapping of the indices from the first sequence to indices from the other sequence must be monotonically increasing, and vice versa, i.e. if j > i are indices from the first sequence, then there must not be two indices l > k in the other sequence, such that index i is matched with index l and index j is matched with index k, and vice versa\nWe can plot each match between the sequences 1:M and 1:N as a path in a M\\times N matrix from (1, 1) to (M, N), such that each step is one of (0, 1), (1, 0), (1, 1). In this formulation, we see that the number of possible matches is the Delannoy number.\nThe optimal match is denoted by the match that satisfies all the restrictions and the rules and that has the minimal cost, where the cost is computed as the sum of absolute differences, for each matched pair of indices, between their values.\nThe sequences are \"warped\" non-linearly in the time dimension to determine a measure of their similarity independent of certain non-linear variations in the time dimension. This sequence alignment method is often used in time series classification. Although DTW measures a distance-like quantity between two given sequences, it doesn't guarantee the triangle inequality to hold.\nIn addition to a similarity measure between the two sequences (a so called \"warping path\" is produced), by warping according to this path the two signals may be aligned in time. The signal with an original set of points X(original), Y(original) is transformed to X(warped), Y(warped). This finds applications in genetic sequence and audio synchronisation. In a related technique sequences of varying speed may be averaged using this technique see the average sequence section.\nThis is conceptually very similar to the Needleman–Wunsch algorithm.\nImplementation\nThis example illustrates the implementation of the dynamic time warping algorithm when the two sequences s and t are strings of discrete symbols. For two symbols x and y, d(x, y) is a distance between the symbols, e.g., d(x, y)= | x - y |.\nint DTWDistance(s: array [1..n], t: array [1..m]) {\nDTW := array [0..n, 0..m]\nfor i := 0 to n\nfor j := 0 to m\nDTW[i, j] := infinity\nDTW[0, 0] := 0\nfor i := 1 to n\nfor j := 1 to m\ncost := d(s[i], t[j])\nDTW[i, j] := cost + minimum(DTW[i-1, j  ],    // insertion\nDTW[i  , j-1],    // deletion\nDTW[i-1, j-1])    // match\nreturn DTW[n, m]\n}\nwhere DTW[i, j] is the distance between s[1:i] and t[1:j] with the best alignment.\nWe sometimes want to add a locality constraint. That is, we require that if s[i] is matched with t[j], then | i - j | is no larger than w, a window parameter.\nWe can easily modify the above algorithm to add a locality constraint (differences marked).\nHowever, the above given modification works only if | n - m | is no larger than w, i.e. the end point is within the window length from diagonal. In order to make the algorithm work, the window parameter w must be adapted so that | n - m | \\le w (see the line marked with (*) in the code).\nint DTWDistance(s: array [1..n], t: array [1..m], w: int) {\nDTW := array [0..n, 0..m]\nw := max(w, abs(n-m)) // adapt window size (*)\nfor i := 0 to n\nfor j:= 0 to m\nDTW[i, j] := infinity\nDTW[0, 0] := 0\nfor i := 1 to n\nfor j := max(1, i-w) to min(m, i+w)\nDTW[i, j] := 0\nfor i := 1 to n\nfor j := max(1, i-w) to min(m, i+w)\ncost := d(s[i], t[j])\nDTW[i, j] := cost + minimum(DTW[i-1, j  ],    // insertion\nDTW[i  , j-1],    // deletion\nDTW[i-1, j-1])    // match\nreturn DTW[n, m]\n}\nWarping properties\nThe DTW algorithm produces a discrete matching between existing elements of one series to another. In other words, it does not allow time-scaling of segments within the sequence. Other methods allow continuous warping. For example, Correlation Optimized Warping (COW) divides the sequence into uniform segments that are scaled in time using linear interpolation, to produce the best matching warping. The segment scaling causes potential creation of new elements, by time-scaling segments either down or up, and thus produces a more sensitive warping than DTW's discrete matching of raw elements.\nComplexity\nThe time complexity of the DTW algorithm is O(NM), where N and M are the lengths of the two input sequences. The 50 years old quadratic time bound was broken in 2016: an algorithm due to Gold and Sharir enables computing DTW in O({N^2}/\\log \\log N) time and space for two input sequences of length N.\nThis algorithm can also be adapted to sequences of different lengths. Despite this improvement, it was shown that a strongly subquadratic running time of the form O(N^{2-\\epsilon}) for some \\epsilon > 0 cannot exist unless the Strong exponential time hypothesis fails.\nWhile the dynamic programming algorithm for DTW requires O(NM) space in a naive implementation, the space consumption can be reduced to O(\\min(N,M)) using Hirschberg's algorithm.\nFast computation\nFast techniques for computing DTW include PrunedDTW, SparseDTW, FastDTW, and the MultiscaleDTW.\nA common task, retrieval of similar time series, can be accelerated by using lower bounds such as LB_Keogh, LB_Improved, or LB_Petitjean. However, the Early Abandon and Pruned DTW algorithm reduces the degree of acceleration that lower bounding provides and sometimes renders it ineffective.\nIn a survey, Wang et al. reported slightly better results with the LB_Improved lower bound than the LB_Keogh bound, and found that other techniques were inefficient. Subsequent to this survey, the LB_Enhanced bound was developed that is always tighter than LB_Keogh while also being more efficient to compute.  LB_Petitjean is the tightest known lower bound that can be computed in linear time.\nAverage sequence\nAveraging for dynamic time warping is the problem of finding an average sequence for a set of sequences.\nNLAAF is an exact method to average two sequences using DTW.\nFor more than two sequences, the problem is related to that of multiple alignment and requires heuristics.\nDBA is currently a reference method to average a set of sequences consistently with DTW.\nCOMASA efficiently randomizes the search for the average sequence, using DBA as a local optimization process.\nSupervised learning\nA nearest-neighbour classifier can achieve state-of-the-art performance when using dynamic time warping as a distance measure.\nAmerced Dynamic Time Warping\nAmerced Dynamic Time Warping (ADTW) is a variant of DTW designed to better control DTW's permissiveness in the alignments that it allows. The windows that classical DTW uses to constrain alignments introduce a step function. Any warping of the path is allowed within the window and none beyond it. In contrast, ADTW employs an additive penalty that is incurred each time that the path is warped. Any amount of warping is allowed, but each warping action incurs a direct penalty. ADTW significantly outperforms DTW with windowing when applied as a nearest neighbor classifier on a set of benchmark time series classification tasks.\nAlternative approaches\nIn functional data analysis, time series are regarded as discretizations of smooth (differentiable) functions of time. By viewing the observed samples at smooth functions, one can utilize continuous mathematics for analyzing data. Smoothness and monotonicity of time warp functions may be obtained for instance by integrating a time-varying radial basis function, thus being a one-dimensional diffeomorphism. Optimal nonlinear time warping functions are computed by minimizing a measure of distance of the set of functions to their warped average. Roughness penalty terms for the warping functions may be added, e.g., by constraining the size of their curvature. The resultant warping functions are smooth, which facilitates further processing. This approach has been successfully applied to analyze patterns and variability of speech movements.\nAnother related approach are hidden Markov models (HMM) and it has been shown that the Viterbi algorithm used to search for the most likely path through the HMM is equivalent to stochastic DTW.\nDTW and related warping methods are typically used as pre- or post-processing steps in data analyses. If the observed sequences contain both random variation in both their values, shape of observed sequences and random temporal misalignment, the warping may overfit to noise leading to biased results. A simultaneous model formulation with random variation in both values (vertical) and time-parametrization (horizontal) is an example of a nonlinear mixed-effects model. In human movement analysis, simultaneous nonlinear mixed-effects modeling has been shown to produce superior results compared to DTW.\nOpen-source software\n* The [https://github.com/MonashTS/tempo tempo] C++ library with Python bindings implements Early Abandoned and Pruned DTW as well as Early Abandoned and Pruned ADTW and DTW lower bounds LB_Keogh, LB_Enhanced and LB_Webb.\n* The [https://github.com/ChangWeiTan/UltraFastWWS UltraFastMPSearch] Java library implements the UltraFastWWSearch algorithm for fast warping window tuning.\n* The [https://github.com/lemire/lbimproved lbimproved] C++ library implements Fast Nearest-Neighbor Retrieval algorithms under the GNU General Public License (GPL). It also provides a C++ implementation of dynamic time warping, as well as various lower bounds.\n* The [https://github.com/rmaestre/FastDTW FastDTW] library is a Java implementation of DTW and a FastDTW implementation that provides optimal or near-optimal alignments with an O(N) time and memory complexity, in contrast to the O(N2) requirement for the standard DTW algorithm. FastDTW uses a multilevel approach that recursively projects a solution from a coarser resolution and refines the projected solution.\n* [https://mvnrepository.com/artifact/com.github.davidmoten/fastdtw FastDTW fork] (Java) published to Maven Central.\n* [https://github.com/cesarsotovalero/time-series-classification time-series-classification] (Java) a package for time series classification using DTW in Weka.\n* The [https://dynamictimewarping.github.io/ DTW suite] provides Python ([https://pypi.org/project/dtw-python/ dtw-python]) and R packages ([https://cran.r-project.org/package=dtw dtw]) with a comprehensive coverage of the DTW algorithm family members, including a variety of recursion rules (also called step patterns), constraints, and substring matching.\n* The mlpy Python library implements DTW.\n* The [https://pypi.python.org/pypi/pydtw pydtw] Python library implements the Manhattan and Euclidean flavoured DTW measures including the LB_Keogh lower bounds.\n* The [https://gravitino.github.io/cudadtw/ cudadtw] C++/CUDA library implements subsequence alignment of Euclidean-flavoured DTW and z-normalized Euclidean distance similar to the popular UCR-Suite on CUDA-enabled accelerators.\n* The [https://java-ml.sourceforge.net/ JavaML] machine learning library implements [https://sourceforge.net/p/java-ml/java-ml-code/ci/9f6726deab4e55b7617478bc51e29c20308bffb9/tree/net/sf/javaml/distance/dtw/FastDTW.java DTW].\n* The [https://github.com/doblak/ndtw ndtw] C# library implements DTW with various options.\n* [https://github.com/kirel/sketch-a-char Sketch-a-Char] uses Greedy DTW (implemented in JavaScript) as part of LaTeX symbol classifier program.\n* The [https://github.com/hfink/matchbox MatchBox] implements DTW to match mel-frequency cepstral coefficients of audio signals.\n* [https://github.com/fpetitjean/DBA Sequence averaging]: a GPL Java implementation of DBA.\n* The [https://github.com/nickgillian/grt/wiki Gesture Recognition Toolkit|GRT] C++ real-time gesture-recognition toolkit implements DTW.\n* The [http://biointelligence.hu/pyhubs/ PyHubs] software package implements DTW and nearest-neighbour classifiers, as well as their extensions (hubness-aware classifiers).\n* The [https://github.com/talcs/simpledtw simpledtw] Python library implements the classic O(NM) Dynamic Programming algorithm and bases on Numpy. It supports values of any dimension, as well as using custom norm functions for the distances. It is licensed under the MIT license.\n* The [https://tslearn.readthedocs.io/en/latest/# tslearn] Python library implements DTW in the time-series context.\n*The [https://github.com/garrettwrong/cuTWED cuTWED] CUDA Python library implements a state of the art improved Time Warp Edit Distance using only linear memory with phenomenal speedups.\n* [https://github.com/baggepinnen/DynamicAxisWarping.jl DynamicAxisWarping.jl] Is a Julia implementation of DTW and related algorithms such as FastDTW, SoftDTW, GeneralDTW and DTW barycenters.\n* The [https://github.com/kaen2891/Multi_DTW/ Multi_DTW] implements DTW to match two 1-D arrays or 2-D speech files (2-D array).\n* The [https://pypi.org/project/dtwParallel/ dtwParallel] (Python) package incorporates the main functionalities available in current DTW libraries and novel functionalities such as parallelization, computation of similarity (kernel-based) values, and consideration of data with different types of features (categorical, real-valued, etc.).\nApplications\nSpoken-word recognition\nDue to different speaking rates, a non-linear fluctuation occurs in speech pattern versus time axis, which needs to be eliminated. DP matching is a pattern-matching algorithm based on dynamic programming (DP), which uses a time-normalization effect, where the fluctuations in the time axis are modeled using a non-linear time-warping function. Considering any two speech patterns, we can get rid of their timing differences by warping the time axis of one so that the maximal coincidence is attained with the other. Moreover, if the warping function is allowed to take any possible value,  distinction can be made between words belonging to different categories. So, to enhance the distinction between words belonging to different categories, restrictions were imposed on the warping function slope.\nCorrelation power analysis\nUnstable clocks are used to defeat naive power analysis. Several techniques are used to counter this defense, one of which is dynamic time warping.\nFinance and econometrics\nDynamic time warping is used in finance and econometrics to assess the quality of the prediction versus real-world data.\nSee also\n* Levenshtein distance\n* Elastic matching\n* Sequence alignment\n* Multiple sequence alignment\n* Wagner–Fischer algorithm\n* Needleman–Wunsch algorithm\n* Fréchet distance\n* Nonlinear mixed-effects model\nReferences\nFurther reading\n* Pavel Senin, [https://csdl.ics.hawaii.edu/techreports/2008/08-04/08-04.pdf Dynamic Time Warping Algorithm Review]\n*\n*\n*\n*\n*\n*"
    }
  ]
}