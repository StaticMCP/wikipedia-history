{
  "content": [
    {
      "type": "text",
      "text": "# Non-blocking I/O (Java)\n\njava.nio (NIO stands for New Input/Output) is a collection of Java programming language APIs that offer features for intensive I/O operations. It was introduced with the J2SE 1.4 release of Java by Sun Microsystems to complement an existing standard I/O.  NIO was developed under the Java Community Process as JSR 51. An extension to NIO that offers a new file system API, called NIO.2, was released with Java SE 7 (\"Dolphin\").\nFeatures and organization\nThe APIs of NIO were designed to provide access to the low-level I/O operations of modern operating systems.  Although the APIs are themselves relatively high-level, the intent is to facilitate an implementation that can directly use the most efficient operations of the underlying platform.\nThe Java NIO APIs are provided in the  package and its subpackages. The documentation by Oracle identifies these features.\n* Buffers for data of primitive types\n* Character set encoders and decoders\n* A pattern-matching facility based on Perl-style regular expressions (in package )\n* Channels, a new primitive I/O abstraction\n* A file interface that supports locks and memory mapping of files up to Integer.MAX_VALUE bytes (2 GiB)\n* A multiplexed, non-blocking I/O facility for writing scalable servers\nNIO buffers\nNIO data transfer is based on buffers ( and related classes).  These classes represent a contiguous extent of memory, together with a small number of data transfer operations.  Although theoretically these are general-purpose data structures, the implementation may select memory for alignment or paging characteristics, which are not otherwise accessible in Java.  Typically, this would be used to allow the buffer contents to occupy the same physical memory used by the underlying operating system for its native I/O operations, thus allowing the most direct transfer mechanism, and eliminating the need for any additional copying.  In most operating systems, provided the particular area of memory has the right properties, transfer can take place without using the CPU at all.  The NIO buffer is intentionally limited in features in order to support these goals.\nThere are buffer classes for all of Java's primitive types except boolean, which can share memory with byte buffers and allow arbitrary interpretation of the underlying bytes.\nUsage\nNIO buffers maintain several pointers that dictate the function of their accessor methods. The NIO buffer implementation contains a rich set of methods for modifying these pointers:\n* The flip() method, rather than performing a \"flip\" or paging function in the canonical sense, moves the position pointer to the origin of the underlying array (if any) and the limit pointer to the former position of the position pointer.\n* Three get() methods are supplied for transferring data out of a NIO buffer. The bulk implementation, rather than performing a \"get\" in the traditional sense, \"puts\" the data into a specified array. The \"offset\" argument supplied to this method refers not to the offset from within the buffer from which to read, nor an offset from the position pointer, but rather the offset from 0 within the target array.\n* Unless using the absolute get() and put() methods, any get() or put() is conducted from the position pointer. Should one need to read from a different position within the underlying array, whilst not adjusting the writing position, the mark() and reset() methods have been supplied.\n* The mark() method effectively stores the position of the position pointer by setting the mark pointer to the position of the position pointer. The reset() method causes the position pointer to move to the mark pointer's position.\n* Upon invocation of the clear() method or the flip() method the mark pointer is discarded.\n* The clear() method does not ensure zero-ing of the buffer, but does return the limit pointer to the upper boundary of the underlying array, and the position pointer to zero.\n* put() and get() operations for NIO buffers are not thread safe.\n* You can only map() a  from a  up to Integer.MAX_VALUE in size (2GiB); regions beyond this limit can be accessed using an offset greater than zero.\nChannels\nChannels (classes implementing the interface ) are designed to provide for bulk data transfers to and from NIO buffers.  This is a low-level data transfer mechanism that exists in parallel with the classes of the higher-level I/O library (packages  and ).  A channel implementation can be obtained from a high-level data transfer class such as , , or , and vice versa. Channels are analogous to \"file descriptors\" found in Unix-like operating systems.\nFile channels () can use arbitrary buffers but can also establish a buffer directly mapped to file contents using memory-mapped file.  They  can also interact with file system locks. Similarly, socket channels ( and ) allow for data transfer between sockets and NIO buffers.\nFileChannel can be used to do a file copy, which is potentially far more efficient than using old read/write with a byte array. The typical code for this is:\n// Getting file channels\ntry(FileChannel in = FileChannel.open(source, StandardOpenOption.READ);\nFileChannel out = FileChannel.open(target, StandardOpenOption.WRITE)) {\n// JavaVM does its best to do this as native I/O operations.\nin.transferTo(0, in.size(), out);\n}\nSelectors\nA selector ( and subclasses) provides a mechanism for waiting on channels and recognizing when one or more become available for data transfer.  When a number of channels are registered with the selector, it enables blocking of the program flow until at least one channel is ready for use, or until an interruption condition occurs.\nAlthough this multiplexing behavior could be implemented with threads, the selector can provide a significantly more efficient implementation using lower-level operating system constructs.  A POSIX-compliant operating system, for example, would have direct representations of these concepts, select().  A notable application of this design would be the common paradigm in server software which involves simultaneously waiting for responses on a number of sessions.\nCharacter sets\nIn Java, a character set is a mapping between Unicode characters (or a subset of them) and bytes.\nThe  package of NIO provides facilities for identifying character sets and providing encoding and decoding algorithms for new mappings.\nReception\nIt is unexpected that a Channel associated with a Java IO RandomAccess file closes the file descriptor on an interrupt, whereas RandomAccessFiles' associated FileChannel does do this.\nJDK 7 and NIO.2\nJDK 7 includes a  package which, with the  class (also new to JDK 7), among other features, provides extended capabilities for filesystem tasks, e.g. can work with symbolic/hard links and dump big directory listings into buffers more quickly than the old File class does.\nThe  package and its related package, , provide comprehensive support for file I/O and for accessing the file system. A zip file system provider is also available in JDK 7.\nThe java.nio.file.LinkOption is an example of emulating extensible enums with interfaces. In Java, it is not possible to have one Enum extend another Enum. However, it is possible to emulate an extensible Enum type by having an Enum implement one or more interfaces. LinkOption is an enum type that implements both the OpenOption and CopyOption interfaces, which emulates the effects of an extensible Enum type. A small down-side to this approach is that implementations cannot be inherited between various Enum types.\nCitations\nReferences\n*\nExternal links\n*\n* [http://docs.oracle.com/javase/1.5.0/docs/guide/nio/index.html JDK 5.0 New I/O-related APIs & Developer Guides] - description of New I/O by Oracle Corporation\n* [http://www.concretepage.com/java/jdk7/ Learn Java SE 7 | NIO 2 Features]\n* [http://www.jcp.org/en/jsr/detail?id=51 JSR 51] (NIO)\n* [http://www.jcp.org/en/jsr/detail?id=203 JSR 203] (NIO.2)\n* [http://today.java.net/pub/a/today/2007/02/13/architecture-of-highly-scalable-nio-server.html Architecture of a Highly Scalable NIO-Based Server] - discussion on Java NIO and patterns of usage\n* [http://tutorials.jenkov.com/java-nio/index.html Java NIO tutorial]\n* [https://rox-xmlrpc.sourceforge.net/niotut/index.html The Rox Java NIO Tutorial]\n* [http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf Scalable IO in Java (PDF) ]"
    }
  ]
}