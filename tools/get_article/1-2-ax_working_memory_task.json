{
  "content": [
    {
      "type": "text",
      "text": "# 1-2-AX working memory task\n\n-->\n| ICD10           =\n| ICD9            =\n}}\nThe 1-2-AX working memory task is a cognitive test which requires working memory to be solved.\nIt can be used as a test case for learning algorithms to test their ability to remember some old data. This task can be used to demonstrate the working memory abilities of algorithms like PBWM or Long short-term memory.\nDescription\nThe input of the task is a sequence of the numbers/letters 1, 2, A, X, B and Y, and additional distracting instances of 3, C and Z which should be ignored. For each character of input in sequence, the subject must respond with left (L) or right (R).\nThe two target sequences that the subject is looking for are A-X and B-Y. When the subject encounters a 1 they must switch to looking for A-X, and when they encounter a 2 they must switch to looking for B-Y.\nWhile looking for A-X, if the subject encounters an X having seen an A previously (and similarly for a Y while looking for B-Y), and where that previous letter was not part of an earlier sequence, they respond R to mark the end of that sequence; their response to all other characters should be L.\nExamples\n{| class=\"wikitable\"\n|-\n! Input\n| 2 || 1 || A || A || X || X || Y || A || X\n|-\n! Output\n| L || L || L || L ||  || L || L || L ||\n|}\n{| class=\"wikitable\"\n|-\n! Input\n| 1 || 2 || A || B || X || Y || A || C || Z\n|-\n! Output\n| L || L || L || L || L ||  || L || L || L\n|}\nRequirements for algorithms\nTo solve this task, an algorithm must be able to both remember the last number 1 or 2 and the last letter A or B independently. We refer to this memory as the working memory. This memory must persist all other input. In addition, the algorithm must be able to strip out and ignore the letters C and Z.\nSolutions\nPseudocode\nFor traditional computer models, both requirements are easy to solve. Here is some Python code (kind of pseudocode but works) where the function next_output gets one single number/letter as input and returns either a letter or nothing. next_outputs is there for convenience to operate on a whole sequence.\nlast_num = \"\"\nlast_letter = \"\"\ndef next_output(next_input: str) -> str | None:\n\"\"\"\nArgs:\nnext_input: A string containing a single character.\nReturns:\nA string containing the letters \"L\", \"R\" or None.\nExample:\n>>> next_output(\"2\")\n'L'\n\"\"\"\nglobal last_num, last_letter\nif next_input in [\"1\", \"2\"]:\nlast_num = next_input\nlast_letter = \"\"\nreturn \"L\"\nelif next_input in [\"A\", \"B\"]:\nlast_letter = next_input\nreturn \"L\"\nelif next_input in [\"X\", \"Y\"]:\nseq = last_num + last_letter + next_input\nlast_letter = next_input\nif seq in [\"1AX\", \"2BY\"]:\nreturn \"R\"\nreturn \"L\"\nreturn None\ndef next_outputs(next_inputs: str) -> list[str]:\n\"\"\"\nArgs:\nnext_input: A string.\nReturns:\nA list of strings containing the letters \"L\" or \"R\".\nExample:\n>>> next_outputs(\"21AAXBYAX\")\n[\"L\", \"L\", \"L\", \"L\", \"R\", \"L\", \"L\", \"L\", \"R\"]\n\"\"\"\nreturn [next_output(c) for c in next_inputs]\nExample:\n>>> next_outputs(\"21AAXBYAX\")\n['L', 'L', 'L', 'L', 'R', 'L', 'L', 'L', 'R']\n>>> next_outputs(\"12CBZY\")\n['L', 'L', None, 'L', None, 'R']\nFinite-state machine\nSimilarly, this task can be solved in a straightforward way by a finite-state machine with 7 states (call them ---, 1--, 2--, 1A-, 2B-, 1AX, 2BY).\nNeural network\nThis task is much more difficult for neural networks. For simple feedforward neural networks, this task is not solvable because feedforward networks don't have any working memory. Including working memory into neural networks is a difficult task. There have been several approaches like PBWM or Long short-term memory which have working memory, both are able to solve it.\nReferences"
    }
  ]
}