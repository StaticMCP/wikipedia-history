{
  "content": [
    {
      "type": "text",
      "text": "# Hardware register\n\nIn digital electronics, a register is a group of memory cells that store a collection of bits and continuously output the stored data. It typically consists of a synchronized group of flip-flops in which each flip-flop stores and outputs one bit of the collection. The number of bits a register can store, known as its word size, is equal to the number of flip-flops it contains. It is volatile memory, meaning that the circuit will cease to retain its stored data upon loss of operating power. Registers are characterized in various ways, including by bit storage capacity (e.g., \"32-bit register\"), signal polarities, logic level and power supply voltages, and timing parameters.\nRegisters are a fundamental building block of digital systems. They are used in a diverse range of applications, including in central processing units (CPUs) for a variety of purposes; in digital counters and other state machines; in serial and parallel data communications; and in device interfaces for functions such as control and configuration, status reporting, and data buffering.\nSignals\nA register has a variety of input and output nets, which are the electrical conductors used to convey digital signals between the register and external circuitry.\nA register has inputs that receive the data to be stored, and outputs that emit the currently stored data. Its flip-flops share a common clock input which, upon relevant signal edges, causes the flip-flops to sample and store the input data. Typically, the flip-flops also share a common reset input, which is used to initialize the stored data.\nInput signals\n*Reset — initializes all flip-flops to known states, typically '0'. Depending on the register design, this may be synchronous or asynchronous. This is typically used to zero the flip-flops before starting clocked operation.\n*Clock — upon rising or falling signal edge (the active edge), causes the data presented on the data inputs to be stored in the register's flip-flops. In registers that have a synchronous reset input in which reset is asserted, a clock active edge will invoke a register reset in lieu of storing input data.\n*Data in — data to be stored upon clock active edge, one bit per flip-flop. For a register with n flip-flops, the data inputs are typically named D_{0} to D_{n-1}.\nOutput signals\n*Data out — currently stored data, one bit per flip-flop, continuously emitted, stable except when transitioning to new stored values. For a register with n flip-flops, these are typically designated Q_{0} to Q_{n-1}. Some registers provide both true and complementary data outputs. For example, the 74175 MSI integrated circuit has four flip flops, each with its true and complementary outputs bonded out to package pins.\nUnused signals\nUnused inputs are usually connected to fixed logic levels to prevent them from floating, which might cause unpredictable behavior or damage the register's circuitry.\nUnused outputs are typically left unconnected.\nData structure\nThe data stored in a register may represent any arbitrary binary data that fits into the register's storage capacity. In cases where the data represents a binary integer, the least to most significant data bits are typically associated with register inputs D_{0} to D_{n-1} and outputs Q_{0} to Q_{n-1} respectively, although this is not required.\nImplementation\nRegisters are implemented in various ways, including as stand-alone MSI integrated circuits, as integrated registers within ASICs and programmable processors, and as IP blocks in FPGAs. In the latter case, a register is typically instantiated by synthesizing it from a description written in VHDL, Verilog or some other hardware description language. For example, the following VHDL code describes a 32-bit register with load enable and asynchronous reset:\nentity reg32 is -- 32 bit register with load enable\nport (\nCLK   : in  std_logic;                     -- clock\nRESET : in  std_logic;                     -- async reset\nLD    : in  std_logic;                     -- load enable\nD     : in  std_logic_vector(31 downto 0); -- data inputs\nQ     : out std_logic_vector(31 downto 0)  -- stored data\n);\nend reg32;\narchitecture behavioral of reg32 is\nbegin\nprocess(CLK, RESET)\nbegin\nif RESET = '1' then.         -- if RESET asserted\nQ  '0');      --   zero stored data\nelsif rising_edge(CLK) then  -- else if CLK active edge\nif LD = '1' then           --   and loading is allowed\nQ\nIn stand-alone MSI integrated circuits, a register is implemented as a semiconductor die which is bonded and encapsulated in a semiconductor package.\nMoto MC74HCT374A die mit5x.jpg|Semiconductor die of an 8-bit register (Motorola MC74HCT374A)\nTI SN74S374N.jpg|Assembled 8-bit register in a plastic dual-in-line package (Texas Instruments SN74S374N)\nSignal visibility\nDepending on its implementation and purpose, a register's data inputs and outputs may all be public (accessible to external circuitry), or some data inputs or outputs (or both) may be designated for internal use only. An example of the latter is a serial-in serial-out shift register, which exposes only one data input and one data output to external circuitry.\nApplications\nIn many applications, combinational logic is used to control when and how new data is stored in a register. For example, registers are commonly endowed with a \"load enable\" function that employs logic gates, in conjunction with a load signal, to allow or inhibit new data to be stored. In a parallel-input shift register, logic gates are used to transfer each stored bit to an adjacent flip-flop, thus shifting the stored binary word by one bit position in a single clock cycle. In a synchronous binary counter, logic gates cause the stored value to step through a binary count sequence.\nIn bus-organized systems, multiplexers or tri-state buffers (or both) are used to route register outputs onto shared buses. Common examples of this include register files, peripheral interfaces and multiplexed address/data buses. To facilitate this, address decoders are often used to select one from among a group of registers to input data from, or send stored data to, a shared bus. For example, in computers, peripheral interface registers are often accessed in a fashion similar to random access memory (RAM), by using a memory or port address to select a particular register.\nLoad enable\nIn many applications, it is required to load (store new data in) a register only during specific clock cycles and to hold (retain currently stored data) during other clock cycles. This is facilitated by adding a \"load enable\" function to the register, which consists of logic gates and an associated control input — typically called clock enable (CE),  load enable or simply load (LD) — that allows or inhibits loading depending on its state.\nA simple way to implement this is to gate the register's clock input with the control signal, but this interferes with system timing because it introduces propagation delay into the clock's signal path. Instead, to avoid problematic clock skew, the control signal typically is used to manage signal routing to the register's data inputs via primitives such as those shown below.\nFile:D flip-flop with clock enable.jpg|In this primitive, load enable (LD) controls a 2-to-1 multiplexer which routes either the data input (D) or the current state (Q) to the flip-flop's D input, thus causing the memory cell to load or hold, respectively\nFile:JK flip-flop with clock enable.jpg|In this primitive, a JK flip-flop uses two gates to implement load enable. When LD is asserted, the flip-flop is set or cleared depending on D, thus effectively storing D. When LD is negated, the stored data remains unchanged.\nFile:N-bit register with clock enable.jpg|An n-bit register with load enable, constructed from n primitives\nAddressable registers\nIn bus-oriented systems it is common for registers to receive data from or send stored data to (or both) a shared bus. Widely used examples of this include register files and peripheral interface registers. To facilitate this, each register is assigned a unique binary number known as its address, which is used to select the register for read and write operations. The selection mechanism is often based on a 1-of-n binary decoder, which in this capacity is commonly referred to as an address decoder. A register that can be accessed and manipulated using a specific address is said to be an addressable register.\nTo simplify access and management, related registers are typically organized into groups in which each group is assigned a contiguous range of addresses. In general, it is not required for every address in the range to be assigned to a register, and a register may be assigned multiple addresses in the range.\nThe registers in a group typically share a data input bus for write operations, or a data output bus for read operations, or both. In the latter case, depending on the application, a register group may use separate buses for read and write operations or a single bus for both.\nWrite operation\nIn a write operation, a register is selected by sending its address to a binary decoder, which in turn enables the register to store new data. The register's data inputs are connected to and thus receive the data to be stored from a shared bus, as shown in the example circuit below.\nFile:Addressable register write.jpg|During a register write operation, write enable (WR) is asserted and the target register's address (ADDR) is sent to a binary decoder, which then asserts the register's load enable input (LD). Upon clock active edge, the selected register will store the word presented on the shared bus (DATA).\nRead operation\nThe process of reading an addressable register involves gating its output data onto a shared bus. Depending on the application, the gating mechanism may employ multiplexers or tri-state buffers, or both. The outputs of all registers in a group are accessible to the gating mechanism, thus allowing any register's output word to be sent to the bus. Some applications employ multiple instances of this mechanism to allow different registers (or a single register) to be concurrently gated onto multiple buses; each such instance is commonly called a read port.\n;Multiplexer gating\nIn multiplexer-based gating, a register is selected for a read operation by sending its address to a multiplexer. The multiplexer then routes the register's output word to the bus either directly, as shown below, or through a tri-state word buffer in cases where the bus may be driven by other signal sources.\nFile:Addressable register read mux 01.jpg|During a register read operation, the target register's address (ADDR) is sent to the word multiplexer, which responds by driving the register's stored data onto the shared bus (DATA).\n;Tri-state buffer gating\nIn tri-state buffer-based gating, a register is selected for a read operation by sending its address to a binary decoder, causing the decoder to assert its associated output signal. This signal is sent to a tri-state word buffer, which responds by gating the register's output data onto the bus.\nFile:Addressable register read tristate.jpg|During a register read operation, output enable (OE) is asserted and the target register's address (ADDR) is sent to a binary decoder. This causes the decoder to enable the associated tri-state word buffer, which in turn gates the register's stored data onto a shared bus (DATA).\nAtomic bit operations\nIn multitasking systems it is often necessary to set or clear select register bits while leaving others unchanged. This can be accomplished purely by software via a read-modify-write (RMW) sequence, but if the register is accessed by multiple processes or cores, the integrity of each RMW must be protected using mechanisms such as memory barriers, atomic instructions, and semaphores. The required protection is further complicated if the register can be modified by direct memory access (DMA) transfers.\nRMWs and their protection mechanisms can be avoided if the register directly supports atomic operations. Registers endowed with this capability inherently allow specified bits to be set or cleared without the risk of interference from DMA or other processes. This is typically implemented by adding logic to the input of each flip-flop such as in the example below:\nFile:Atomic register bit.jpg|In this circuit primitive, MODE is a two-bit binary value that selects the operation to be performed. In mode 0, D is unconditionally stored. In modes 1 to 3, Q is modified (set, cleared or complemented, respectively) when D is '1', or unchanged when D is '0'. LD is a master enable that allows or inhibits changes to Q.\nFile:N-bit atomic register.jpg|n-bit atomic register with load enable, constructed from n primitives\nIn the above circuits, any arbitrary combination of bits can be atomically modified. For example, in the case of a 16-bit register, to atomically set bits 8 and 10, external circuitry would assert LD='1', MODE='1' and D[15:0]=0x0500.\nThe MODE inputs may be driven by low order bits of an address bus, thus mapping each of the register's four operations to a unique address. Alternatively, MODE may driven by otherwise unused data bus bits, which allows the register to be mapped to a single address.\nComputers\nIn computers, typical uses of registers include:\n* The registers in a central processing unit (CPU), which are called processor registers\n* configuration and start-up of certain features, especially during initialization\n* buffer storage e.g. video memory for graphics cards\n* input/output (I/O) of different kinds\n* determining the source of an interrupt\n* peripheral status reporting such as whether a certain event has occurred, for example a modem status register or a line status register\nPeripherals\nRegisters are used in interfaces between software and peripherals. Software writes them to send information to the device, and reads them to receive information from the device.\nTo read or write a register in a \"peripheral unit\" (computer hardware outside the CPU), the processor executes a \"load\" or \"store\" instruction using the register's  memory-mapped I/O or port-mapped I/O address. Registers are accessed in words, but sometimes only use a few bits of the word.\nFrom a CPUs perspective, a register is either read/write, read-only or write-only. The latter is generally not preferred as it can make debugging difficult and prevent read-modify-write operations.\nThe software-accessible registers in standard integrated circuits typically are documented in their associated electronic component datasheets. Many such devices also have internal registers that are inaccessible to software, which are used for purposes such as state machines and pipelining.\nCommercial design tools simplify and automate memory-mapped register specification and code generation for hardware, firmware, hardware verification, testing and documentation. DITA SIDSC XML defines an XML format for memory-mapped registers.\nSee also\n* Register-transfer level (RTL)\nReferences\npt:Registro"
    }
  ]
}