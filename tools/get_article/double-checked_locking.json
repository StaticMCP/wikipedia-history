{
  "content": [
    {
      "type": "text",
      "text": "# Double-checked locking\n\nIn software engineering, double-checked locking (also known as \"double-checked locking optimization\") is a software design pattern used to reduce the overhead of acquiring a lock by testing the locking criterion (the \"lock hint\") before acquiring the lock.  Locking occurs only if the locking criterion check indicates that locking is required.\nThe original form of the pattern, appearing in Pattern Languages of Program Design 3, has data races, depending on the memory model in use, and it is hard to get right. Some consider it to be an anti-pattern. There are valid forms of the pattern, including the use of the  keyword in Java and explicit memory barriers in C++.\nThe pattern is typically used to reduce locking overhead when implementing \"lazy initialization\" in a multi-threaded environment, especially as part of the Singleton pattern. Lazy initialization avoids initializing a value until the first time it is accessed.\nMotivation and original pattern\nConsider, for example, this code segment in the Java programming language:\n// Single-threaded version\nclass Foo {\nprivate static Helper helper;\npublic Helper getHelper() {\nif (helper == null) {\nhelper = new Helper();\n}\nreturn helper;\n}\n// other functions and members...\n}\nThe problem is that this does not work when using multiple threads. A lock must be obtained in case two threads call getHelper() simultaneously. Otherwise, either they may both try to create the object at the same time, or one may wind up getting a reference to an incompletely initialized object.\nSynchronizing with a lock can fix this, as is shown in the following example:\n// Correct but possibly expensive multithreaded version\nclass Foo {\nprivate Helper helper;\npublic synchronized Helper getHelper() {\nif (helper == null) {\nhelper = new Helper();\n}\nreturn helper;\n}\n// other functions and members...\n}\nThis is correct and will most likely have sufficient performance. However, the first call to getHelper() will create the object and only the few threads trying to access it during that time need to be synchronized; after that all calls just get a reference to the member variable. Since synchronizing a method could in some extreme cases decrease performance by a factor of 100 or higher, the overhead of acquiring and releasing a lock every time this method is called seems unnecessary: once the initialization has been completed, acquiring and releasing the locks would appear unnecessary. Many programmers, including the authors of the double-checked locking design pattern, have attempted to optimize this situation in the following manner:\n# Check that the variable is initialized (without obtaining the lock). If it is initialized, return it immediately.\n# Obtain the lock.\n# Double-check whether the variable has already been initialized: if another thread acquired the lock first, it may have already done the initialization. If so, return the initialized variable.\n# Otherwise, initialize and return the variable.\n// Broken multithreaded version\n// original \"Double-Checked Locking\" idiom\nclass Foo {\nprivate Helper helper;\npublic Helper getHelper() {\nif (helper  null) {\nsynchronized (this) {\nif (helper  null) {\nhelper = new Helper();\n}\n}\n}\nreturn helper;\n}\n// other functions and members...\n}\nIntuitively, this algorithm is an efficient solution to the problem. But if the pattern is not written carefully, it will have a data race. For example, consider the following sequence of events:\n# Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.\n# Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a partially constructed object before A has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.\n# Thread B notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B (either because A has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.\nMost runtimes have memory barriers or other methods for managing memory visibility across execution units. Without a detailed understanding of the language's behavior in this area, the algorithm is difficult to implement correctly. One of the dangers of using double-checked locking is that even a naive implementation will appear to work most of the time: it is not easy to distinguish between a correct implementation of the technique and one that has subtle problems. Depending on the compiler, the interleaving of threads by the scheduler and the nature of other concurrent system activity, failures resulting from an incorrect implementation of double-checked locking may only occur intermittently. Reproducing the failures can be difficult.\nUsage in C++\nFor the singleton pattern, double-checked locking is not needed:\nSingleton& getInstance() {\nstatic Singleton s;\nreturn s;\n}\nC++11 and beyond also provide a built-in double-checked locking pattern in the form of std::once_flag and std::call_once:\nimport std;\nusing std::once_flag;\nusing std::optional;\nclass Singleton {\nprivate:\nSingleton() = default;\nstatic optional instance;\nstatic once_flag flag;\npublic:\nstatic Singleton* getInstance() {\nstd::call_once(\nSingleton::flag,\n[]() -> void { instance.emplace(Singleton()); }\n);\nreturn &instance;\n}\n};\nIf one truly wishes to use the double-checked idiom instead of the trivially working example above (for instance because Visual Studio before the 2015 release did not implement the C++11 standard's language about concurrent initialization quoted above  ), one needs to use acquire and release fences:\nimport std;\nusing std::atomic;\nusing std::lock_guard;\nusing std::mutex;\nclass Singleton {\nprivate:\nSingleton() = default;\nstatic atomic instance;\nstatic mutex m;\npublic:\nstatic Singleton* getInstance() {\nSingleton* p = instance.load(std::memory_order_acquire);\nif (!p) { // 1st check\nlock_guard lock(m);\np = instance.load(std::memory_order_relaxed);\nif (!p) { // 2nd (double) check\np = new Singleton();\ninstance.store(p, std::memory_order_release);\n}\n}\nreturn p;\n}\n~Singleton() {\n// cleanup logic\n}\n};\nUsage in POSIX\n[https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_once.html pthread_once()]\nmust be used\nto initialize library (or sub-module) code when its API does not have a dedicated initialization\nprocedure required to be called in single-threaded mode.\nUsage in Go\npackage main\nimport \"sync\"\nvar arrOnce sync.Once\nvar arr []int\n// getArr retrieves arr, lazily initializing on first call. Double-checked\n// locking is implemented with the sync.Once library function. The first\n// goroutine to win the race to call Do() will initialize the array, while\n// others will block until Do() has completed. After Do has run, only a\n// single atomic comparison will be required to get the array.\nfunc getArr() []int {\narrOnce.Do(func() {\narr = []int{0, 1, 2}\n})\nreturn arr\n}\nfunc main() {\n// thanks to double-checked locking, two goroutines attempting to getArr()\n// will not cause double-initialization\ngo getArr()\ngo getArr()\n}\nUsage in Java\nAs of J2SE 5.0, the volatile keyword is defined to create a memory barrier. This allows a solution that ensures that multiple threads handle the singleton instance correctly. This new idiom is described in [http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html] and [http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html].\n// Works with acquire/release semantics for volatile in Java 1.5 and later\n// Broken under Java 1.4 and earlier semantics for volatile\nclass Foo {\nprivate volatile Helper helper;\npublic Helper getHelper() {\nHelper localRef = helper;\nif (localRef == null) {\nsynchronized (this) {\nlocalRef = helper;\nif (localRef == null) {\nhelper = localRef = new Helper();\n}\n}\n}\nreturn localRef;\n}\n// other functions and members...\n}\nNote the local variable \"\", which seems unnecessary. The effect of this is that in cases where  is already initialized (i.e., most of the time), the volatile field is only accessed once (due to \"\" instead of \"\"), which can improve the method's overall performance by as much as 40 percent.\nJava 9 introduced the  class, which allows use of relaxed atomics to access fields, giving somewhat faster reads on machines with weak memory models, at the cost of more difficult mechanics and loss of sequential consistency (field accesses no longer participate in the synchronization order, the global order of accesses to volatile fields).\n// Works with acquire/release semantics for VarHandles introduced in Java 9\nclass Foo {\nprivate volatile Helper helper;\npublic Helper getHelper() {\nHelper localRef = getHelperAcquire();\nif (localRef == null) {\nsynchronized (this) {\nlocalRef = getHelperAcquire();\nif (localRef == null) {\nlocalRef = new Helper();\nsetHelperRelease(localRef);\n}\n}\n}\nreturn localRef;\n}\nprivate static final VarHandle HELPER;\nprivate Helper getHelperAcquire() {\nreturn (Helper) HELPER.getAcquire(this);\n}\nprivate void setHelperRelease(Helper value) {\nHELPER.setRelease(this, value);\n}\nstatic {\ntry {\nMethodHandles.Lookup lookup = MethodHandles.lookup();\nHELPER = lookup.findVarHandle(Foo.class, \"helper\", Helper.class);\n} catch (ReflectiveOperationException e) {\nthrow new ExceptionInInitializerError(e);\n}\n}\n// other functions and members...\n}\nIf the helper object is static (one per class loader), an alternative is the initialization-on-demand holder idiom (See Listing 16.6 from the previously cited text.)\n// Correct lazy initialization in Java\nclass Foo {\nprivate static class HelperHolder {\npublic static final Helper helper = new Helper();\n}\npublic static Helper getHelper() {\nreturn HelperHolder.helper;\n}\n}\nThis relies on the fact that nested classes are not loaded until they are referenced.\nSemantics of  field in Java 5 can be employed to safely publish the helper object without using :\npublic class FinalWrapper {\npublic final T value;\npublic FinalWrapper(T value) {\nthis.value = value;\n}\n}\npublic class Foo {\nprivate FinalWrapper helperWrapper;\npublic Helper getHelper() {\nFinalWrapper tempWrapper = helperWrapper;\nif (tempWrapper  null) {\nsynchronized (this) {\nif (helperWrapper  null) {\nhelperWrapper = new FinalWrapper(new Helper());\n}\ntempWrapper = helperWrapper;\n}\n}\nreturn tempWrapper.value;\n}\n}\nThe local variable  is required for correctness: simply using  for both null checks and the return statement could fail due to read reordering allowed under the Java Memory Model. Performance of this implementation is not necessarily better than the  implementation.\nUsage in C#\nIn .NET Framework 4.0, the Lazy&lt;T&gt; class was introduced, which internally uses double-checked locking by default (LazyThreadSafetyMode.ExecutionAndPublication mode) to store either the exception that was thrown during construction, or the result of the function that was passed to Lazy&lt;T&gt;:\npublic class MySingleton\n{\nprivate static readonly Lazy _mySingleton = new Lazy(() => new MySingleton());\nprivate MySingleton() { }\npublic static MySingleton Instance => _mySingleton.Value;\n}\nSee also\n* The Test and Test-and-set idiom for a low-level locking mechanism.\n* Initialization-on-demand holder idiom for a thread-safe replacement in Java.\nReferences\nExternal links\n* Issues with the double checked locking mechanism captured in [https://web.archive.org/web/20060620041255/http://purevirtuals.com/blog/2006/06/16/son-of-a-bug/ Jeu George's Blogs]\n* \"Double Checked Locking\" Description from the Portland Pattern Repository\n* \"Double Checked Locking is Broken\" Description from the Portland Pattern Repository\n* Paper \"[http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf C++ and the Perils of Double-Checked Locking]\" (475&nbsp;KB) by Scott Meyers and Andrei Alexandrescu\n* Article \"[https://www.infoworld.com/article/2074979/double-checked-locking--clever--but-broken.html Double-checked locking: Clever, but broken]\" by Brian Goetz\n* Article \"[https://www.infoworld.com/article/2074990/warning--threading-in-a-multiprocessor-world.html Warning! Threading in a multiprocessor world]\" by Allen Holub\n* [http://www.ibm.com/developerworks/java/library/j-dcl/index.html Double-checked locking and the Singleton pattern]\n* [https://web.archive.org/web/20060412081055/http://www.oaklib.org/docs/oak/singleton.html Singleton Pattern and Thread Safety]\n* [http://msdn2.microsoft.com/en-us/library/12a04hfd.aspx volatile keyword in VC++ 2005]\n* [https://web.archive.org/web/20120902131951/https://blogs.oracle.com/cwebster/entry/double_check_locking Java Examples and timing of double check locking solutions]\n*"
    }
  ]
}