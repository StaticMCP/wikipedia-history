{
  "content": [
    {
      "type": "text",
      "text": "# Security of the Java software platform\n\nThe Java software platform provides a number of features designed for improving the security of Java applications. This includes enforcing runtime constraints through the use of the Java Virtual Machine (JVM), a security manager that sandboxes untrusted code from the rest of the operating system, and a suite of security APIs that Java developers can utilise. Despite this, criticism has been directed at the programming language, and Oracle, due to an increase in malicious programs that revealed security vulnerabilities in the JVM, which were subsequently not properly addressed by Oracle in a timely manner.\nSecurity features\nThe JVM\nThe binary form of programs running on the Java platform is not native machine code but an intermediate bytecode. The JVM performs verification on this bytecode before running it to prevent the program from performing unsafe operations such as branching to incorrect locations, which may contain data rather than instructions. It also allows the JVM to enforce runtime constraints such as array bounds checking. This means that Java programs are significantly less likely to suffer from memory safety flaws such as buffer overflow than programs written in languages such as C which do not provide such memory safety guarantees.\nThe platform does not allow programs to perform certain potentially unsafe operations such as pointer arithmetic or unchecked type casts. It manages memory allocation and initialization and provides automatic garbage collection which in many cases (but not all) relieves the developer from manual memory management. This contributes to type safety and memory safety.\nSecurity manager\nThe platform provides a security manager which allows users to run untrusted bytecode in a \"sandboxed\" environment designed to protect them from malicious or poorly written software by preventing the untrusted code from accessing certain platform features and APIs. For example, untrusted code might be prevented from reading or writing files on the local filesystem, running arbitrary commands with the current user's privileges, accessing communication networks, accessing the internal private state of objects using reflection, or causing the JVM to exit.\nThe security manager also allows Java programs to be cryptographically signed; users can choose to allow code with a valid digital signature from a trusted entity to run with full privileges in circumstances where it would otherwise be untrusted.\nUsers can also set fine-grained access control policies for programs from different sources. For example, a user may decide that only system classes should be fully trusted, that code from certain trusted entities may be allowed to read certain specific files, and that all other code should be fully sandboxed.\nSecurity APIs\nThe Java Class Library provides a number of APIs related to security, such as standard cryptographic algorithms, authentication, and secure communication protocols.\nThe  class\nsun.misc.Unsafe is an internal utility class in the Java programming language which is a collection of low-level unsafe operations. While it is not a part of the official Java Class Library, it is called internally by the Java libraries. It resides in an unofficial Java module named jdk.unsupported. Beginning in Java 11, it has been partially migrated to jdk.internal.misc.Unsafe (which resides in module java.base).\nIts primary feature is to allow direct memory management (similar to C memory management) and memory address manipulation, manipulating objects and fields, thread manipulation, and concurrency primitives.\nIts declaration is: public final class Unsafe;, and it is a singleton class with a private constructor.\nIt contains the following methods, many of which are declared native (invoking Java Native Interface):\n* : retrieves the Unsafe instance. It uses sun.reflect.Reflection to do so.\n* : fetches a value (a field or array element) in the object at the given offset. (There are corresponding getBoolean(), getByte(), getShort(), getChar(), getLong(), getFloat(), and getDouble() methods as well.)\n* : stores a value into an object at the given offset. (There are corresponding putBoolean(), putByte(), putShort(), putChar(), putLong(), putFloat(), and putDouble() methods as well.)\n* : fetches a reference value from an object at the given offset.\n* : stores a reference value into an object at the given offset.\n* : fetches a value at the given address. (There are corresponding getBoolean(), getByte(), getShort(), getChar(), getLong(), getFloat(), and getDouble() methods as well.)\n* : stores a value into the given address. (There are corresponding putBoolean(), putByte(), putShort(), putChar(), putLong(), putFloat(), and putDouble() methods as well.)\n* : fetches a native pointer from a given address.\n* : stores a native pointer into a given address.\n* : allocates a block of native memory of the given size (similar to ).\n* : resizes a block of native memory to the given size (similar to ).\n* , : sets all bytes in a block of memory to a fixed value (similar to ).\n* , : sets all bytes in a given block of memory to a copy of another block (smilar to ).\n* : deallocates a block of native memory obtained from allocateMemory() or reallocateMemory(), similar to ).\n* : obtains the location of a given field in the storage allocation of its class.\n* : obtains the location of a given static field in conjunction with staticFieldBase().\n* : obtains the location of a given static field in conjunction with staticFieldOffset().\n* : ensures the given class has been initialized.\n* : obtains the offset of the first element in the storage allocation of a given array class.\n* : obtains the scale factor for addressing elements in the storage allocation of a given array class.\n* : obtains the size (in bytes) of a native pointer.\n* : obtains the size (in bytes) of a native memory page.\n* : signals to the JVM to define a class without security checks.\n* : signals to the JVM to define a class but do not make it known to the class loader or system directory.\n* : allocates an instance of a class without running its constructor.\n* : locks an object.\n* : unlocks an object.\n* : tries to lock an object, returning whether the lock succeeded.\n* : throws an exception without telling the verifier.\n* : updates a variable to x if it is holding expected, returning whether the operation succeeded. (There are corresponding compareAndSwapLong() and compareAndSwapObject() methods as well.)\n* : volatile version of getInt(). (There are corresponding getBooleanVolatile(), getByteVolatile(), getShortVolatile(), getCharVolatile(), getLongVolatile(), getFloatVolatile(), getDoubleVolatile(), and getObjectVolatile() methods as well.)\n* : volatile version of putInt(). (There are corresponding putBooleanVolatile(), putByteVolatile(), putShortVolatile(), putCharVolatile(), putLongVolatile(), putFloatVolatile(), putDoubleVolatile(), and putObjectVolatile() methods as well.)\n* : version of putIntVolatile() not guaranteeing immediate visibility of storage to other threads. (There are corresponding putOrderedLong() and putOrderedObject() methods as well.)\n* : unblocks a thread.\n* : blocks the current thread.\n* : gets the load average in the system run queue assigned to available processors averaged over various periods of time.\n* : invokes the given direct byte buffer's cleaner.\n* : ensures loads and stores before the fence will not be reordered with loads and stores after the fence.\n* : ensures loads before the fence will not be reordered with loads and stores after the fence.\n* : ensures loads and stores before the fence will not be reordered with stores after the fence.\nit also contains the following constants:\n*  -1}}\n*  arrayBaseOffset(boolean[].class)}}\n*  arrayBaseOffset(byte[].class)}}\n*  arrayBaseOffset(short[].class)}}\n*  arrayBaseOffset(char[].class)}}\n*  arrayBaseOffset(int[].class)}}\n*  arrayBaseOffset(long[].class)}}\n*  arrayBaseOffset(float[].class)}}\n*  arrayBaseOffset(double[].class)}}\n*  arrayBaseOffset(Object[].class)}}\n*  arrayIndexScale(boolean[].class)}}\n*  arrayIndexScale(byte[].class)}}\n*  arrayIndexScale(short[].class)}}\n*  arrayIndexScale(char[].class)}}\n*  arrayIndexScale(int[].class)}}\n*  arrayIndexScale(long[].class)}}\n*  arrayIndexScale(float[].class)}}\n*  arrayIndexScale(double[].class)}}\n*  arrayIndexScale(Object[].class)}}\n*  addressSize()}}\nExamples\nAn example usage the following:\npackage org.wikipedia.example;\nimport java.lang.reflect.Field;\nimport sun.misc.Unsafe;\npublic class Example {\npublic static void main(String[] args) throws Exception {\n// Get Unsafe instance via reflection\nField f = Unsafe.class.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nUnsafe unsafe = (Unsafe)f.get(null);\n// Allocate a block of 8 bytes\nlong memoryAddress = unsafe.allocateMemory(8L);\ntry {\n// Insert a long into the memory, and read from that block\nunsafe.putLong(memoryAddress, 123456789L);\nlong value = unsafe.getLong(memoryAddress);\nSystem.out.printf(\"Value from memory: %d%n\", value); // Output: 123456789\n} finally {\n// Free the allocated memory\nunsafe.freeMemory(memoryAddress);\n}\n}\n}\nOne can also wrap native memory segments, like java.lang.foreign.MemorySegment:\npackage org.wikipedia.example;\nimport java.lang.reflect.Field;\nimport sun.misc.Unsafe;\npublic class NativeMemory implements AutoCloseable {\nprivate static final Unsafe unsafe;\nprivate final long address;\nprivate final long size;\nstatic {\ntry {\nField theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\ntheUnsafe.setAccessible(true);\nunsafe = (Unsafe)theUnsafe.get(null);\n} catch (Exception e) {\nthrow new RuntimeException(\"Unable to access Unsafe\", e);\n}\n}\npublic NativeMemory(long size) {\nthis.size = size;\nthis.address = unsafe.allocateMemory(size);\n}\npublic void putByte(long offset, byte value) {\ncheckBounds(offset, 1);\nunsafe.putByte(address + offset, value);\n}\npublic byte getByte(long offset) {\ncheckBounds(offset, 1);\nreturn unsafe.getByte(address + offset);\n}\nprivate void checkBounds(long offset, long bytes) {\nif (offset  size) {\nthrow new IndexOutOfBoundsException(String.format(\"Offset out of bounds: %d\", offset));\n}\n}\n@Override\npublic void close() {\nunsafe.freeMemory(address);\n}\n}\nIn use:\npackage org.wikipedia.example;\npublic class Main {\npublic static void main(String[] args) {\ntry (NativeMemory mem = new NativeMemory(1024)) {\nmem.putByte(0, (byte)42);\nSystem.out.printf(\"Value: %s%n\", mem.getByte(0));\n}\n}\n}\nPotential sources of security vulnerabilities in Java applications\nThere are a number of possible sources of security vulnerabilities in Java applications, some of which are common to non-Java applications and some of which are specific to the Java platform. (Note that these refer to potential sources of vulnerabilities which need to be kept in mind by security-conscious programmers: this is not intended as a list of actual vulnerabilities.)\nExamples of potential sources of vulnerability common to Java and non-Java applications are:\n* Vulnerabilities in the protection mechanisms provided by the hardware or operating system which the application relies upon for its security\n* Vulnerabilities in native libraries, such as the C standard library, which may be used to implement the application and/or runtime\n* Vulnerabilities caused purely by errors in user programs (for example improper construction of SQL queries leading to SQL injection vulnerabilities)\nHowever, much discussion of Java security focusses on potential sources of vulnerability specific to the Java platform. These include:\n* Vulnerabilities in the sandboxing mechanism which allow untrusted bytecode to circumvent the restrictions imposed by the security manager\n* Vulnerabilities in the Java class library which an application relies upon for its security\nA vulnerability in the Java platform will not necessarily make all Java applications vulnerable. When vulnerabilities and patches are announced, for example by Oracle, the announcement will normally contain a breakdown of which types of application are affected ([https://blogs.oracle.com/security/entry/april_2013_critical_patch_update1 example]).\nFor example, a hypothetical security flaw which affects only the security manager sandboxing mechanism of a particular JVM implementation would mean that only Java applications which run arbitrary untrusted bytecode would be compromised: applications where the user fully trusts and controls all bytecode being executed would not. This would mean that, say, a web browser plugin based on that JVM would be vulnerable to malicious applets downloaded from public websites, but a server-side web application running on the same version of the JVM where the administrator has full control over the classpath would be unaffected.\nAs with non-Java applications, security vulnerabilities can stem from parts of the platform which may not initially appear to be security-related. For example, in 2011, Oracle issued a security fix for a bug in the  method. This method converts a string such as \"12.34\" into the equivalent double-precision floating point number. The bug caused this method to enter an infinite loop when called on a specific input. This bug had security implications, because for example if a web server converts a string typed into a form by the user using this method, a malicious user could type in the string which triggers the bug. This would cause the web server thread processing the malicious request to enter an infinite loop and become unavailable for serving requests from other users. Doing this repeatedly to a vulnerable web server would be an easy denial-of-service attack: all the web server's threads for responding to user requests would soon be stuck in the infinite loop and the web server would be unable to serve any legitimate users at all.\nCriticism of security manager\nThe security manager in the Java platform (which, as mentioned above, is designed to allow the user to safely run untrusted bytecode) has been criticized in recent years for making users vulnerable to malware, especially in web browser plugins which execute Java applets downloaded from public websites, more informally known as \"Java in the browser\".\nOracle's efforts to address these vulnerabilities resulted in a delay to the release of Java 8.\n2012\nAn OS X trojan referred to as Flashback exploited a vulnerability in Java, which had not been patched by Apple, although Oracle had already released a patch. In April, Apple later released a removal tool for Lion users without Java. With Java 7 Update 4, Oracle began to release Java directly for Lion and later.\nIn October, Apple released an update that removed the Java plugin from all browsers. This was seen as a move by Apple to distance OS X from Java.\n2013\nIn January, a zero-day vulnerability was found in all versions of Java 7, including the latest version Java 7 Update 10, which was already exploited in the wild. The vulnerability was caused by a patch to fix an earlier vulnerability. In response, Apple blacklisted the latest version of the Java plugin. Oracle released a patch (Update 11) within three days. Microsoft also released a patch for Internet Explorer versions 6, 7, and 8.\nCyberespionage malware Red October was found exploiting a Java vulnerability that was patched in October 2011. The website for Reporters Without Borders was also compromised by a Java vulnerability in versions prior to Update 11.\nAfter the release of Update 11, another vulnerability began circulating online, which was later confirmed. It was also found that Java's security mode itself was vulnerable due to a bug. In response, Mozilla disabled Java (as well as Adobe Reader and Microsoft Silverlight) in Firefox by default, while Apple blacklisted the latest Java plugin again.\nIn February, Twitter reported that it had shut down an attack. Twitter advised users to disable Java, although it did not explain why. Later in the month, Facebook reported that it had been hacked by a zero-day Java attack. Apple also reported an attack. It was found that a breach of an iPhone developer forum was used to attack Twitter, Facebook, and Apple. The forum itself was unaware of the breach. Following Twitter, Facebook, and Apple, Microsoft reported that it was also similarly compromised.\nAnother vulnerability discovered allowed for the Java security sandbox to be completely bypassed in the original release of Java 7, as well as Updates 11 and 15. In March, trojan called McRat was found exploiting a zero-day Java vulnerability. Oracle then released another patch to address the vulnerability.\nSee also\n*Criticism of Java\nReferences\nExternal links\n* [http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html Java SE Security]. Oracle Corporation. Downloaded 2013-04-24.\n* [http://www.oracle.com/technetwork/java/seccodeguide-139067.html Secure Coding Guidelines for the Java Programming Language]. Oracle Corporation. Downloaded 2013-04-24.\n* [http://www.gnudeveloper.com/cyber_security/web_application_security_manager.html  How Security manager helps in Run with least privilege principle ]."
    }
  ]
}