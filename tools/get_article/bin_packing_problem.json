{
  "content": [
    {
      "type": "text",
      "text": "# Bin packing problem\n\nThe bin packing problem is an optimization problem, in which items of different sizes must be packed into a finite number of bins or containers, each of a fixed given capacity, in a way that minimizes the number of bins used. The problem has many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file backups in media, splitting a network prefix into multiple subnets, and technology mapping in FPGA semiconductor chip design.\nComputationally, the problem is NP-hard, and the corresponding decision problem, deciding if items can fit into a specified number of bins, is NP-complete. Despite its worst-case hardness, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many approximation algorithms exist. For example, the first fit algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires Θ(n&nbsp;log&nbsp;n) time, where n is the number of items to be packed. The algorithm can be made much more effective by first sorting the list of items into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.\nThere are many variations of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. The bin packing problem can also be seen as a special case of the cutting stock problem. When the number of bins is restricted to 1 and each item is characterized by both a volume and a value, the problem of maximizing the value of items that can fit in the bin is known as the knapsack problem.\nA variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically,  a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing since when virtual machines (VMs) are packed in a server, their total memory requirement could decrease due to pages shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.\nAnother variant of bin packing of interest in practice is the so-called online bin packing. Here the items of different volume are supposed to arrive sequentially, and the decision maker has to decide whether to select and pack the currently observed item, or else to let it pass. Each decision is without recall. In contrast, offline bin packing allows rearranging the items in the hope of achieving a better packing once additional items arrive. This of course requires additional storage for holding the items to be rearranged.\nFormal statement\nIn Computers and Intractability Garey and Johnson list the bin packing problem under the reference [SR1]. They define its decision variant as follows.\nInstance: Finite set I of items, a size s(i) \\in \\mathbb{Z}^+ for each i \\in I, a positive integer bin capacity B, and a positive integer K.\nQuestion: Is there a partition of I into disjoint sets I_1,\\dots, I_K such that the sum of the sizes of the items in each I_j is B or less?\nNote that in the literature often an alternate, but not equivalent, notation is used, where B = 1 and s(i) \\in \\mathbb{Q} \\cap (0,1] for each i \\in I. Furthermore, research is mostly interested in the optimization variant, which asks for the smallest possible value of K. A solution is optimal if it has minimal K. The K-value for an optimal solution for a set of items I is denoted by \\mathrm{OPT}(I) or just \\mathrm{OPT} if the set of items is clear from the context.\nA possible integer linear programming formulation of the problem is:\n{|\n| colspan=\"2\" |minimize  K = \\sum_{j=1}^n y_j\n|\n|-\n|subject to\n|K \\geq 1,\n|-\n|\n|\\sum_{i \\in I} s(i) x_{ij} \\leq B y_j,\n|\\forall j \\in \\{1,\\ldots,n\\}\n|-\n|\n|\\sum_{j=1}^n x_{ij} = 1,\n|\\forall i \\in I\n|-\n|\n| y_j \\in \\{0,1\\},\n|\\forall j \\in \\{1,\\ldots,n\\}\n|-\n|\n| x_{ij} \\in \\{0,1\\},\n|\\forall i \\in I \\, \\forall j \\in \\{1,\\ldots,n\\}\n|}\nwhere  y_j = 1 if bin j is used and  x_{ij} = 1 if item i is put into bin j.\nHardness of bin packing\nThe bin packing problem is strongly NP-complete. This can be proven by reducing the strongly NP-complete 3-partition problem to bin packing.\nFurthermore, there can be no approximation algorithm with absolute approximation ratio smaller than \\tfrac 3 2 unless \\mathsf{P} = \\mathsf{NP}. This can be proven by a reduction from the partition problem: given an instance of Partition where the sum of all input numbers is 2T,  construct an instance of bin-packing in which the bin size is . If there exists an equal partition of the inputs, then the optimal packing needs 2 bins; therefore, every algorithm with an approximation ratio smaller than  must return less than 3 bins, which must be 2 bins. In contrast, if there is no equal partition of the inputs, then the optimal packing needs at least 3 bins.\nOn the other hand, bin packing is solvable in pseudo-polynomial time for any fixed number of bins , and solvable in polynomial time for any fixed bin capacity .\nApproximation algorithms for bin packing\nTo measure the performance of an approximation algorithm there are two approximation ratios considered in the literature. For a given list of items L the number A(L) denotes the number of bins used when algorithm A is applied to list L, while \\mathrm{OPT}(L) denotes the optimum number for this list. The absolute worst-case performance ratio R_A for an algorithm A is defined as\n: R_A \\equiv \\inf\\{r \\geq 1 : A(L)/\\mathrm{OPT}(L) \\leq r \\text{ for all lists } L\\}.\nOn the other hand, the asymptotic worst-case ratio R_A^{\\infty} is defined as\n: R_A^\\infty \\equiv \\inf\\{ r \\geq 1: \\exists N >0,  A(L)/\\mathrm{OPT}(L) \\leq r \\text{ for all lists } L \\text{ with } \\mathrm{OPT}(L) \\geq N\\}.\nEquivalently, R_A^{\\infty} is the smallest number such that there exists some constant K, such that for all lists L:\n: A(L) \\leq R^{\\infty}_A \\cdot \\mathrm{OPT}(L) + K.\nAdditionally, one can restrict the lists to those for which all items have a size of at most \\alpha.  For such lists, the bounded size performance ratios are denoted as R_A(\\text{size}\\leq \\alpha) and R_A^\\infty(\\text{size}\\leq \\alpha).\nApproximation algorithms for bin packing can be classified into two categories:\n# Online heuristics, that consider the items in a given order and place them one by one inside the bins.  These heuristics are also applicable to the offline version of this problem.\n# Offline heuristics, that modify the given list of items e.g. by sorting the items by size. These algorithms are no longer applicable to the online variant of this problem. However, they have an improved approximation guarantee while maintaining the advantage of their small time-complexity. A sub-category of offline heuristics is asymptotic approximation schemes. These algorithms have an approximation guarantee of the form (1+\\varepsilon)\\mathrm{OPT}(L) + C for some constant that may depend on 1/\\varepsilon. For an arbitrarily large \\mathrm{OPT}(L) these algorithms get arbitrarily close to \\mathrm{OPT}(L). However, this comes at the cost of a (drastically) increased time complexity compared to the heuristical approaches.\nOnline heuristics\nIn the online version of the bin packing problem, the items arrive one after another and the (irreversible) decision where to place an item has to be made before knowing the next item or even if there will be another one. A diverse set of offline and online heuristics for bin-packing have been studied by David S. Johnson on his Ph.D. thesis.\nSingle-class algorithms\nThere are many simple algorithms that use the following general scheme:\n* For each item in the input list:\n*# If the item fits into one of the currently open bins, then put it in one of these bins;\n*# Otherwise, open a new bin and put the new item in it.\nThe algorithms differ in the criterion by which they choose the open bin for the new item in step 1 (see the linked pages for more information):\n* Next Fit (NF) always keeps a single open bin. When the new item does not fit into it, it closes the current bin and opens a new bin. Its advantage is that it is a bounded-space algorithm since it only needs to keep a single open bin in memory. Its disadvantage is that its asymptotic approximation ratio is 2. In particular, NF(L) \\leq 2 \\cdot \\mathrm{OPT}(L) -1 , and for each N \\in \\mathbb{N} there exists a list  such that \\mathrm{OPT}(L) = N and NF(L) = 2 \\cdot \\mathrm{OPT}(L) -2. Its asymptotic approximation ratio can be somewhat improved based on the item sizes: R_{NF}^\\infty(\\text{size}\\leq\\alpha) \\leq 2 for all \\alpha \\geq 1/2 and R_{NF}^\\infty(\\text{size}\\leq\\alpha) \\leq 1/(1-\\alpha) for all \\alpha \\leq 1/2. For each algorithm  that is an AnyFit-algorithm it holds that R_{A}^{\\infty}(\\text{size}\\leq\\alpha)\\leq R_{NF}^{\\infty}(\\text{size}\\leq\\alpha).\n* Next-k-Fit (NkF) is a variant of Next-Fit, but instead of keeping only one bin open, the algorithm keeps the last  bins open and chooses the first bin in which the item fits. Therefore, it is called a k-bounded space algorithm. For k\\geq 2 the NkF delivers results that are improved compared to the results of NF, however, increasing  to constant values larger than  improves the algorithm no further in its worst-case behavior.  If algorithm  is an AlmostAnyFit-algorithm and m = \\lfloor 1/\\alpha\\rfloor \\geq 2 then R_{A}^{\\infty}(\\text{size}\\leq\\alpha)\\leq R_{N2F}^{\\infty}(\\text{size}\\leq\\alpha) = 1+1/m.\n* First-Fit (FF) keeps all bins open, in the order in which they were opened. It attempts to place each new item into the first bin in which it fits. Its approximation ratio is FF(L) \\leq \\lfloor 1.7\\mathrm{OPT}\\rfloor, and there is a family of input lists  for which FF(L) matches this bound.\n* Best-Fit (BF), too, keeps all bins open, but attempts to place each new item into the bin with the maximum load in which it fits. Its approximation ratio is identical to that of FF, that is: BF(L) \\leq \\lfloor 1.7\\mathrm{OPT}\\rfloor, and there is a family of input lists  for which BF(L) matches this bound.\n*Worst-Fit (WF) attempts to place each new item into the bin with the minimum load. It can behave as badly as Next-Fit, and will do so on the worst-case list for that NF(L) = 2 \\cdot \\mathrm{OPT}(L) -2 . Furthermore, it holds that R_{WF}^{\\infty}(\\text{size}\\leq \\alpha) = R_{NF}^{\\infty}(\\text{size}\\leq \\alpha). Since WF is an AnyFit-algorithm, there exists an AnyFit-algorithm such that R_{AF}^{\\infty}(\\alpha) = R_{NF}^{\\infty}(\\alpha).\n* Almost Worst-Fit (AWF) attempts to place each new item inside the second most empty open bin (or emptiest bin if there are two such bins). If it does not fit, it tries the most empty one. It has an asymptotic worst-case ratio of \\tfrac {17}{10}.\nIn order to generalize these results, Johnson introduced two classes of online heuristics called any-fit algorithm and almost-any-fit algorithm:\n* In an AnyFit (AF) algorithm, if the current nonempty bins are B1,...,Bj, then the current item will not be packed into Bj+1 unless it does not fit in any of B1,...,Bj. The FF, WF, BF and AWF algorithms satisfy this condition. Johnson proved that, for any AnyFit algorithm A and any \\alpha:\n*:R_{FF}^{\\infty}(\\alpha) \\leq R_{A}^{\\infty}(\\alpha) \\leq R_{WF}^{\\infty}(\\alpha).\n* In an AlmostAnyFit (AAF) algorithm, if the current nonempty bins are B1,...,Bj, and of these bins, Bk is the unique bin with the smallest load, then the current item will not be packed into Bk, unless it does not fit into any of the bins to its left. The FF, BF and AWF algorithms satisfy this condition, but WF does not. Johnson proved that, for any AAF algorithm A and any :\n*:R_{A}^{\\infty}(\\alpha) = R_{FF}^{\\infty}(\\alpha)   In particular: R_{A}^{\\infty} = 1.7 .\nRefined algorithms\nBetter approximation ratios are possible with heuristics that are not AnyFit. These heuristics usually keep several classes of open bins, devoted to items of different size ranges (see the linked pages for more information):\n* Refined-first-fit bin packing (RFF) partitions the item sizes into four ranges: \\left(\\frac 1 2,1\\right], \\left(\\frac 2 5, \\frac 1 2\\right], \\left(\\frac 1 3, \\frac 2 5\\right], and \\left(0, \\frac 1 3\\right]. Similarly, the bins are categorized into four classes. The next item i \\in L is first assigned to its corresponding class. Inside that class, it is assigned to a bin using first-fit. Note that this algorithm is not an Any-Fit algorithm since it may open a new bin despite the fact that the current item fits inside an open bin. This algorithm was first presented by Andrew Chi-Chih Yao, who proved that it has an approximation guarantee of RFF(L) \\leq (5/3) \\cdot \\mathrm{OPT}(L) +5  and presented a family of lists L_k with RFF(L_k) = (5/3)\\mathrm{OPT}(L_k) +1/3 for \\mathrm{OPT}(L) = 6k+1.\n* Harmonic-k partitions the interval of sizes (0,1] based on a Harmonic progression into k-1 pieces I_j := \\left(\\frac 1 {j+1}, \\frac 1 j\\right]  for 1\\leq j  and I_k := \\left(0, \\frac 1 k\\right] such that \\bigcup_{j=1}^k I_j = (0,1]. This algorithm was first described by Lee and Lee.  It has a time complexity of \\mathcal{O}(|L|\\log(|L|)) and at each step, there are at most  open bins that can be potentially used to place items, i.e., it is a -bounded space algorithm. For k \\rightarrow \\infty, its approximation ratio satisfies R_{Hk}^{\\infty} \\approx 1.6910, and it is asymptotically tight.\n* Refined-harmonic combines ideas from Harmonic-k with ideas from Refined-First-Fit. It places the items larger than \\tfrac 1 3 similar as in Refined-First-Fit, while the smaller items are placed using Harmonic-k. The intuition for this strategy is to reduce the huge waste for bins containing pieces that are just larger than \\tfrac 1 2. This algorithm was first described by Lee and Lee.  They proved that for k = 20 it holds that R^\\infty_{RH} \\leq 373/228.\nGeneral lower bounds for online algorithms\nYao proved in 1980 that there can be no online algorithm with an asymptotic competitive ratio smaller than \\tfrac 3 2. Brown and Liang improved this bound to . Afterward, this bound was improved to  by Vliet.  In 2012, this lower bound was again improved by Békési and Galambos to \\tfrac {248}{161} \\approx 1.54037.\nComparison table\n{| class=\"wikitable\"\n!Algorithm\n!Approximation guarantee\n!Worst case list L\n!Time-complexity\n|-\n|Next-fit (NF)\n|NF(L) \\leq 2 \\cdot \\mathrm{OPT}(L) -1\n|NF(L) = 2 \\cdot \\mathrm{OPT}(L) -2\n|\\mathcal{O}(|L|)\n|-\n|First-fit (FF)\n|FF(L) \\leq \\lfloor 1.7\\mathrm{OPT}(L)\\rfloor\n|FF(L) = \\lfloor 1.7\\mathrm{OPT}(L)\\rfloor\n|\\mathcal{O}(|L|\\log(|L|))\n|-\n|Best-fit (BF)\n|BF(L) \\leq \\lfloor 1.7\\mathrm{OPT}(L) \\rfloor\n|BF(L) =\\lfloor 1.7\\mathrm{OPT}(L) \\rfloor\n|\\mathcal{O}(|L|\\log(|L|))\n|-\n|Worst-Fit (WF)\n|WF(L) \\leq 2 \\cdot \\mathrm{OPT}(L) -1\n|WF(L) = 2 \\cdot \\mathrm{OPT}(L) -2\n|\\mathcal{O}(|L|\\log(|L|))\n|-\n|Almost-Worst-Fit (AWF)\n|R^{\\infty}_{AWF} \\leq 17/10\n|R^{\\infty}_{AWF} = 17/10\n|\\mathcal{O}(|L|\\log(|L|))\n|-\n|Refined-First-Fit (RFF)\n|RFF(L) \\leq (5/3) \\cdot \\mathrm{OPT}(L) +5\n|RFF(L)=(5/3)\\mathrm{OPT}(L) +1/3 (for \\mathrm{OPT}(L) = 6k+1)\n| \\mathcal{O}(|L|\\log(|L|))\n|-\n|Harmonic-k (Hk)\n|R_{Hk}^{\\infty} \\leq 1.69103 for k \\rightarrow \\infty\n|R_{Hk}^{\\infty} \\geq 1.69103\n|\\mathcal{O}(|L|\\log(|L|)\n|-\n|Refined Harmonic (RH)\n|R_{RH}^{\\infty} \\leq 373/228 \\approx 1.63597\n|\n|\\mathcal{O}(|L|)\n|-\n|Modified Harmonic (MH)\n|R_{MH}^{\\infty} \\leq 538/33 \\approx 1.61562\n|\n|\n|-\n|Modified Harmonic 2 (MH2)\n|R_{MH2}^{\\infty} \\leq 239091/148304 \\approx 1.61217\n|\n|\n|-\n|Harmonic + 1 (H+1)\n|\n|R_{H+1}^\\infty \\geq 1.59217\n|\n|-\n|Harmonic ++ (H++)\n|R_{H++}^\\infty \\leq 1.58889\n|R_{H++}^{\\infty} \\geq 1.58333\n|\n|}\nOffline algorithms\nIn the offline version of bin packing, the algorithm can see all the items before starting to place them into bins. This allows to attain improved approximation ratios.\nMultiplicative approximation\nThe simplest technique used by offline approximation schemes is the following:\n* Ordering the input list by descending size;\n* Run an online algorithm on the ordered list.\nJohnson proved that any AnyFit scheme A that runs on a list ordered by descending size has an asymptotic approximation ratio of1.22 \\approx \\frac{11}{9} \\leq R^{\\infty}_A \\leq \\frac{5}{4} = 1.25.Some methods in this family are (see the linked pages for more information):\n* First-fit-decreasing (FFD) orders the items by descending size, then calls First-Fit. Its approximation ratio is FFD(I) = \\frac{11}9 \\mathrm{OPT}(I) + \\frac 6 9, and this is tight.\n* Next-fit-decreasing (NFD) orders the items by descending size, then calls Next-Fit.  Its approximate ratio is slightly less than 1.7 in the worst case. It has also been analyzed probabilistically. Next-Fit packs a list and its inverse into the same number of bins. Therefore, Next-Fit-Increasing has the same performance as Next-Fit-Decreasing.\n* Modified first-fit-decreasing (MFFD), improves on FFD for items larger than half a bin by classifying items by size into four size classes large, medium, small, and tiny, corresponding to items with size > 1/2 bin, > 1/3 bin, > 1/6 bin, and smaller items respectively.  Its approximation guarantee is MFFD(I) \\leq \\frac {71}{60}\\mathrm{OPT}(I) + 1.\nFernandez de la Vega and Lueker presented a PTAS for bin packing. For every \\varepsilon>0, their algorithm finds a solution with size at most (1+\\varepsilon)\\mathrm{OPT} + 1 and runs in time  \\mathcal{O}(n\\log(1/\\varepsilon)) + \\mathcal{O}_{\\varepsilon}(1), where \\mathcal{O}_{\\varepsilon}(1) denotes a function only dependent on 1/\\varepsilon. For this algorithm, they invented the method of adaptive input rounding: the input numbers are grouped and rounded up to the value of the maximum in each group. This yields an instance with a small number of different sizes, which can be solved exactly using the configuration linear program.\nAdditive approximation\nThe Karmarkar-Karp bin packing algorithm finds a solution with size at most \\mathrm{OPT} + \\mathcal{O}(\\log^2(\\mathrm{OPT})), and runs in time polynomial in  (the polynomial has a high degree, at least 8).\nRothvoss presented an algorithm that generates a solution with at most \\mathrm{OPT} + \\mathcal{O}(\\log(\\mathrm{OPT})\\cdot \\log\\log(\\mathrm{OPT})) bins.\nHoberg and Rothvoss improved this algorithm to generate a solution with at most \\mathrm{OPT} + \\mathcal{O}(\\log(\\mathrm{OPT})) bins. The algorithm is randomized, and its running-time is polynomial in .\nComparison table\n{| class=\"wikitable\"\n!Algorithm\n!Approximation guarantee\n!Worst case instance\n|-\n|First-fit-decreasing (FFD)\n|\\mathrm{FFD}(I) \\leq \\frac {11}9 \\mathrm{OPT}(I) + \\frac 6 9\n|\\mathrm{FFD}(I) = \\frac {11}9 \\mathrm{OPT}(I) + \\frac 6 9\n|-\n|Modified-first-fit-decreasing (MFFD)\n|\\mathrm{MFFD}(I) \\leq \\frac {71}{60}\\mathrm{OPT}(I) + 1\n|R_\\mathrm{MFFD}^\\infty \\geq \\frac {71}{60}\n|-\n|Karmarkar and Karp\n|\\mathrm{KK}(I) \\leq \\mathrm{OPT}(I) + O(\\log^2{\\mathrm{OPT}(I)})\n|\n|-\n|Rothvoss\n|\\mathrm{HB}(I) \\leq \\mathrm{OPT}(I) + O(\\log{\\mathrm{OPT}(I)}\\log\\log{\\mathrm{OPT}(I)})\n|\n|-\n|Hoberg and Rothvoss\n|\\mathrm{HB}(I) \\leq \\mathrm{OPT}(I) + O(\\log{\\mathrm{OPT}(I)})\n|\n|}\nExact algorithms\nMartello and Toth developed an exact algorithm for the 1-dimensional bin-packing problem, called MTP. A faster alternative is the Bin Completion algorithm proposed by Richard E. Korf in 2002 and later improved.\nA further improvement was presented by Schreiber and Korf in 2013. The new Improved Bin Completion algorithm is shown to be up to five orders of magnitude faster than Bin Completion on non-trivial problems with 100 items, and outperforms the BCP (branch-and-cut-and-price) algorithm by Belov and Scheithauer on problems that have fewer than 20 bins as the optimal solution. Which algorithm performs best depends on problem properties like the number of items, the optimal number of bins, unused space in the optimal solution and value precision.\nSmall number of different sizes\nA special case of bin packing is when there is a small number d of different item sizes. There can be many different items of each size. This case is also called high-multiplicity bin packing, and It admits more efficient algorithms than the general problem.\nBin-packing with fragmentation\nBin-packing with fragmentation or fragmentable object bin-packing is a variant of the bin packing problem in which it is allowed to break items into parts and put each part separately on a different bin. Breaking items into parts may allow for improving the overall performance, for example, minimizing the number of total bin. Moreover, the computational problem of finding an optimal schedule may become easier, as some of the optimization variables become continuous. On the other hand, breaking items apart might be costly. The problem was first introduced by Mandal, Chakrabary and Ghose.\nVariants\nThe problem has two main variants.\n# In the first variant, called bin-packing with size-increasing fragmentation (BP-SIF), each item may be fragmented; overhead units are added to the size of every fragment.\n# In the second variant, called bin-packing with size-preserving fragmentation (BP-SPF) each item has a size and a cost; fragmenting an item increases its cost but does not change its size.\nComputational complexity\nMandal, Chakrabary and Ghose proved that BP-SPF is NP-hard.\nMenakerman and Rom showed that BP-SIF and BP-SPF are both strongly NP-hard. Despite the hardness, they present several algorithms and investigate their performance. Their algorithms use classic algorithms for bin-packing, like next-fit and first-fit decreasing, as a basis for their algorithms.\nBertazzi, Golden and Wang introduced a variant of BP-SIF with 1-x split rule: an item is allowed to be split in only one way according to its size. It is useful for the vehicle routing problem for example. In their paper, they provide the worst-case performance bound of the variant.\nShachnai, Tamir and Yehezkeli developed approximation schemes for BP-SIF and BP-SPF; a dual PTAS (a PTAS for the dual version of the problem), an asymptotic PTAS called APTAS, and a dual asymptotic FPTAS called AFPTAS for both versions.\nEkici introduced a variant of BP-SPF in which some items are in conflict, and it is forbidden to pack fragments of conflicted items into the same bin. They proved that this variant, too, is NP-hard.\nCassazza and Ceselli introduced a variant with no cost and no overhead, and the number of bins is fixed. However, the number of fragmentations should be minimized. They present mathematical programming algorithms for both exact and approximate solutions.\nRelated problems\nThe problem of fractional knapsack with penalties was introduced by Malaguti, Monaci, Paronuzzi and Pferschy. They developed an FPTAS and a dynamic program for the problem, and they showed an extensive computational study comparing the performance of their models. See also: Fractional job scheduling.\nPerformance with divisible item sizes\nAn important special case of bin packing is that the item sizes form a divisible sequence (also called factored). A special case of divisible item sizes occurs in memory allocation in computer systems, where the item sizes are all powers of 2. If the item sizes are divisible, then some of the heuristic algorithms for bin packing find an optimal solution.\nCardinality constraints on the bins\nThere is a variant of bin packing in which there are cardinality constraints on the bins: each bin can contain at most k items, for some fixed integer k.\n* Krause, Shen and Schwetman introduce this problem as a variant of optimal job scheduling: a computer has some k processors. There are some n jobs that take unit time (1), but have different memory requirements. Each time-unit is considered a single bin. The goal is to use as few bins (=time units) as possible, while ensuring that in each bin, at most k jobs run. They present several heuristic algorithms that find a solution with at most 2 \\mathrm{OPT} bins.\n* Kellerer and Pferschy present an algorithm with run-time O(n^2 \\log{n}), that finds a solution with at most \\left\\lceil\\frac{3}{2}\\mathrm{OPT}\\right\\rceil bins. Their algorithm performs a binary search for OPT. For every searched value m, it tries to pack the items into 3m/2 bins.\nNon-additive functions\nThere are various ways to extend the bin-packing model to more general cost and load functions:\n* Anily, Bramel and Simchi-Levi study a setting where the cost of a bin is a concave function of the number of items in the bin. The objective is to minimize the total cost rather than the number of bins. They show that next-fit-increasing bin packing attains an absolute worst-case approximation ratio of at most 7/4, and an asymptotic worst-case ratio of 1.691 for any concave and monotone cost function.\n* Cohen, Keller, Mirrokni and Zadimoghaddam study a setting where the size of the items is not known in advance, but it is a random variable. This is particularly common in cloud computing environments. While there is an upper bound on the amount of resources a certain user needs, most users use much less than the capacity. Therefore, the cloud manager may gain a lot by slight overcommitment. This induces a variant of bin packing with chance constraints: the probability that the sum of sizes in each bin is at most B should be at least p, where p is a fixed constant (standard bin packing corresponds to p=1). They show that, under mild assumptions, this problem is equivalent to a submodular bin packing problem, in which the \"load\" in each bin is not equal to the sum of items, but to a certain submodular function of it.\nRelated problems\nIn the bin packing problem, the size of the bins is fixed and their number can be enlarged (but should be as small as possible).\nIn contrast, in the multiway number partitioning problem, the number of bins is fixed and their size can be enlarged. The objective is to find a partition in which the bin sizes are as nearly equal is possible (in the variant called multiprocessor scheduling problem or minimum makespan problem, the goal is specifically to minimize the size of the largest bin).\nIn the vector bin packing problem, each item is a vector, and the size of each bin is also a vector. Let a bin has size w, and the sum of vectors in the bin be v, then the requirement is that \\forall i, v_i \\leq w_i.\nIn the inverse bin packing problem, both the number of bins and their sizes are fixed, but the item sizes can be changed. The objective is to achieve the minimum perturbation to the item size vector so that all the items can be packed into the prescribed number of bins.\nIn the maximum resource bin packing problem, the goal is to maximize the number of bins used, such that, for some ordering of the bins, no item in a later bin fits in an earlier bin. In a dual problem, the number of bins is fixed, and the goal is to minimize the total number or the total size of items placed into the bins, such that no remaining item fits into an unfilled bin.\nIn the bin covering problem, the bin size is bounded from below: the goal is to maximize the number of bins used such that the total size in each bin is at least a given threshold.\nIn the fair indivisible chore allocation problem (a variant of fair item allocation), the items represent chores, and there are different people each of whom attributes a different difficulty-value to each chore. The goal is to allocate to each person a set of chores with an upper bound on its total difficulty-value (thus, each person corresponds to a bin). Many techniques from bin packing are used in this problem too.\nIn the guillotine cutting problem, both the items and the \"bins\" are two-dimensional rectangles rather than one-dimensional numbers, and the items have to be cut from the bin using end-to-end cuts.\nIn the selfish bin packing problem, each item is a player who wants to minimize its cost.\nThere is also a variant of bin packing in which the cost that should be minimized is not the number of bins, but rather a certain concave function of the number of items in each bin.\nOther variants are two-dimensional bin packing, three-dimensional bin packing, bin packing with delivery,\nResources\n* [https://site.unibo.it/operations-research/en/research/bpplib-a-bin-packing-problem-library BPPLIB] - a library of surveys, codes, benchmarks, generators, solvers, and bibliography.\nReferences"
    }
  ]
}