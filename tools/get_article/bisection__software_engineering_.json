{
  "content": [
    {
      "type": "text",
      "text": "# Bisection (software engineering)\n\nBisect}}\nBisection is a method used in software development to identify change sets that result in a specific behavior change. It is mostly employed for finding the patch that introduced a bug. Another application area is finding the patch that indirectly fixed a bug.\nOverview\nThe process of locating the changeset that introduced a specific regression was described as \"source change isolation\" in 1997 by Brian Ness and Viet Ngo of Cray Research. Regression testing was performed on Cray's compilers in editions comprising one or more changesets. Editions with known regressions could not be validated until developers addressed the problem. Source change isolation narrowed the cause to a single changeset that could then be excluded from editions, unblocking them with respect to this problem, while the author of the change worked on a fix. Ness and Ngo outlined linear search and binary search methods of performing this isolation.\nCode bisection has the goal of minimizing the effort to find a specific change set.\nIt employs a divide and conquer algorithm that\ndepends on having access to the code history which is usually preserved by\nrevision control in a code repository.\nBisection method\nCode bisection algorithm\nCode history has the structure of a directed acyclic graph which can be topologically sorted. This makes it possible to use a divide and conquer search algorithm which:\n* splits up the search space of candidate revisions\n* tests for the behavior in question\n* reduces the search space depending on the test result\n* re-iterates the steps above until a range with at most one bisectable patch candidate remains\nAlgorithmic complexity\nBisection is in LSPACE having an algorithmic complexity of O(\\log N) with N denoting the number of revisions in the search space, and is similar to a binary search.\nDesirable repository properties\nFor code bisection it is desirable that each revision in the search space can be built and tested independently.\nMonotonicity\nFor the bisection algorithm to identify a single changeset which caused the behavior being tested to change, the behavior must change monotonically across the search space. For a Boolean function such as a pass/fail test, this means that it only changes once across all changesets between the start and end of the search space.\nIf there are multiple changesets across the search space where the behavior being tested changes between false and true, then the bisection algorithm will find one of them, but it will not necessarily be the root cause of the change in behavior between the start and the end of the search space. The root cause could be a different changeset, or a combination of two or more changesets across the search space. To help deal with this problem, automated tools allow specific changesets to be ignored during a bisection search.\nAutomation support\nAlthough the bisection method can be completed manually, one of its main advantages is that it can be easily automated. It can thus fit into existing test automation processes: failures in exhaustive automated regression tests can trigger automated bisection to localize faults. Ness and Ngo focused on its potential in Cray's continuous delivery-style environment in which the automatically isolated bad changeset could be automatically excluded from builds.\nThe revision control systems Fossil, Git and Mercurial have built-in functionality for code bisection. The user can start a bisection session with a specified range of revisions from which the revision control system proposes a revision to test, the user tells the system whether the revision tested as \"good\" or \"bad\", and the process repeats until the specific \"bad\" revision has been identified. Other revision control systems, such as Bazaar or Subversion, support bisection through plugins or external scripts.\nPhoronix Test Suite can do bisection automatically to find performance regressions.\nSee also\n* Delta debugging (generalization of finding a minimal cause of a bug)\n*  (determining changesets that edited a line in a file)\nReferences"
    }
  ]
}