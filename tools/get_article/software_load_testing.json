{
  "content": [
    {
      "type": "text",
      "text": "# Software load testing\n\nThe term load testing or stress testing is used in different ways in the professional software testing community. Load testing generally refers to the practice of modeling the expected usage of a software program by simulating multiple users accessing the program concurrently. As such, this testing is most relevant for multi-user systems; often one built using a client/server model, such as web servers. However, other types of software systems can also be load tested. For example, a word processor or graphics editor can be forced to read an extremely large document; or a financial package can be forced to generate a report based on several years' worth of data. The most accurate load testing simulates actual use, as opposed to testing using theoretical or analytical modeling.\nLoad testing lets you measure your website's quality of service (QOS) performance based on actual customer behavior. Nearly all the load testing tools and frameworks follow the classical load testing paradigm: when customers visit your website, a script recorder records the communication and then creates related interaction scripts. A load generator tries to replay the recorded scripts, which could possibly be modified with different test parameters before replay. In the replay procedure, both the hardware and software statistics will be monitored and collected by the conductor, these statistics include the CPU, memory, disk IO of the physical servers and the response time, the throughput of the system under test (SUT), etc. And at last, all these statistics will be analyzed and a load testing report will be generated.\nLoad and performance testing analyzes software intended for a multi-user audience by subjecting the software to different numbers of virtual and live users while monitoring performance measurements under these different loads. Load and performance testing is usually conducted in a test environment identical to the production environment before the software system is permitted to go live.\nObjectives of load testing:\n- To ensure that the system meets performance benchmarks;\n- To determine the breaking point of the system;\n- To test the way the product reacts to load-induced downtimes.\nAs an example, a website with shopping cart capability is required to support 100 concurrent users broken out into the following activities:\n* 25 virtual users (VUsers) log in, browse through items and then log off\n* 25 VUsers log in, add items to their shopping cart, check out and then log off\n* 25 VUsers log in, return items previously purchased and then log off\n* 25 VUsers just log in without any subsequent activity\nA test analyst can use various load testing tools to create these VUsers and their activities. Once the test has started and reached a steady-state, the application is being tested at the 100 VUser loads as described above. The application's performance can then be monitored and captured.\nThe specifics of a load test plan or script will generally vary across organizations. For example, in the bulleted list above, the first item could represent 25 VUsers browsing unique items, random items, or a selected set of items depending upon the test plan or script developed. However, all load test plans attempt to simulate system performance across a range of anticipated peak workflows and volumes. The criteria for passing or failing a load test (pass/fail criteria) are generally different across organizations as well. There are no standards specifying acceptable load testing performance metrics.\nA common misconception is that load testing software provides record and playback capabilities like regression testing tools. Load testing tools analyze the entire OSI protocol stack whereas most regression testing tools focus on GUI performance. For example, a regression testing tool will record and playback a mouse click on a button on a web browser, but a load testing tool will send out hypertext the web browser sends after the user clicks the button. In a multiple-user environment, load testing tools can send out hypertext for multiple users with each user having a unique login ID, password, etc.\nThe popular load testing tools available also provide insight into the causes for slow performance. There are numerous possible causes for slow system performance, including, but not limited to, the following:\n* Application server(s) or software\n* Database server(s)\n* Network â€“ latency, congestion, etc.\n* Client-side processing\n* Load balancing between multiple servers\nLoad testing is especially important if the application, system, or service will be subject to a service level agreement or SLA.\nLoad testing is performed to determine a system's behavior under both normal and anticipated peak load conditions. It helps to identify the maximum operating capacity of an application as well as any bottlenecks and determine which element is causing degradation. When the load placed on the system is raised beyond normal usage patterns to test the system's response at unusually high or peak loads, it is known as stress testing. The load is usually so great that error conditions are the expected result, but there is no clear boundary when an activity ceases to be a load test and becomes a stress test.\nThe term \"load testing\" is often used synonymously with concurrency testing, software performance testing, reliability testing, and volume testing for specific scenarios. All of these are types of non-functional testing that are not part of functionality testing used to validate suitability for use of any given software.\nUser experience under load test\nIn the example above, while the device under test (DUT) is under production load - 100 VUsers, run the target application.  The performance of the target application here would be the User Experience Under Load. It describes how fast or slow the DUT responds, and how satisfied or how the user actually perceives performance.\nBrowser-level vs. protocol-level users\nHistorically, all load testing was performed with automated API tests that simulated traffic through concurrent interactions at the protocol layer (often called protocol level users or PLUs). With the advance of containers and cloud infrastructure, the option is now present to test with real browsers (often called browser level users or BLUs). Each approach has its merits for different types of applications, but generally, browser-level users will be more akin to the real traffic that a website will experience and provide a more realistic load profile and response time measurement. BLUs are certainly a more expensive way of running tests and cannot work with all types of applications, specifically those that are not accessible through a web browser like a desktop client or API-based application.\nLoad testing tools\n{| class=\"wikitable sortable\"\n|-\n! Tool name\n! Company name\n! License\n! Type\n! Pricing\n! Focus\n! Notes\n|-\n|Apache JMeter\n|Apache Software Foundation\n|Apache License&nbsp;2.0\n|Local\n|Free\n|\n|Java desktop application for load testing and performance measurement.\n|-\n|BlazeMeter\n|Perforce Software, Inc\n|\n|Cloud-based\n|Free version, demo, paid plan, contact for pricing\n|Website, web app, mobile, database, and other scenarios\n|Scalable load up to 200,000 concurrent simulated browser users from across eight geographical locations. Can also be used for integration and functional testing.\n|-\n|Blitz (discontinued in 2018)\n|Spirent Communications\n|\n|Cloud-based\n|Trial available\n|Websites, mobile, and REST APIs\n|It allows to simulate of up to 50,000 simultaneous virtual users from different worldwide locations.\n|-\n|Flood\n|Tricentis APAC Pty Ltd\n|\n|Cloud-based\n|Free plan, paid plan, contact for pricing\n|Browser based load testing, APIs and protocol driven applications\n|Scalable load up to millions of concurrent users from all geographic regions available on AWS and Azure, plus on-premise deployments. Pricing is based on Virtual User Hours consumed each month.\n|-\n|Gatling\n|Gatling Corp\n|Apache License&nbsp;2.0\n|Local, cloud-based\n|Free version, demo, paid plan, contact for pricing\n|Java web applications\n|Portable HTML reports.\n|-\n|HammerDB\n|\n|GPLv3\n|Local\n|Free\n|Databases\n|Database load testing and benchmarking tool.\n|-\n|Loader.io\n|SendGrid, Inc\n|\n|Cloud-based\n|Free plan, paid plan, contact for pricing\n|Web applications and API\n|\n|-\n|LoadRunner\n|Micro Focus\n|\n|Local, Cloud-based\n|Free community edition; other: demo, free trial, contact for pricing\n|\n|Primarily used for executing large numbers of tests (or a large number of virtual users) concurrently. Can be used for unit and integration testing as well.\n|-\n|LoadUI (integrated now in ReadyAPI)\n|SmartBear Software\n|EUPL\n|Local\n|Demo available\n|\n|Cross-platform load testing tool, targeted mainly at web services. Integrates with soapUI.\n|-\n|[https://github.com/locustio/locust/ Locust]\n|Open source\n|MIT License\n|Local, cloud-based\n|Free, hosted paid version available\n|\n|Python based framework with load tests expressed in regular code\n|-\n|Login VSI\n|Login VSI, Inc.\n|\n|Local\n|Demo, contact for pricing\n|Virtual windows desktops workloads\n|\n|-\n|NeoLoad\n|Neotys\n|\n|Local, cloud-based\n|Free trial, demo, contact for pricing\n|Web and mobile\n|Load can be generated from local agents or from the cloud.\n|-\n|OpenSTA\n|CYRANO\n|GNU General Public License&nbsp;2.0\n|Local\n|Free\n|Web server\n|Utilizes a distributed software architecture based on CORBA. OpenSTA binaries available for Windows.\n|-\n|Parasoft SOAtest\n|Parasoft\n|\n|Local, cloud-based\n|Demo, contact for pricing\n|\n|Performance testing tool that verifies functionality and performance under load. Supports SOAtest tests, JUnits, lightweight socket-based components. Detects concurrency issues.\n|-\n|Rational Performance Tester\n|IBM\n|\n|Local, cloud-based\n|Contact for pricing\n|\n| Eclipse-based large-scale performance testing tool primarily used for executing large volume performance tests to measure system response time for server-based applications.\n|-\n|Siege\n|Open source\n|&nbsp;GPLv3&nbsp;or later\n|Local\n|Free\n|Web servers\n|Supports basic authentication, cookies, HTTP, HTTPS and FTP protocols.\n|-\n|Silk Performer\n|Micro Focus\n|\n|Local, cloud-based\n|Free trial, contact for pricing\n|\n|Application performance tool with cloud and local virtual agents. Supports most protocols and applications. Licensed.\n|-\n|SoapUI\n|SmartBear Software\n|EUPL Version 1.1\n|Local\n|Free\n|\n|\n|-\n|Test Studio\n|Progress Telerik\n|\n|Local\n|Free trial, demo, paid plan\n|\n|Assess how the website would perform if visited by a large number of users at the same time.\n|-\n|Tsung\n|Open Source\n|GPL-2.0\n|Local\n|Free\n|Web servers, Databases, XMPP\n|It can be used to stress HTTP, WebDAV, SOAP, PostgreSQL, MySQL, LDAP, MQTT and Jabber/XMPP servers.\n|-\n|Visual Studio Enterprise edition (deprecated after Visual Studio 2019)\n|Microsoft\n|\n|Local\n|Paid plan\n|\n| Visual Studio Enterprise edition includes a load test tool that enables a developer to execute a variety of tests (web, unit, etc...) with a combination of configurations to simulate real user load. Microsoft announced that its web performance and load test functionality was deprecated after Visual Studio 2019.\n|-\n|Vegeta\n|\n|MIT License\n|Local\n|Free\n|HTTP applications\n|\n|-\n|WebLOAD\n|RadView Software Ltd\n|\n|Local, cloud-based\n|Free trial, demo, contact for pricing\n|Web and Mobile applications and API\n|Load testing tool for web and mobile applications including Web Dashboard for performance test analysis. Used for large-scale loads which can be generated also from the cloud. Licensed.\n|}\nReferences"
    }
  ]
}