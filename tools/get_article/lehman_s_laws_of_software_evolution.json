{
  "content": [
    {
      "type": "text",
      "text": "# Lehman's laws of software evolution\n\nIn software engineering, the laws of software evolution refer to a series of laws that Lehman and Belady formulated starting in 1974 with respect to software evolution.\nThe laws describe a balance between forces driving new developments on one hand, and forces that slow down progress on the other hand.  Over the past decades the laws have been revised and extended several times.\nContext\nObserving that most software is subject to change in the course of its existence, the authors set out to determine laws that these changes will typically obey, or must obey for the software to survive.\nIn his 1980 article, Lehman qualified the application of such laws by distinguishing between three categories of software:\n* An S-program is written according to an exact specification of what that program can do. For example, a program to find solutions to the eight queens puzzle would be an S-program. The validity of an S-program is derived entirely from the specification. These programs are mostly static and shouldn't evolve much.\n* A P-program is written to model a real-world problem. An example given is weather prediction. Even though a P-program is also written according to some specification, the P-program's ultimate value and validity is determined by comparing its output not to the specification, but to the real-world context.\n* An E-program is written to \"mechanize a human or societal activity.\" As such, E-programs are embedded in the portion of the real-world that they model. How an E-program should behave is strongly linked to the environment in which it runs, and such a program needs to adapt continually to varying requirements and circumstances in that environment\nIn the same article, Lehman also defined A-programs as the union of P and E types. A-programs differ from S types \"in that they represent an application in the real world.\" However, in a later 1997 paper, he appeared to blur the distinction between A and E types by defining E-type programs as \"software solving a problem or addressing an application in the real world.\" The laws summarized below are said to apply to E-type programs under the later definition.\nThe laws\nAll told, eight laws were formulated:\n# (1974) \"Continuing Change\" — an E-type system must be continually adapted or it becomes progressively less satisfactory.\n# (1974) \"Increasing Complexity\" — as an E-type system evolves, its complexity increases unless work is done to maintain or reduce it.\n# (1974) \"Self Regulation\" — E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.\n# (1978) \"Conservation of Organisational Stability (invariant work rate)\" — the average effective global activity rate in an evolving E-type system is invariant over the product's lifetime.\n# (1978) \"Conservation of Familiarity\" — as an E-type system evolves, all associated with it, developers, sales personnel and users, for example, must maintain mastery of its content and behaviour to achieve satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.\n# (1991) \"Continuing Growth\" — the functional content of an E-type system must be continually increased to maintain user satisfaction over its lifetime.\n# (1996) \"Declining Quality\" — the quality of an E-type system will appear to be declining unless it is rigorously maintained and adapted to operational environment changes.\n# (1996) \"Feedback System\" (first stated 1974, formalised as law 1996) — E-type evolution processes constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.\nReferences"
    }
  ]
}