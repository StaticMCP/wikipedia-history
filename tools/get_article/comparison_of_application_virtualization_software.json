{
  "content": [
    {
      "type": "text",
      "text": "# Comparison of application virtualization software\n\nApplication virtualization software refers to both application virtual machines and software responsible for implementing them. Application virtual machines are typically used to allow application bytecode to run portably on many different computer architectures and operating systems. The application is usually run on the computer using an interpreter or just-in-time compilation (JIT). There are often several implementations of a given virtual machine, each covering a different set of functions.\nComparison of virtual machines\nThe table here summarizes elements for which the virtual machine designs are intended to be efficient, not the list of abilities present in any implementation.\n{| class=\"wikitable sortable\"\n|-\n!Virtual machine\n!Machine model\n!Memory management\n!Code security\n!Interpreter\n!JIT\n!AOT\n!Shared libraries\n!Common Language Object Model\n!Dynamic typing\n|-\n! Android Runtime (ART)\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! Common Language Runtime (CLR)\n| stack\n| automatic or manual\n|\n|\n|\n|\n|\n|\n|\n|-\n! Dis (Inferno)\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! DotGNU Portable.NET\n| stack\n| automatic or manual\n|\n|\n|\n|\n|\n|\n|\n|-\n! HotSpot JVM\n| stack\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! JikesRVM\n| stack\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! LLVM\n| register\n| manual\n|\n|\n|\n|\n|\n|\n|\n|-\n! Mono\n| stack\n| automatic or manual\n|\n|\n|\n|\n|\n|\n|\n|-\n! Parrot\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! Dalvik\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! Squeak\n| stack\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! BEAM (Erlang)\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|-\n! MoarVM\n| register\n| automatic\n|\n|\n|\n|\n|\n|\n|\n|}\nVirtual machine instructions process data in local variables using a main model of computation, typically that of a stack machine, register machine, or random access machine often called the memory machine. Use of these three methods is motivated by different tradeoffs in virtual machines vs physical machines, such as ease of interpreting, compiling, and verifying for security.\nMemory management in these portable virtual machines is addressed at a higher level of abstraction than in physical machines. Some virtual machines, such as the popular Java virtual machines (JVM), are involved with addresses in such a way as to require safe automatic memory management by allowing the virtual machine to trace pointer references, and disallow machine instructions from manually constructing pointers to memory. Other virtual machines, such as LLVM, are more like traditional physical machines, allowing direct use and manipulation of pointers. Common Intermediate Language (CIL) offers a hybrid in between, allowing both controlled use of memory (like the JVM, which allows safe automatic memory management), while also allowing an 'unsafe' mode that allows direct pointer manipulation in ways that can violate type boundaries and permission.\nCode security generally refers to the ability of the portable virtual machine to run code while offering it only a prescribed set of abilities. For example, the virtual machine might only allow the code access to a certain set of functions or data. The same controls over pointers which make automatic memory management possible and allow the virtual machine to ensure typesafe data access are used to assure that a code fragment is only allowed to certain elements of memory and cannot bypass the virtual machine itself. Other security mechanisms are then layered on top as code verifiers, stack verifiers, and other methods.\nAn interpreter allows programs made of virtual instructions to be loaded and run immediately without a potentially costly compile into native machine instructions. Any virtual machine which can be run can be interpreted, so the column designation here refers to whether the design includes provisions for efficient interpreting (for common usage).\nJust-in-time compilation (JIT), refers to a method of compiling to native instructions at the latest possible time, usually immediately before or during the running of the program. The challenge of JIT is more one of implementation than of virtual machine design, however, modern designs have begun to make considerations to help efficiency. The simplest JIT methods simply compile to a code fragment similar to an offline compiler. However, more complex methods are often employed, which specialize compiled code fragments to parameters known only at runtime (see Adaptive optimization).\nAhead-of-time compilation (AOT) refers to the more classic method of using a precompiler to generate a set of native instructions which do not change during the runtime of the program. Because aggressive compiling and optimizing can take time, a precompiled program may launch faster than one which relies on JIT alone for execution. JVM implementations have mitigated this startup cost by initial interpreting to speed launch times, until native code fragments can be generated by JIT.\nShared libraries are a facility to reuse segments of native code across multiple running programs. In modern operating systems, this generally means using virtual memory to share the memory pages containing a shared library across different processes which are protected from each other via memory protection. It is interesting that aggressive JIT methods such as adaptive optimization often produce code fragments unsuitable for sharing across processes or successive runs of the program, requiring a tradeoff be made between the efficiencies of precompiled and shared code and the advantages of adaptively specialized code. For example, several design provisions of CIL are present to allow for efficient shared libraries, possibly at the cost of more specialized JIT code. The JVM implementation on OS X uses a Java Shared Archive to provide some of the benefits of shared libraries.\nComparison of application virtual machine implementations\nIn addition to the portable virtual machines described above, virtual machines are often used as an execution model for individual scripting languages, usually by an interpreter. This table lists specific virtual machine implementations, both of the above portable virtual machines, and of scripting language virtual machines.\n{| class=\"wikitable sortable\"\n|-\n! Virtual machine\n! Languages executed\n! Comments\n! Interpreter\n! JIT\n! Implementation language\n! SLoC\n|-\n!BEAM\n|Erlang, Elixir, Gleam, Cuneiform, LFE, Clojerl, Luerl\n|\n|\n|\n|Erlang, C, C++\n|1561k including OTP\n|-\n! Common Language Runtime (CLR)\n| C#, C++/CLI, F#, VB.NET\n| bytecode is CIL; .NET Core Runtime on GitHub\n|\n|\n| C#, C++\n|\n|-\n! Adobe Flash Player (aka Tamarin)\n| ActionScript, SWF (file format)\n| interactive web authoring tool; bytecode is named ActionScript Byte Code (.abc)\n|\n|\n| C++\n| 135k (initially released)\n|-\n! Dis (Inferno)\n| Limbo\n| Dis Virtual Machine Specification\n|\n|\n| C\n| 15k + 2850 per JIT arch + 500 per host OS\n|-\n! DotGNU-Portable.NET\n| CLI languages including: C#\n| Common Language Runtime clone\n|\n|\n| C, C#\n|\n|-\n! Forth\n| Forth\n| Features are simplified, usually include assembler, compiler, text-level and binary-level interpreters, sometimes editor, debugger and OS; compile speed is >20 SKLOC/S, behaves much like JIT.\n|\n|\n| Forth, Forth Assembler\n| 2.8K to 5.6K; advanced, professional implementations are smaller.\n|-\n! Glulx\n| Inform 6, Inform 7, others\n|\n|\n|\n| Various implementations exist\n|\n|-\n|-\n! HHVM\n| PHP, Hack\n| Is an open-source virtual machine designed for executing programs written in Hack and PHP.\n|\n|\n| C++, OCaml\n|\n|-\n! HotSpot\n| Java, Kotlin, Jython, Groovy, JRuby, C, C++, Clojure, Scala and several others\n| JVM reference implementation by Sun; OpenJDK: code under GPL; IcedTea: code and tools under GPL\n|\n|\n| JDK, OpenJDK & IcedTea with regular JIT : Java, C, C++, ASM ; IcedTea with the \"Zero\" JIT : Java, C, C++\n| HotSpot is around 6500k lines; TCK is 80k tests and around 1000k lines\n|-\n! Icon\n| Icon\n| Base source code provides both the interpreter as well as an unsupported compile-to-C version.  The runtime code, that is shared between the compiler and the interpreter, is written in a variant of C called RTT.\n|\n|\n|C, RTT (a custom front-end to C, provided with the base source for Icon).\n| ~180k total.  (source to bytecode: ~11k, bytecode interpreter: ~46k, iconc: ~23k, common/headers: ~13k, rtt: ~15k)\n|-\n! LLVM\n| C, C++, Kotlin, Objective-C, Swift, Ada, Fortran, and Rust\n| MSIL, C and C++ output are supported. ActionScript Byte Code output is supported by Adobe Alchemy. bytecode is named \"LLVM Bytecode (.bc)\". assembly is named \"LLVM Assembly Language (*.ll)\".\n|\n|\n| C++\n| 811k\n|-\n! Lua\n| Lua\n|\n|\n| LuaJIT\n| C\n| 13k + 7k LuaJIT\n|-\n! MMIX\n| MMIXAL\n|\n|\n|\n|\n|\n|-\n! Mono\n| CLI languages including: C#, VB.NET, IronPython, IronRuby, and others\n| Common Language Runtime clone\n|\n|\n| C#, C\n| 2332k\n|-\n! NekoVM\n| currently Neko and Haxe\n|\n|\n| x86 only\n| C\n| 46k\n|-\n! Oz\n| Oz, Alice\n|\n|\n|\n|\n|\n|-\n! O-code machine\n| BCPL\n|\n|\n|\n|\n|\n|-\n! p-code machine\n| Pascal\n| UCSD Pascal, widespread in late 70s including Apple II\n|\n|\n|assembly, Pascal\n|\n|-\n! Parrot\n| Perl 5, Raku, NQP-rx, PIR, PASM, PBC, BASIC, bc, C99, ECMAScript, Lisp, Lua, m4, Tcl, WMLScript, XML, and others\n|\n|\n|\n| C, Perl\n| 111k&nbsp;C, 240k&nbsp;Perl\n|-\n! Perl virtual machine\n| Perl\n| op-code tree walker\n|\n|\n| C, Perl\n| 175k&nbsp;C, 9k&nbsp;Perl\n|-\n! CPython\n| Python\n|\n|\n|\n| C\n| 387k&nbsp;C, 368k&nbsp;Python, 10k&nbsp;ASM, 31k&nbsp;Psyco\n|-\n! PyPy\n| Python\n| Self-hosting implementation of Python, next generation of Psyco\n|\n|\n| Python\n|\n|-\n! Rubinius\n| Ruby\n| Virtual machine for another Ruby implementation\n|\n|\n| C++, Ruby\n|\n|-\n! Silverlight\n| C#, VB.NET\n| Micro-version of Microsoft .NET Framework to let applications run sandboxed inside browser\n|\n|\n| C++\n| 7MB (first release)\n|-\n! ScummVM\n| Scumm\n| Computer game engine\n|\n|\n|\n|\n|-\n! SECD\n| ISWIM, Lispkit Lisp\n|\n|\n|\n|\n|\n|-\n! Squirrel\n| Squirrel\n|\n|\n| Squirrel_JIT\n| C++\n| 12k\n|-\n! Smalltalk\n| Smalltalk\n|\n|\n|\n|\n|\n|-\n! SQLite\n| SQLite opcodes\n| Virtual database engine\n|\n|\n|\n|\n|-\n! Squeak\n| Squeak Smalltalk\n| Self hosting implementation of Squeak virtual machine.  Rich multi-media support.\n|\n|\n| Smalltalk/Slang\n| 110k Smalltalk, ~300K C\n|-\n!SWI-Prolog\n|Prolog: SWI-Prolog, YAP\n|\n|\n|\n| C, SWI-Prolog\n|\n|-\n! TraceMonkey\n| JavaScript\n| Based on Tamarin\n|\n|\n| C++\n| 173k\n|-\n! TrueType\n| TrueType\n| Font rendering engine\n|\n|\n| C (typically)\n|\n|-\n! Valgrind\n| x86/x86-64 binaries\n| Checking of memory accesses and leaks under Linux\n|\n|\n| C\n| 467k\n|-\n! VisualWorks\n| Smalltalk\n|\n|\n|\n| C\n|\n|-\n! Vx32 virtual machine\n| x86 binaries\n| Application-level virtualization for native code\n|\n|\n|\n|\n|-\n! Waba\n|\n| Virtual machine for small devices, similar to Java\n|\n|\n|\n|\n|-\n! Yet Another Ruby VM (YARV)\n| Ruby\n| Virtual machine of the reference implementation for Ruby 1.9 and newer versions\n|\n|\n|C\n|\n|-\n! Z-machine\n| Z-Code\n|\n|\n|\n|\n|\n|-\n! Zend Engine\n| PHP\n|\n|\n|\n| C\n| 75k\n|}\nSee also\n* Application virtualization\n* Language binding\n* Foreign function interface\n* Calling convention\n* Name mangling\n* Application programming interface (API)\n* Application binary interface (ABI)\n* Comparison of platform virtualization software\n* Comparison of Java virtual machines\n* List of Java virtual machines\n* List of ECMAScript engines\n* List of application servers\n* WebAssembly\nReferences\npt:Comparação entre aplicações de virtualização de máquinas"
    }
  ]
}