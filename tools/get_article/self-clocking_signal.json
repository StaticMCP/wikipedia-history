{
  "content": [
    {
      "type": "text",
      "text": "# Self-clocking signal\n\nIn telecommunications and electronics, a self-clocking signal is one that can be decoded without the need for a separate clock signal or other source of synchronization. This is usually done by including embedded synchronization information within the signal, and adding constraints on the coding of the data payload such that false synchronization can easily be detected.\nMost line codes are designed to be self-clocking.\nIsochronicity and anisochronicity\nIf a clock signal is embedded in the data transmission, there are two possibilities: the clock signals are sent at the same time as the data (isochronous), or at a different time (anisochronous).\nIsochronous self-clocking signals\nIf the embedded clock signal is isochronous, it gets sent simultaneously with the data. Below is an example signal, in this case using the Manchester code self-clocking signal. The data and clock cycles can be thought of as \"adding up\" to a combination, where both the clock cycle and the data can be retrieved from the transmitted signal.\nImage:Manchester_encoding_both_conventions.svg\nAsynchronous self-clocking signals\nAsynchronous self-clocking signals do not combine clock cycles and data transfer into one continuous signal. Instead, the transmission of clock cycles and data transmission is modulated. Below is an example signal used in asynchronous serial communication, where it is made clear that the information about the clock speed is transmitted in a different timeframe than the actual data.\nImage:Puerto serie Rs232.png\nImplementations\nExample uses of self-clocking signal protocols include:\n*Isochronous\n**Manchester code, where the clock signals occur at the transition points.\n**Plesiochronous digital hierarchy (PDH) signals\n**Eight-to-fourteen modulation (EFM)\n**4B5B\n**8b/10b encoding\n**64b/66b encoding\n**HDLC\n**Modified frequency modulation (MFM)\n*Anisochronous\n**Morse code\n**Asynchronous start-stop\nMost of these codes can be seen as a kind of run-length limited (RLL) code. Those constraints on \"runs\" of zeros and \"runs\" of ones ensure that transitions occur often enough to keep the receiver synchronized.\nSuch self-clocking signals can be decoded correctly into a stream of bits without bit slip. To further decode that stream of bits and decide which bit is the first bit of a byte, often a self-synchronizing code is used.\nAnalog examples\nAmplitude modulation – modulating a signal M(t) by changing the amplitude of a carrier wave, as in:\n:y(t) = M(t) \\cdot \\cos(\\omega_c t),\nis self-clocking, as the zero crossings serve as a clock pulse.\nOne may consider this clock pulse redundant information, or at least a wasteful use of channel capacity, and duplex the channel by varying the phase, as in polar modulation, or adding another signal that is 90° out of phase (a sine wave), as in quadrature modulation. The result is to send twice as many signals over the channel, at the cost of losing the clock, and thus suffering signal degradation in case of clock drift (the analog equivalent of bit drift).\nThis demonstrates how encoding clocking or synchronization in a code costs channel capacity, and illustrates the trade-off.\nSee also\n* Delay insensitive circuit\nReferences"
    }
  ]
}