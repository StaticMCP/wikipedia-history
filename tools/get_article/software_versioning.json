{
  "content": [
    {
      "type": "text",
      "text": "# Software versioning\n\nSoftware versioning is the process of assigning unique version names or unique version numbers to unique states of computer software. The most widely adopted scheme for version numbers is known as semantic versioning (SemVer), which comprises a three-part version number (Major.Minor.Patch), an optional pre-release tag (e.g. alpha, beta), and an optional build meta tag. A fourth number may also be used to denote the software build, as was the case for Adobe Flash. Some companies also rely on the build date, in a system known as calendar versioning, and letters and other characters, such as Lotus 1-2-3 Release 1a.\nMost free and open-source software packages, including MediaWiki, treat versions as a series of individual numbers, separated by periods, with a progression such as 1.8.1, 1.9.0. On the other hand, some software packages identify releases by decimal numbers: 1.8, 1.81, 1.82. Developers may choose to jump multiple minor versions at a time to indicate that significant features have been added or for marketing purposes. Version numbers are often used to identify copies of a software product and compare them against another copy in a collaborative version control system.\nWithin software development teams, version control is used to keep track of incrementally-different versions of information in order to be able to roll any changes back. Modern computer software is often tracked using two different software versioning schemes: an internal version number, which may be incremented many times in a single day, and a release version, which typically changes far less often.\nHistorically, file numbers were especially used in public administration and corporations to uniquely identify files or cases. This practice was introduced to computer files for the first time with MIT's ITS file system, later the TENEX file system for the PDP-10 in 1972. In the 21st century, more programmers started to use a standardized version policy, such as the semantic versioning policy, which is particularly useful when using software libraries, frameworks, and command-line applications.\nHistory\nFile numbers were used especially in public administration, as well as companies, to uniquely identify files or cases. For computer files this practice was introduced for the first time with MIT's ITS file system, later the TENEX filesystem for the PDP-10 in 1972.\nLater lists of files including their versions were added, and dependencies amongst them. Linux distributions like Debian, with its dpkg, early on created package management software which could resolve dependencies between their packages. Debian's first try was that a package knew other packages which depended on it. From 1994 on this idea was inverted, so a package that knew the packages it needed. When installing a package, dependency resolution was used to automatically calculate the packages needed as well, and install them with the desired package. To facilitate upgrades, minimum package versions were introduced. Thus the numbering scheme needed to tell which version was newer than the required one.[\nSchemes\nBased on sequence identifiers\nIn sequence-based software versioning schemes, each software release is assigned a unique identifier that consists of one or more sequences of numbers or letters. This is the extent of the commonality; schemes vary widely in areas such as the number of sequences, the attribution of meaning to individual sequences, and the means of incrementing the sequences.\nChange significance\nIn some schemes, sequence-based identifiers are used to convey the significance of changes between releases. Changes are classified by significance level, and the decision of which sequence to change between releases is based on the significance of the changes from the previous release, whereby the first sequence is changed for the most significant changes, and changes to sequences after the first represent changes of decreasing significance.\nDepending on the scheme, significance may be assessed by lines of code changed, function points added or removed, the potential impact on customers in terms of work required to adopt a new version, risk of bugs or undeclared breaking changes, degree of changes in visual layout, the number of new features, or almost anything the product developers or marketers deem to be significant, including marketing desire to stress the \"relative goodness\" of the new version.\nSemantic versioning\n(aka SemVer) is a widely adopted version scheme that encodes a version by a three-part version number (Major.Minor.Patch), an optional pre-release tag, and an optional build meta tag. In this scheme, risk and functionality are the measures of significance. Breaking changes are indicated by increasing the major number (high risk); new, non-breaking features increment the minor number (medium risk); and all other non-breaking changes increment the patch number (lowest risk). The presence of a pre-release tag (-alpha, -beta) indicates substantial risk, as does a major number of zero (0.y.z), which is used to indicate a work-in-progress that may contain any level of potentially breaking changes (highest risk). As an example of inferring compatibility from a SemVer version, software which relies on version 2.1.5 of an API is compatible with version 2.2.3, but not necessarily with 3.2.4.\nOther schemes\nA fourth number may also be used to denote the software build, as was the case for Adobe Flash. Some companies also include the build date and letters and other characters, such as Lotus 1-2-3 Release 1a.\nDevelopers may choose to jump multiple minor versions at a time to indicate that significant features have been added, but are not enough to warrant incrementing a major version number; for example, Internet Explorer 5 from 5.1 to 5.5 or Adobe Photoshop 5 to 5.5. This may be done to emphasize the value of the upgrade to the software user or, as in Adobe's case, to represent a release halfway between major versions (although levels of sequence-based versioning are not necessarily limited to a single digit, as in Blender version 2.91 or Minecraft Java Edition starting from 1.7.10).\nA different approach is to use the major and minor numbers along with an alphanumeric string denoting the release type, e.g. \"alpha\" (a), \"beta\" (b), or \"release candidate\" (rc). A software release train using this approach might look like 0.5, 0.6, 0.7, 0.8, 0.9 → 1.0b1, 1.0b2 (with some fixes), 1.0b3 (with more fixes) → 1.0rc1 (if it is stable enough), 1.0rc2 (if more bugs are found) → 1.0. It is a common practice in this scheme to lock out new features and breaking changes during the release candidate phases and, for some teams, even betas are locked down to bug fixes only, to ensure convergence on the target release.\nOther schemes impart meaning on individual sequences:\n: (example: 1.2.12.102)\n: (example: 1.4.3.5249)\nAgain, in these examples, the definition of what constitutes a \"major\" as opposed to a \"minor\" change is entirely subjective and up to the author, as is what defines a \"build\", or how a \"revision\" differs from a \"minor\" change.\nShared libraries in Linux and Solaris may use the  format where:\n:current: The most recent interface number that the library implements.\n:revision: The implementation number of the current interface.\n:age: The difference between the newest and oldest interfaces that the library implements. This use of the third field is specific to libtool: others may use a different meaning or simply ignore it.\nA similar problem of relative change significance and versioning nomenclature exists in book publishing, where edition numbers or names can be chosen based on varying criteria.\nIn most proprietary software, the first released version of a software product has version 1.\nDegree of compatibility\nSome projects use the major version number to indicate incompatible releases. Two examples are Apache Portable Runtime (APR) and the FarCry CMS.\nOften programmers write new software to be backward compatible. For example, IBM z/OS is designed to work properly with 3 consecutive major versions of the operating system running in the same sysplex. This enables people who run a high availability computer cluster to keep most of the computers up and running while one machine at a time is shut down, upgraded, and restored to service.\nOften packet headers and file format include a version number – sometimes the same as the version number of the software that wrote it; other times a \"protocol version number\" independent of the software version number. The code to handle old deprecated protocols and file formats is often seen as cruft.\nDesignating development stage\nSoftware in the experimental stage (alpha or beta) often uses a zero in the first (\"major\") position of the sequence to designate its status. However, this scheme is only useful for the early stages, not for upcoming releases with established software where the version number has already progressed past 0.\nA number of schemes are used to denote the status of a newer release:\n* Alphanumeric suffix is a common scheme adopted by semantic versioning. In this scheme, versions have affixed a dash plus some alphanumeric characters to indicate the status.\n* Numeric status is a scheme that uses numbers to indicate the status as if it's part of the sequence. A typical choice is the third position for the four-position versioning.\n* Numeric 90+ is another scheme that uses numbers, but apparently under a number of a previous version. A large number in the last position, typically 90 or higher, is used. This is commonly used by older open-source projects like Fontconfig.\n{| class=\"wikitable\"\n|+ Comparison of development stage indicators\n|-\n! Developmentstage !! Semanticversioning !! Numericstatus !! Numeric90+\n|-\n| Alpha || 1.2.0-a.1 || 1.2.0.1 || 1.1.90\n|-\n| Beta  || 1.2.0-b.2 || 1.2.1.2 || 1.1.93\n|-\n| Release candidate (RC) || 1.2.0-rc.3 || 1.2.2.3 || 1.1.97\n|-\n| Release || 1.2.0 || 1.2.3.0 || 1.2.0\n|-\n| Post-release fixes || 1.2.5 || 1.2.3.5 || 1.2.5\n|}\nThe two purely numeric forms remove the special logic required to handle the comparison of \"alpha &lt; beta &lt; rc &lt; no prefix\" as found in semantic versioning, at the cost of clarity.\nMost free and open-source software packages, including MediaWiki, treat versions as a series of individual numbers, separated by periods, with a progression such as 1.7.0, 1.8.0, 1.8.1, 1.9.0, 1.10.0, 1.11.0, 1.11.1, 1.11.2, and so on. On the other hand, some software packages identify releases by decimal numbers: 1.7, 1.8, 1.81, 1.82, 1.9, etc. Decimal versions were common in the 1980s, for example with NetWare, DOS, and Microsoft Windows, but even in the 2000s have been for example used by Opera and Movable Type. In the decimal scheme, 1.81 is the minor version following 1.8, while maintenance releases (i.e. bug fixes only) may be denoted with an alphabetic suffix, such as 1.81a or 1.81b.\nThe standard GNU version numbering scheme is major.minor.revision, but Emacs is a notable example using another scheme where the major number (1) was dropped and a user site revision was added which is always zero in original Emacs packages but increased by distributors. Similarly, Debian package numbers are prefixed with an optional \"epoch\", which is used to allow the versioning scheme to be changed.\nIn some cases, developers may decide to reset the major version number. This is sometimes used to denote a new development phase being released. For example, Minecraft Alpha ran from version 1.0.0 to 1.2.6, and when Beta was released, it reset the major version number and ran from 1.0 to 1.8. Once the game was fully released, the major version number again reset to 1.0.0.\nFormat\nSome projects use negative version numbers. One example is the SmartEiffel compiler which started from −1.0 and counted upwards to 0.0.\nTo ease sorting, some software packages represent each component of the major.minor.release scheme with a fixed width. Perl represents its version numbers as a floating-point number; for example, Perl's 5.8.7 release can also be represented as 5.008007. This allows a theoretical version of 5.8.10 to be represented as 5.008010. Other software packages pack each segment into a fixed bit width; for example, on Microsoft Windows, version number 6.3.9600.16384 would be represented as hexadecimal 0x0006000325804000. The floating-point scheme breaks down if any segment of the version number exceeds 999; a packed-binary scheme employing 16 bits apiece breaks down after 65535.\nBetween the 1.0 and the 2.6.x series, the Linux kernel used odd minor version numbers to denote development releases and even minor version numbers to denote stable releases. For example, Linux 2.3 was a development family of the second major design of the Linux kernel, and Linux 2.4 was the stable release family that Linux 2.3 matured into. After the minor version number in the Linux kernel is the release number, in ascending order; for example, Linux 2.4.0 → Linux 2.4.22. Since the 2004 release of the 2.6 kernel, Linux no longer uses this system, and has a much shorter release cycle.\nThe same odd-even system is used by some other software with long release cycles, such as Node.js up to version 0.12 as well as WineHQ.\nBased on date of release identifiers\nshowing release number in CalVer format: \"961219 USA\"]]\nMany projects use a date-based versioning scheme called Calendar Versioning (aka CalVer).\nUbuntu is one example of a project using calendar versioning; Ubuntu 18.04, for example, was released in April 2018. This has the advantage of being easily relatable to development schedules and support timelines. Some video games also use date as versioning, for example the arcade game Street Fighter EX. At startup it displays the version number as a date plus a region code, for example 961219 ASIA.\nWhen using dates in versioning, for instance, file names, it is common to use the ISO 8601 scheme YYYY-MM-DD, as this is easily string-sorted in increasing or decreasing order. The hyphens are sometimes omitted. The Wine project formerly used a date versioning scheme, which used the year followed by the month followed by the day of the release; for example, \"Wine 20040505\". The earliest development builds of Minecraft had a similar version formatting, but instead used DDHHMM, for example rd-131655 was created on the 13th (of May 2009) at 16:21.\nMicrosoft Office build numbers are an encoded date: the first two digits indicate the number of months that have passed from the January of the year in which the project started (with each major Office release being a different project), while the last two digits indicate the day of that month. So 3419 is the 19th day of the 34th month after the month of January of the year the project started.\nOther examples that identify versions by year include Adobe Illustrator 88 and WordPerfect Office 2003. When a year is used to denote version, it is generally for marketing purposes, and an actual version number also exists. For example, Windows 95 is internally versioned as MS-DOS 7.00 and Windows 4.00; likewise, Windows 2000 is internally versioned as NT 5.0.\nOther schemes\nSome software producers use different schemes to denote releases of their software. The Debian project uses a major/minor versioning scheme for releases of its operating system but uses code names from the movie Toy Story during development to refer to stable, unstable, and testing releases.\nBLAG Linux and GNU features very large version numbers: major releases have numbers such as 50000 and 60000, while minor releases increase the number by 1 (e.g. 50001, 50002). Alpha and beta releases are given decimal version numbers slightly less than the major release number, such as 19999.00071 for alpha 1 of version 20000, and 29999.50000 for beta 2 of version 30000. Starting at 9001 in 2003, the most recent version  is 140000.\nUrbit uses Kelvin versioning (named after the absolute Kelvin temperature scale): software versions start at a high number and count down to version 0, at which point the software is considered finished and no further modifications are made.\nPre-release versions\nIn conjunction with the various versioning schemes listed above, a system for denoting pre-release versions is generally used, as the program makes its way through the stages of the software release life cycle.\nPrograms that are in an early stage are often called \"alpha\" software, after the first letter in the Greek alphabet. After they mature but are not yet ready for release, they may be called \"beta\" software, after the second letter in the Greek alphabet. Generally alpha software is tested by developers only, while beta software is distributed for community testing.\nSome systems use numerical versions less than 1 (such as 0.9), to suggest their approach toward a final \"1.0\" release. This is a common convention in open source software. However, if the pre-release version is for an existing software package (e.g. version 2.5), then an \"a\" or \"alpha\" may be appended to the version number. So the alpha version of the 2.5 release might be identified as 2.5a or 2.5.a.\nAn alternative is to refer to pre-release versions as \"release candidates\", so that software packages which are soon to be released as a particular version may carry that version tag followed by \"rc-#\", indicating the number of the release candidate; when the final version is released, the \"rc\" tag is removed.\nSignificance\nTechnical\nIn software engineering\nVersion numbers are used in practical terms by the consumer, or client, to identify or compare their copy of the software product against another copy, such as the newest version released by the developer. For the programmer or company, versioning is often used on a revision-by-revision basis, where individual parts of the software are compared and contrasted with newer or older revisions of those same parts, often in a collaborative version control system.\nIn the 21st century, more programmers started to use a formalized version policy, such as the semantic versioning policy. The purpose of such policies is to make it easier for other programmers to know when code changes are likely to break things they have written. Such policies are especially important for software libraries and frameworks, but may also be very useful for command-line applications (which may be called from other applications) and for other applications (which may be scripted and/or extended by third parties).\nRelease train\nA software release train is a form of software release schedule in which a number of distinct series of versioned software releases for multiple products are released as a number of different \"trains\" on a regular schedule. Generally, for each product line, a number of different release trains are running at a given time, with each train moving from initial release to eventual maturity and retirement on a planned schedule. Users may experiment with a newer release train before adopting it for production, allowing them to experiment with newer, \"raw\", releases early, while continuing to follow the previous train's point releases for their production systems prior to moving to the new release train as it becomes mature.\nCisco's IOS software platform used a release train schedule with many distinct trains for many years. More recently, a number of other platforms including Firefox and Fenix for Android, Eclipse, LibreOffice, Ubuntu, Fedora, Python, digiKam and VMware have adopted the release train model.\nInternal version numbers\nSoftware may have an \"internal\" version number which differs from the version number shown in the product name (and which typically follows version numbering rules more consistently). Java SE 5.0, for example, has the internal version number of 1.5.0, and versions of Windows from NT 4 on have continued the standard numerical versions internally: Windows 2000 is NT 5.0, XP is Windows NT 5.1, Windows Server 2003 and Windows XP Professional x64 Edition are NT 5.2, Windows Server 2008 and Vista are NT 6.0, Windows Server 2008 R2 and Windows 7 are NT 6.1, Windows Server 2012 and Windows 8 are NT 6.2, and Windows Server 2012 R2 and Windows 8.1 are NT 6.3. Windows 10 was initially intended to be NT 6.4, as the earliest Technical Preview build shared to the public is numbered 6.4.9841. However, that did not last as the version of Windows 10 was quickly artificially increased to 10.0 to align with the commercial name, resulting in the first released version of the operating system being numbered 10.0.10240. Note, however, that Windows NT is only on its fifth major revision, as its first release was numbered 3.1 (to match the then-current Windows release number) and the Windows 10 launching made a version leap from 6.3 to 10.0.\nMarketing\nA relatively common practice is to make major jumps in version numbers for marketing reasons. Sometimes software vendors just bypass the 1.0 release or quickly release a release with a subsequent version number because 1.0 software is considered by many customers too immature to trust with production deployments. For example, as in the case of dBase II, a product is launched with a version number that implies that it is more mature than it is.\nOther times version numbers are increased to match those of competitors. This can be seen in many examples of product version numbering by Microsoft, America Online, Sun Solaris, Java Virtual Machine, SCO Unix, WordPerfect. Microsoft Access jumped from version 2.0 to version 7.0, to match the version number of Microsoft Word.\nMicrosoft has also been the target of \"catch-up\" versioning, with the Netscape browsers skipping version 5 to 6, in line with Microsoft's Internet Explorer, but also because the Mozilla application suite inherited version 5 in its user agent string during pre-1.0 development and Netscape 6.x was built upon Mozilla's code base. Another example of keeping up with competitors is when Slackware Linux jumped from version 4 to version 7 in 1999.\nThis approach, panned by many because it breaks the semantic significance of the sections of the version number, has been adopted by an increasing number of vendors including Mozilla (for Firefox) and Google (for Google Chrome).\nPromoting minor as major\nSun's Java has at times had a hybrid system, where the internal version number has always been 1.x but has been marketed by reference only to the x:\n* JDK 1.0.3\n* JDK 1.1.2 through 1.1.8\n* J2SE 1.2.0 (\"Java 2\") through 1.4.2\n* Java 1.5.0, 1.6.0, 1.7.0, 1.8.0 (\"Java 5, 6, 7, 8\")\nSun also dropped the first digit for Solaris, where Solaris 2.8 (or 2.9) is referred to as Solaris 8 (or 9) in marketing materials.\nA similar jump took place with the Asterisk open-source PBX construction kit in the early 2010s, whose project leads announced that the current version 1.8.x would soon be followed by version 10.\nPolitical and cultural significance of version numbers\nVersion 1.0 as a milestone\nThe free-software and open source communities tend to release software early and often. Initial versions are numbers less than 1, with these 0.x version used to convey that the software is incomplete and not reliable enough for general release or usable in its current state. Backward-incompatible changes are common with 0.x versions. Version 1.0 is used as a major milestone, indicating that the software has at least all major features plus functions the developers wanted to get into that version, and is considered reliable enough for general release. A good example of this is the Linux kernel, which was first released as version 0.01 in 1991, and took until 1994 to reach version 1.0.0.\nThe developers of the arcade game emulator MAME do not ever intend to release a version 1.0 of the program because there will always be more arcade games to emulate and thus the project can never be truly completed. Accordingly, version 0.99 was followed by version 0.100.\nSuperstition\n*The Office 2007 release of Microsoft Office had an internal version number of 12. The next version, Office 2010, has an internal version of 14, due to superstitions surrounding the number 13. Visual Studio 2013 is Version number 12.0 of the product, and the new version, Visual Studio 2015 has the Version number 14.0 for the same reasons.\n*Roxio Toast went from version 12 to version 14, likely in an effort to skip the superstitions surrounding the number 13.\n*Corel's WordPerfect Office, version 13 is marketed as \"X3\" (Roman number 10 and \"3\"). The procedure has continued into the next version, X4. The same has happened with Corel's Graphic Suite (i.e. CorelDRAW, Corel Photo-Paint) as well as its video editing software \"Video Studio\".\n*Sybase skipped major versions 13 and 14 in its Adaptive Server Enterprise relational database product, moving from 12.5 to 15.0.\n* ABBYY Lingvo Dictionary uses numbering 12, x3 (14), x5 (15).\n* SUSE Linux Enterprise skipped version 13 and 14 after version 12 and directly released SLES 15 in July 2018.\n* In the mid-1990s, the rapidly growing CMMS, Maximo, moved from Maximo Series 3 directly to Series 5, skipping Series 4 due to that number's perceived marketing difficulties in the Chinese market, where the number 4 is associated with \"death\" (see tetraphobia). This did not stop Maximo Series 5 version 4.0 from being released. (The \"Series\" versioning has since been dropped, effectively resetting version numbers after Series 5 version 1.0's release.)\nGeek culture\n* The SUSE Linux distribution started at version 4.2, to reference 42, \"the answer to the ultimate question of life, the universe and everything\" mentioned in Douglas Adams' ''The Hitchhiker's Guide to the Galaxy''.\n* A Slackware Linux distribution was versioned 13.37, referencing leet.\n* Finnix skipped from version 93.0 to 100, partly to fulfill the assertion, \"There Will Be No Finnix '95\", a reference to Windows 95.\n* The Tagged Image File Format specification has used 42 as internal version number since its inception, its designers not expecting to alter it anymore during their (or its) lifetime since it would conflict with its development directives.\nSoftware examples\nPython\nThe Python Software Foundation has published PEP 440 – Version Identification and Dependency Specification, outlining their own flexible scheme, that defines an epoch segment, a release segment, pre-release and post-release segments and a development release segment.\nTeX\nTeX has an idiosyncratic version numbering system, an unusual feature invented by its developer Donald Knuth. Since version 3.1, updates have been indicated by adding an extra digit at the end, so that the version number asymptotically approaches the number , so 3.14 effectively means 3.2 in semantic versioning. (This is a form of unary numbering; the version number is the number of digits.) Since 2021, the version number has been 3.141592653. This is a reflection of TeX being very stable, and only minor updates are anticipated. TeX developer Donald Knuth has stated that the \"absolutely final change (to be made after [his] death)\" will be to change the version number to , at which point all remaining bugs will become permanent features.\nIn a similar way, the version number of Metafont asymptotically approaches Euler's number, . As of February 2021, the version number is 2.71828182. Metafont was also devised by Donald Knuth as a companion to his TeX typesetting system.\nApple\nDuring the era of the classic Mac OS, minor version numbers rarely went beyond \".1\". When they did, they usually jumped straight to \".5\", suggesting the release was \"more significant\". Thus, \"8.5\" was marketed as its own release, representing \"Mac OS 8 and a half\", and 8.6 effectively meant \"8.5.1\".\nMac OS X departed from this trend, in large part because \"X\" (the Roman numeral for 10) was in the name of the product. As a result, all versions of OS X began with the number 10. The first major release of OS X was given the version number 10.0, but the next major release was not 11.0. Instead, it was numbered 10.1, followed by 10.2, 10.3, and so on for each subsequent major release. Thus the 11th major version of OS X was labeled \"10.10\". Even though the \"X\" was dropped from the name as of macOS 10.12, this numbering scheme continued through macOS 10.15. Under the \"X\"-based versioning scheme, the third number (instead of the second) denoted a minor release, and additional updates below this level, as well as updates to a given major version of OS X coming after the release of a new major version, were titled Supplemental Updates.\nThe Roman numeral X was concurrently leveraged for marketing purposes across multiple product lines. Both QuickTime and Final Cut Pro jumped from version 7 directly to version 10, QuickTime X and Final Cut Pro X. Like Mac OS X itself, the products were not upgrades to previous versions, but brand-new programs. As with OS X, major releases for these programs incremented the second digit and minor releases were denoted using a third digit. The \"X\" was dropped from Final Cut's name with the release of macOS 11.0 (see below), and QuickTime's branding became moot when the framework was deprecated in favor of AVFoundation in 2011 (the program for playing QuickTime video was only named QuickTime Player from the start).\nApple's next macOS release, provisionally numbered 10.16, was officially announced as macOS 11 at WWDC in June 2020, and released in November 2020. The following macOS version, macOS Monterey, was released in October 2021 and bumped its major version number to 12.\nIn June 2025, Apple announced an unified versioning scheme, using the year next to the release date, similar to model years in vehicles. The versions that were released in the fall of 2025 are iOS 26, macOS 26, iPadOS 26, tvOS 26, watchOS 26 and visionOS 26.\nMicrosoft Windows\nThe Microsoft Windows operating system was first labelled with standard version numbers for Windows 1.01 through Windows 3.2. After this Microsoft excluded the version number from the product name. For Windows 95 (version 4.0), Windows 98 (4.10) and Windows 2000 (5.0), year of the release was included in the product title. After Windows 2000, Microsoft created the Windows Server family which continued the year-based style with a difference: For minor releases, Microsoft suffixed \"R2\" to the title, e.g., Windows Server 2008 R2 (version 6.1). This style had remained consistent to this date. The client versions of Windows however did not adopt a consistent style. First, they received names with arbitrary alphanumeric suffixes as with Windows Me (4.90), Windows XP (5.1), and Windows Vista (6.0). Then, once again Microsoft adopted incremental numbers in the title, but this time, they were not versioning numbers; the version numbers of Windows 7, Windows 8 and Windows 8.1 are respectively 6.1, 6.2 and 6.3. In Windows 10, the version number leaped to 10.0 and subsequent updates to the OS only incremented build number (which is date-based) and update build revision (UBR) number.\nThe successor of Windows 10, Windows 11, was released on October 5, 2021. Despite being named \"11\", the new Windows release did not bump its major version number to 11. Instead, it stayed at the same version number of 10.0, used by Windows 10.\nNon-software use\nSome computer file systems, such as the OpenVMS Filesystem, also keep versions for files. Versioning amongst documents is relatively similar to the routine used with computers and software engineering, where with each small change in the structure, contents, or conditions, the version number is incremented by 1, or a smaller or larger value, again depending on the personal preference of the author and the size or importance of changes made.\nTechnical drawing and CAD software files may also use some kind of primitive versioning number to keep track of changes.\nSee also\n*Continuous Data Protection\n*Maintenance release\n*Product life cycle management\n*Release management\n*Release notes\n*Software engineering\nNotes\nReferences\nExternal links\n* [http://wiki.documentfoundation.org/ReleasePlan Document Foundation release plan for LibreOffice, showing release trains]"
    }
  ]
}