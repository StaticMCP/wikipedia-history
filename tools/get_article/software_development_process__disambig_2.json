{
  "content": [
    {
      "type": "text",
      "text": "# Software development process__disambig_2\n\nA software development process prescribes a process for developing software. It typically divides an overall effort into smaller steps or sub-processes that are intended to ensure high-quality results. The process may describe specific deliverables  artifacts to be created and completed.\nAlthough not strictly limited to it, software development process often refers to the high-level process that governs the development of a software system from its beginning to its end of life  known as a methodology, model or framework. The system development life cycle (SDLC) describes the typical phases that a development effort goes through from the beginning to the end of life for a system  including a software system. A methodology prescribes how engineers go about their work in order to move the system through its life cycle. A methodology is a classification of processes or a blueprint for a process that is devised for the SDLC. For example, many processes can be classified as a spiral model.\nSoftware process and software quality are closely interrelated; some unexpected facets and effects have been observed in practice.\nMethodology\nThe SDLC drives the definition of a methodology in that a methodology must address the phases of the SDLC. Generally, a methodology is designed to result in a high-quality system that meets or exceeds expectations (requirements) and is delivered on time and within budget even though computer systems can be complex and integrate disparate components. Various methodologies have been devised, including waterfall, spiral, agile, rapid prototyping, incremental, and synchronize and stabilize.\nA major difference between methodologies is the degree to which the phases are sequential vs. iterative. Agile methodologies, such as XP and scrum, focus on lightweight processes that allow for rapid changes. Iterative methodologies, such as Rational Unified Process and dynamic systems development method, focus on stabilizing project scope and iteratively expanding or improving products. Sequential or big-design-up-front (BDUF) models, such as waterfall, focus on complete and correct planning to guide larger projects and limit risks to successful and predictable results. Anamorphic development is guided by project scope and adaptive iterations. In scrum, for example, one could say a single user story goes through all the phases of the SDLC within a two-week sprint. By contrast the waterfall methodology, where every business requirement is translated into feature/functional descriptions which are then all implemented typically over a period of months or longer.\nA project can include both a project life cycle (PLC) and an SDLC, which describe different activities. According to Taylor (2004), \"the project life cycle encompasses all the activities of the project, while the systems development life cycle focuses on realizing the product requirements\".\nHistory\nThe term SDLC is often used as an abbreviated version of SDLC methodology. Further, some use SDLC and traditional SDLC to mean the waterfall methodology.\nAccording to Elliott (2004), SDLC \"originated in the 1960s, to develop large scale functional business systems in an age of large scale business conglomerates. Information systems activities revolved around heavy data processing and number crunching routines\". The structured systems analysis and design method (SSADM) was produced for the UK government Office of Government Commerce in the 1980s. Ever since, according to Elliott (2004), \"the traditional life cycle approaches to systems development have been increasingly replaced with alternative approaches and frameworks, which attempted to overcome some of the inherent deficiencies of the traditional SDLC\". The main idea of the SDLC has been \"to pursue the development of information systems in a very deliberate, structured and methodical way, requiring each stage of the life cycle––from the inception of the idea to delivery of the final system––to be carried out rigidly and sequentially\" within the context of the framework being applied.\nOther methodologies were devised later:\n; 1970s\n* Structured programming since 1969\n* Cap Gemini SDM, originally from PANDATA, the first English translation was published in 1974. SDM stands for System Development Methodology\n; 1980s\n* Structured systems analysis and design method (SSADM) from 1980 onwards\n* Information Requirement Analysis/Soft systems methodology\n; 1990s\n* Object-oriented programming (OOP) developed in the early 1960s and became a dominant programming approach during the mid-1990s\n* Rapid application development (RAD), since 1991\n* Dynamic systems development method (DSDM), since 1994\n* Scrum, since 1995\n* Team software process, since 1998\n* Rational Unified Process (RUP), maintained by IBM since 1998\n* Extreme programming, since 1999\n; 2000s\n* Agile Unified Process (AUP) maintained since 2005 by Scott Ambler\n* Disciplined agile delivery (DAD) Supersedes AUP\n; 2010s\n* Scaled Agile Framework (SAFe)\n* Large-Scale Scrum (LeSS)\n* DevOps\nSince DSDM in 1994, all of the methodologies on the above list except RUP have been agile methodologies - yet many organizations, especially governments, still use pre-agile processes (often waterfall or similar).\nExamples\nThe following are notable methodologies somewhat ordered by popularity.\n; Agile\nAgile software development refers to a group of frameworks based on iterative development, where requirements and solutions evolve via collaboration between self-organizing cross-functional teams. The term was coined in the year 2001 when the Agile Manifesto was formulated.\n; Waterfall\nThe waterfall model is a sequential development approach, in which development flows one-way (like a waterfall) through the SDLC phases.\n; Spiral\nIn 1988, Barry Boehm published a software system development spiral model, which combines key aspects of the waterfall model and  rapid prototyping, in an effort to combine advantages of  top-down and bottom-up concepts. It emphases a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems.\n; Incremental\nVarious methods combine linear and iterative methodologies, with the primary objective of reducing inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process.\n; Prototyping\nSoftware prototyping is about creating prototypes, i.e. incomplete versions of the software program being developed.\n; Rapid\nRapid application development (RAD) is a methodology which favors iterative development and the rapid construction of prototypes instead of large amounts of up-front planning. The \"planning\" of software developed using RAD is interleaved with writing the software itself. The lack of extensive pre-planning generally allows software to be written much faster and makes it easier to change requirements.\n; Shape Up\nShape Up is a software development approach introduced by Basecamp in 2018. It is a set of principles and techniques that Basecamp developed internally to overcome the problem of projects dragging on with no clear end. Its primary target audience is remote teams. Shape Up has no estimation and velocity tracking, backlogs, or sprints, unlike waterfall, agile, or scrum. Instead, those concepts are replaced with appetite, betting, and cycles. As of 2022, besides Basecamp, notable organizations that have adopted Shape Up include UserVoice and Block.\n; Chaos\nChaos model has one main rule: always resolve the most important issue first.\n; Incremental funding\nIncremental funding methodology - an iterative approach.\n; Lightweight\nLightweight methodology - a general term for methods that only have a few rules and practices.\n; Structured systems analysis and design\nStructured systems analysis and design method - a specific version of waterfall.\n; Slow programming\nAs part of the larger slow movement, emphasizes careful and gradual work without (or minimal) time pressures. Slow programming aims to avoid bugs and overly quick release schedules.\n; V-Model\nV-Model (software development) - an extension of the waterfall model.\n; Unified Process\nUnified Process (UP) is an iterative software development methodology framework, based on Unified Modeling Language (UML). UP organizes the development of software into four phases, each consisting of one or more executable iterations of the software at that stage of development: inception, elaboration, construction, and guidelines.\nComparison\nThe waterfall model describes the SDLC phases such that each builds on the result of the previous one. Not every project requires that the phases be sequential. For relatively simple projects, phases may be combined or overlapping. Alternative methodologies to waterfall are described and compared below.\n{| class=\"wikitable\" style=\"margin:auto;\"\n|+ Comparison of methodologies\n|-\n! style=\"width:5%;\"|\n!| Waterfall\n!|  RAD\n!|  Open source\n!| OOP\n!|  JAD\n!|  proto-typing\n!|  End User\n|-\n| Control\n| Formal\n| MIS\n| Weak\n| Standards\n| Joint\n| User\n| User\n|-\n| Time frame\n| Long\n| Short\n| Medium\n| Any\n| Medium\n| Short\n| Short\n–\n|-\n| Users\n| Many\n| Few\n| Few\n| Varies\n| Few\n| One or two\n| One\n|-\n| MIS staff\n| Many\n| Few\n| Hundreds\n| Split\n| Few\n| One or two\n| None\n|-\n| Transaction/DSS\n| Transaction\n| Both\n| Both\n| Both\n| DSS\n| DSS\n| DSS\n|-\n| Interface\n| Minimal\n| Minimal\n| Weak\n| Windows\n| Crucial\n| Crucial\n| Crucial\n|-\n| Documentation and training\n| Vital\n| Limited\n| Internal\n| In Objects\n| Limited\n| Weak\n| None\n|-\n| Integrity and security\n| Vital\n| Vital\n| Unknown\n| In Objects\n| Limited\n| Weak\n| Weak\n|-\n| Reusability\n| Limited\n| Some\n| Maybe\n| Vital\n| Limited\n| Weak\n| None\n|}\nProcess meta-models\nSome process models are abstract descriptions for evaluating, comparing, and improving the specific process adopted by an organization.\n; ISO/IEC 12207\nISO/IEC 12207 is the international standard describing the method to select, implement, and monitor the life cycle for software.\n; Capability Maturity Model Integration\nThe Capability Maturity Model Integration (CMMI) is one of the leading models and is based on best practices. Independent assessments grade organizations on how well they follow their defined processes, not on the quality of those processes or the software produced. CMMI has replaced CMM.\n; ISO 9000\nISO 9000 describes standards for a formally organized process to manufacture a product and the methods of managing and monitoring progress. Although the standard was originally created for the manufacturing sector, ISO 9000 standards have been applied to software development as well. Like CMMI, certification with ISO 9000 does not guarantee the quality of the end result, only that formalized business processes have been followed.\n; ISO/IEC 15504\nISO/IEC 15504 Information technology—Process assessment, a.k.a. Software Process Improvement Capability Determination (SPICE), is a framework for the assessment of software processes. This standard is aimed at setting out a clear model for process comparison. SPICE is used much like CMMI. It models processes to manage, control, guide, and monitor software development. This model is then used to measure what a development organization or project team actually does during software development. This information is analyzed to identify weaknesses and drive improvement. It also identifies strengths that can be continued or integrated into common practice for that organization or team.\n; ISO/IEC 24744\nISO/IEC 24744 Software Engineering—Metamodel for Development Methodologies, is a power type-based metamodel for software development methodologies.\n; Soft systems methodology\nSoft systems methodology is a general method for improving management processes.\n; Method engineering\nMethod engineering is a general method for improving information system processes.\nSee also\n* Computer-aided software engineering\n* List of software development philosophies\n* Outline of software engineering\n* Software development effort estimation\n* Software documentation\n* Software project management\n* Software release life cycle\nReferences\nExternal links\n* [http://www.cms.gov/Research-Statistics-Data-and-Systems/CMS-Information-Technology/XLC/Downloads/SelectingDevelopmentApproach.pdf Selecting a development approach]  at cms.hhs.gov.\n* Gerhard Fischer, [http://l3d.cs.colorado.edu/~gerhard/papers/isfst2001.pdf \"The Software Technology of the 21st Century: From Software Reuse to Collaborative Software Design\"] , 2001"
    }
  ]
}