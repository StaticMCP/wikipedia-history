{
  "content": [
    {
      "type": "text",
      "text": "# Non-blocking linked list\n\nA non-blocking linked list is an example of non-blocking data structures designed to implement a linked list in shared memory using synchronization primitives:\n* Compare-and-swap\n* Fetch-and-add\n* Load-link/store-conditional\nSeveral strategies for implementing non-blocking lists have been suggested.\nReview: linked lists\n(Singly) linked lists are fundamental data structures that are widely used as is, or to build other data structures. They consist of \"nodes\", or \"links\", that are put in some order indicated by a \"next\" pointer on each node. The last node in the list (the \"tail\") has a  next pointer. The first node (the \"head\") is a sentinel: it stores no interesting information and is only used for its  pointer.\nThe operations that must be supported on lists are as follows.\n* Given a node  that is not yet part of the list, and a pointer  to a node in the list (perhaps the head), insert  after .\n* Given a pointer , delete  from the list.\nBoth operations must support concurrent use: two or more threads of execution must be able to perform insertions and deletions without interfering with each other's work (see diagram).\nHarris's solution\nIn a 2001 paper, Harris gives a solution to concurrent maintenance of ordered linked list that is non-blocking, using a compare-and-swap () primitive. Insertion of  after  is simple:\n#\n#\n#\n# If the  was not successful, go back to 1.\nDeletion of  is more involved. The naive solution of resetting this pointer with a single CAS runs the risk of losing data when another thread is simultaneously inserting (see diagram). This is specific case of the ABA problem. Instead, two invocations of  are needed for a correct algorithm. The first marks the pointer  as deleted, changing its value but in such a way that the original pointer can still be reconstructed. The second actually deletes the node by resetting .\nOperations on lock-free linked lists\nInsert\n*search for the right spot in the list\n*insert using Compare-and-swap\nDelete (Naive approach)\n*search for the right spot in the list\n*delete using Compare-and-swap\nContains\n*search for a specific value in the list and return whether it is present or not\n*this is a read only operation, does not pose any concurrency issues\nProblems\nConcurrent insert and delete\n*a process deleting node B requires an atomic action on the node's predecessor\n*  concurrently another process tries to insert a node C after node B (B.next=C)\n* node B is deleted from the list but C is gone along with it\nSolutions\n* Harris\n** place a 'mark'  in the next pointer of the soon-to-be deleted node\n** fail when we try to CAS the 'mark'\n** when detected go back to start of the list and restart\n* Zhang et al.\n** search the list to see if the value to be deleted exists, if exists mark the node logically deleted\n** a subsequent traversal of the list will do garbage collection of logically deleted nodes\nConcurrent deletions\n* two processes concurrently delete an adjacent node: node B and node C respectively\n* the delete of node C is undone by the delete of node B\nSolutions\nValois\n* make use of auxiliary nodes which contain only a next field\n* each regular node must have an auxiliary node as its predecessor and successor\n* deletion will result in an extra auxiliary node being left behind, which means the delete will have to keep trying to clean up the extra auxiliary nodes\n* use an extra 'back_link' field so the delete operation can traverse back to a node that has not been deleted from the list\nFurther reading\n* High Performance Dynamic Lock-Free Hash Tables and List-Based Sets, Maged M. Michael\n*\n* Two-handed emulation: how to build non-blocking implementations of complex data-structures using DCAS, Michael Greewald\n* Highly-Concurrent Multi-word Synchronization, Hagit Attiya, Eshcar Hillel\n* Lock-free deques and doubly linked lists, HÃ¥kan Sundell, Philippas Tsigas\nReferences"
    }
  ]
}