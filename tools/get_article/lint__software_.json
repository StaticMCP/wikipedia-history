{
  "content": [
    {
      "type": "text",
      "text": "# Lint (software)\n\n| latest release version =\n| latest release date    =\n| operating system       = Cross-platform\n| language = English\n| genre                  = Static program analysis tools\n| license                = Originally proprietary commercial software, now free software under a BSD-like license\n| website                =\n| programming language   = C\n}}\nLint is the computer science term for a static code analysis tool used to flag programming errors, bugs, stylistic errors and suspicious constructs. The term originates from a Unix utility that examined C language source code.  A program which performs this function is also known as a \"linter\" or \"linting tool\".\nHistory\nStephen C. Johnson, a computer scientist at Bell Labs, came up with the term \"lint\" in 1978 while debugging the yacc grammar he was writing for C and dealing with portability issues stemming from porting Unix to a 32-bit machine. The term was borrowed from the word lint, the tiny bits of fiber and fluff shed by clothing, as the command he wrote would act like a lint trap in a clothes dryer, capturing waste fibers while leaving whole fabrics intact. In 1979, lint programming was used outside of Bell Labs for the first time, in the seventh version (V7) of Unix.\nOver the years, different versions of lint have been developed for many C and C++ compilers, and while modern-day compilers have lint-like functions, lint-like tools have also advanced their capabilities. For example, Gimpel's PC-Lint, introduced in 1985 and used to analyze C++ source code, is still for sale.\nOverview\nIn his original 1978 paper Johnson stated his reasoning in creating a separate program to detect errors, distinct from that which it analyzed: \"...the general notion of having two programs is a good one\" [because they concentrate on different things, thereby allowing the programmer to] \"concentrate at one stage of the programming process solely on the algorithms, data structures, and correctness of the program, and then later retrofit, with the aid of lint, the desirable properties of universality and portability\".\nSuccessor linters\nThe analysis performed by lint-like tools can also be performed by an optimizing compiler, which aims to generate faster code.  Even though modern compilers have evolved to include many of lint's historical functions, lint-like tools have also evolved to detect an even wider variety of suspicious constructs. These include \"warnings about syntax errors, uses of undeclared variables, calls to deprecated functions, spacing and formatting conventions, misuse of scope, implicit fallthrough in switch statements, missing license headers, [and]...dangerous language features\".\nLint-like tools are especially useful for dynamically typed languages like JavaScript and Python. Because the interpreters of such languages typically do not enforce as many and as strict rules during execution, linter tools can also be used as simple debuggers for finding common errors (e.g. syntactic discrepancies) as well as hard-to-find errors such as heisenbugs (drawing attention to suspicious code as \"possible errors\"). Lint-like tools generally perform static analysis of source code.\nLint-like tools have also been developed for other aspects of software development, such as enforcing grammar and style guides for given language source code. Some tools (such as ESLint) also allow rules to be auto-fixable: a rule definition can also come with the definition of a transform that resolves the warning. Rules about style are especially likely to come with an auto-fix. If the linter is run in \"fix all\" mode on a file that triggers only rules about formatting, the linter will act just like a formatter.\nSee also\n*Splint (programming tool)\n*List of tools for static code analysis\nReferences\nFurther reading\n*\n*"
    }
  ]
}