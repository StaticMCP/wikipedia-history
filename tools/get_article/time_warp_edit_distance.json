{
  "content": [
    {
      "type": "text",
      "text": "# Time Warp Edit Distance\n\nIn the data analysis of time series, Time Warp Edit Distance (TWED) is a measure of similarity (or dissimilarity) between pairs of discrete time series, controlling the relative distortion of the time units of the two series using the physical notion of elasticity. In comparison to other distance measures, (e.g. DTW (dynamic time warping) or  LCS (longest common subsequence problem)), TWED is a metric. Its computational time complexity is O(n^2), but can be drastically reduced in some specific situations by using a corridor to reduce the search space. Its memory space complexity can be reduced to O(n). It was first proposed in 2009 by P.-F. Marteau.\nDefinition\n\\delta_{\\lambda,\\nu}(A^p_1,B^q_1) = Min\n\\begin{cases}\n\\delta_{\\lambda,\\nu}(A^{p-1}_1,B^q_1) + \\Gamma(a^{'}_p \\to \\Lambda) & \\rm{delete \\ in \\ A} \\\\\n\\delta_{\\lambda,\\nu}(A^{p-1}_1,B^{q-1}_1) + \\Gamma(a^{'}_p \\to b^{'}_q) & \\rm{match \\ or \\ substitution}\\\\\n\\delta_{\\lambda,\\nu}(A^{p}_1,B^{q-1}_1) + \\Gamma(\\Lambda \\to b^{'}_q) & \\rm{delete \\ in \\ B}\n\\end{cases}\nwhereas\n\\Gamma(\\alpha^{'}_p \\to \\Lambda) = d_{LP}(a^{'}_{p}, a^{'}_{p-1}) + \\nu \\cdot (t_{a_p} - t_{a_{p-1}}) + \\lambda\n\\Gamma(\\alpha^{'}_p \\to b^{'}_q) = d_{LP}(a^{'}_p, b^{'}_q) + d_{LP}(a^{'}_{p-1}, b^{'}_{q-1}) + \\nu \\cdot (|t_{a_p} - t_{b_q}| + |t_{a_{p-1}} - t_{b_{q-1}}|)\n\\Gamma(\\Lambda \\to b^{'}_q) = d_{LP}(b^{'}_{p}, b^{'}_{p-1}) + \\nu \\cdot (t_{b_q} - t_{b_{q-1}}) + \\lambda\nWhereas the recursion\n\\delta_{\\lambda,\\nu}\nis initialized as:\n\\delta_{\\lambda,\\nu}(A^0_1,B^0_1) = 0,\n\\delta_{\\lambda,\\nu}(A^0_1,B^j_1) = \\infty\\ \\rm{for\\ }j \\ge 1\n\\delta_{\\lambda,\\nu}(A^i_1,B^0_1) = \\infty\\ \\rm{for\\ }i \\ge 1\nwith\na'_0 = b'_0 = 0\nImplementations\nAn implementation of the TWED algorithm in C with a Python wrapper is available at\nTWED is also implemented into the Time Series Subsequence Search Python package (TSSEARCH for short) available at [https://github.com/fraunhoferportugal/tssearch/blob/main/docs/index.rst].\nAn R implementation of TWED has been integrated into the TraMineR, a R package for mining, describing and visualizing sequences of states or events, and more generally discrete sequence data.\nAdditionally, [https://github.com/garrettwrong/cuTWED cuTWED] is a CUDA- accelerated implementation of TWED which uses an improved algorithm due to G. Wright (2020). This method is linear in memory and massively parallelized.  cuTWED is written in CUDA C/C++, comes with Python bindings, and also includes Python bindings for Marteau's reference C implementation.\nPython\nimport numpy as np\ndef dlp(A, B, p=2):\ncost = np.sum(np.power(np.abs(A - B), p))\nreturn np.power(cost, 1 / p)\ndef twed(A, timeSA, B, timeSB, nu, _lambda):\n\"\"\"Compute Time Warp Edit Distance (TWED) for given time series A and B.\"\"\"\n# [distance, DP] = TWED(A, timeSA, B, timeSB, lambda, nu)\n#\n# A      := Time series A (e.g. [ 10 2 30 4])\n# timeSA := Time stamp of time series A (e.g. 1:4)\n# B      := Time series B\n# timeSB := Time stamp of time series B\n# lambda := Penalty for deletion operation\n# nu     := Elasticity parameter - nu >=0 needed for distance measure\n# Reference :\n#    Marteau, P.; F. (2009). \"Time Warp Edit Distance with Stiffness Adjustment for Time Series Matching\".\n#    IEEE Transactions on Pattern Analysis and Machine Intelligence. 31 (2): 306â€“318. arXiv:cs/0703033\n#    http://people.irisa.fr/Pierre-Francois.Marteau/\n# Check if input arguments\nif len(A) != len(timeSA):\nprint(\"The length of A is not equal length of timeSA\")\nreturn None, None\nif len(B) != len(timeSB):\nprint(\"The length of B is not equal length of timeSB\")\nreturn None, None\nif nu\nBacktracking, to find the most cost-efficient path:\ndef backtracking(DP):\n\"\"\"Compute the most cost-efficient path.\"\"\"\n# [ best_path ] = BACKTRACKING (DP)\n# DP := DP matrix of the TWED function\nx = np.shape(DP)\ni = x[0] - 1\nj = x[1] - 1\n# The indices of the paths are save in opposite direction\n# path = np.ones((i + j, 2 )) * np.inf;\nbest_path = []\nsteps = 0\nwhile i != 0 or j != 0:\nbest_path.append((i - 1, j - 1))\nC = np.ones((3, 1)) * np.inf\n# Keep data points in both time series\nC[0] = DP[i - 1, j - 1]\n# Deletion in A\nC[1] = DP[i - 1, j]\n# Deletion in B\nC[2] = DP[i, j - 1]\n# Find the index for the lowest cost\nidx = np.argmin(C)\nif idx == 0:\n# Keep data points in both time series\ni = i - 1\nj = j - 1\nelif idx == 1:\n# Deletion in A\ni = i - 1\nj = j\nelse:\n# Deletion in B\ni = i\nj = j - 1\nsteps = steps + 1\nbest_path.append((i - 1, j - 1))\nbest_path.reverse()\nreturn best_path[1:]\nMATLAB\nfunction [distance, DP] = twed(A, timeSA, B, timeSB, lambda, nu)\n% [distance, DP] = TWED( A, timeSA, B, timeSB, lambda, nu )\n% Compute Time Warp Edit Distance (TWED) for given time series A and B\n%\n% A      := Time series A (e.g. [ 10 2 30 4])\n% timeSA := Time stamp of time series A (e.g. 1:4)\n% B      := Time series B\n% timeSB := Time stamp of time series B\n% lambda := Penalty for deletion operation\n% nu     := Elasticity parameter - nu >=0 needed for distance measure\n%\n% Code by: P.-F. Marteau - http://people.irisa.fr/Pierre-Francois.Marteau/\n% Check if input arguments\nif length(A) ~= length(timeSA)\nwarning('The length of A is not equal length of timeSA')\nreturn\nend\nif length(B) ~= length(timeSB)\nwarning('The length of B is not equal length of timeSB')\nreturn\nend\nif nu\nBacktracking, to find the most cost-efficient path:\nfunction [path] = backtracking(DP)\n% [ path ] = BACKTRACKING ( DP )\n% Compute the most cost-efficient path\n% DP := DP matrix of the TWED function\nx = size(DP);\ni = x(1);\nj = x(2);\n% The indices of the paths are save in opposite direction\npath = ones(i + j, 2) * Inf;\nsteps = 1;\nwhile (i ~= 1 || j ~= 1)\npath(steps, :) = [i; j];\nC = ones(3, 1) * inf;\n% Keep data points in both time series\nC(1) = DP(i - 1, j - 1);\n% Deletion in A\nC(2) = DP(i - 1, j);\n% Deletion in B\nC(3) = DP(i, j - 1);\n% Find the index for the lowest cost\n[~, idx] = min(C);\nswitch idx\ncase 1\n% Keep data points in both time series\ni = i - 1;\nj = j - 1;\ncase 2\n% Deletion in A\ni = i - 1;\nj = j;\ncase 3\n% Deletion in B\ni = i;\nj = j - 1;\nend\nsteps = steps + 1;\nend\npath(steps, :) = [i j];\n% Path was calculated in reversed direction.\npath = path(1:steps, :);\npath = path(end: - 1:1, :);\nend\nReferences\n*"
    }
  ]
}