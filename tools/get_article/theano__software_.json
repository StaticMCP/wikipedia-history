{
  "content": [
    {
      "type": "text",
      "text": "# Theano (software)\n\n| discontinued = yes\n| latest release version =\n| latest release date = }}\n| repo =\n| programming language = Python, CUDA\n| platform = Linux, macOS, Windows\n| genre = Machine learning library\n| license = The 3-Clause BSD License\n| website =\n}}\nTheano is a Python library and optimizing compiler for manipulating and evaluating mathematical expressions, especially matrix-valued ones.\nIn Theano, computations are expressed using a NumPy-esque syntax and compiled to run efficiently on either CPU or GPU architectures.\nHistory\nTheano is an open source project primarily developed by the Montreal Institute for Learning Algorithms (MILA) at the Université de Montréal.\nThe name of the software references the ancient philosopher Theano, long associated with the development of the golden mean.\nOn 28 September 2017, Pascal Lamblin posted a message from Yoshua Bengio, Head of MILA:  major development would cease after the 1.0 release due to competing offerings by strong industrial players. Theano 1.0.0 was then released on 15 November 2017.\nOn 17 May 2018, Chris Fonnesbeck wrote on behalf of the PyMC development team that the PyMC developers will officially assume control of Theano maintenance once the MILA development team steps down. On 29 January 2021, they started using the name Aesara for their fork of Theano.\nOn 29 Nov 2022, the PyMC development team announced that the PyMC developers will fork the Aesara project under the name PyTensor.\nSample code\nThe following code is the original Theano's example. It defines a computational graph with 2 scalars  and  of type double and an operation between them (addition) and then creates a Python function f that does the actual computation.\nimport theano\nfrom theano import tensor\n# Declare two symbolic floating-point scalars\na = tensor.dscalar()\nb = tensor.dscalar()\n# Create a simple expression\nc = a + b\n# Convert the expression into a callable object that takes (a, b)\n# values as input and computes a value for c\nf = theano.function([a, b], c)\n# Bind 1.5 to 'a', 2.5 to 'b', and evaluate 'c'\nassert 4.0  f(1.5, 2.5)\nExamples\nMatrix Multiplication (Dot Product)===\nThe following code demonstrates how to perform matrix multiplication using Theano, which is essential for linear algebra operations in many machine learning tasks.\nimport theano\nfrom theano import tensor\n# Declare two symbolic 2D arrays (matrices)\nA = tensor.dmatrix(\"A\")\nB = tensor.dmatrix(\"B\")\n# Define a matrix multiplication (dot product) operation\nC = tensor.dot(A, B)\n# Create a function that computes the result of the matrix multiplication\nf = theano.function([A, B], C)\n# Sample matrices\nA_val = [[1, 2], [3, 4]]\nB_val = [[5, 6], [7, 8]]\n# Evaluate the matrix multiplication\nresult = f(A_val, B_val)\nprint(result)\nGradient Calculation\nThe following code uses Theano to compute the gradient of a simple operation (like a neuron) with respect to its input. This is useful in training machine learning models (backpropagation).\nimport theano\nfrom theano import tensor\n# Define symbolic variables\nx = tensor.dscalar(\"x\")  # Input scalar\ny = tensor.dscalar(\"y\")  # Weight scalar\n# Define a simple function (y * x, a simple linear function)\nz = y * x\n# Compute the gradient of z with respect to x (partial derivative of z with respect to x)\ndz_dx = tensor.grad(z, x)\n# Create a function to compute the value of z and dz/dx\nf = theano.function([x, y], [z, dz_dx])\n# Sample values\nx_val = 2.0\ny_val = 3.0\n# Compute z and its gradient\nresult = f(x_val, y_val)\nprint(\"z:\", result[0])  # z = y * x = 3 * 2 = 6\nprint(\"dz/dx:\", result[1])  # dz/dx = y = 3\nBuilding a Simple Neural Network\nThe following code shows how to start building a simple neural network. This is a very basic neural network with one hidden layer.\nimport theano\nfrom theano import tensor as T\nimport numpy as np\n# Define symbolic variables for input and output\nX = T.matrix(\"X\")  # Input features\ny = T.ivector(\"y\")  # Target labels (integer vector)\n# Define the size of the layers\ninput_size = 2  # Number of input features\nhidden_size = 3  # Number of neurons in the hidden layer\noutput_size = 2  # Number of output classes\n# Initialize weights for input to hidden layer (2x3 matrix) and hidden to output (3x2 matrix)\nW1 = theano.shared(np.random.randn(input_size, hidden_size), name=\"W1\")\nb1 = theano.shared(np.zeros(hidden_size), name=\"b1\")\nW2 = theano.shared(np.random.randn(hidden_size, output_size), name=\"W2\")\nb2 = theano.shared(np.zeros(output_size), name=\"b2\")\n# Define the forward pass (hidden layer and output layer)\nhidden_output = T.nnet.sigmoid(T.dot(X, W1) + b1)  # Sigmoid activation\noutput = T.nnet.softmax(T.dot(hidden_output, W2) + b2)  # Softmax output\n# Define the cost function (cross-entropy)\ncost = T.nnet.categorical_crossentropy(output, y).mean()\n# Compute gradients\ngrad_W1, grad_b1, grad_W2, grad_b2 = T.grad(cost, [W1, b1, W2, b2])\n# Create a function to compute the cost and gradients\ntrain = theano.function(inputs=[X, y], outputs=[cost, grad_W1, grad_b1, grad_W2, grad_b2])\n# Sample input data and labels (2 features, 2 samples)\nX_val = np.array([[0.1, 0.2], [0.3, 0.4]])\ny_val = np.array([0, 1])\n# Train the network for a single step (you would iterate in practice)\ncost_val, grad_W1_val, grad_b1_val, grad_W2_val, grad_b2_val = train(X_val, y_val)\nprint(\"Cost:\", cost_val)\nprint(\"Gradients for W1:\", grad_W1_val)\nBroadcasting in Theano\nThe following code demonstrates how broadcasting works in Theano. Broadcasting allows operations between arrays of different shapes without needing to explicitly reshape them.\nimport theano\nfrom theano import tensor as T\nimport numpy as np\n# Declare symbolic arrays\nA = T.dmatrix(\"A\")\nB = T.dvector(\"B\")\n# Broadcast B to the shape of A, then add them\nC = A + B  # Broadcasting B to match the shape of A\n# Create a function to evaluate the operation\nf = theano.function([A, B], C)\n# Sample data (A is a 3x2 matrix, B is a 2-element vector)\nA_val = np.array([[1, 2], [3, 4], [5, 6]])\nB_val = np.array([10, 20])\n# Evaluate the addition with broadcasting\nresult = f(A_val, B_val)\nprint(result)\nSee also\n* Comparison of deep learning software\n* Differentiable programming\nReferences\nExternal links\n*  (GitHub)\n* [http://deeplearning.net/software/theano/ Theano] at Deep Learning, Université de Montréal"
    }
  ]
}