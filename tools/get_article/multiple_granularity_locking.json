{
  "content": [
    {
      "type": "text",
      "text": "# Multiple granularity locking\n\nIn computer science, multiple granularity locking (MGL) is a locking method used in database management systems (DBMS) and relational databases.\nIn multiple granularity locking, locks are set on objects that contain other objects. MGL exploits the hierarchical nature of the contains relationship. For example, a database may have files, which contain pages, which contain records. This can be thought of as a tree of objects, where each node contains its children. A lock on this structure (such as a shared or exclusive lock) locks the targeted node as well as all of its descendants.\nMultiple granularity locking is usually used with non-strict two-phase locking to guarantee serializability.\nLock modes\nIn addition to shared (S) locks and exclusive (X) locks from other locking schemes, like strict two-phase locking, MGL also uses intentional \"locks\", which do not directly lock a node, but instead denote the existence, or intent to add, a lock of the specified type lower in the node hierarchy.  Intentional locks include \"intention shared\" (IS), \"intention exclusive\" (IX), and the combined \"shared and intention exclusive\"  (SIX) locks. IS locks conflict with X locks, while IX locks conflict with S and X locks. The null lock (NL) is compatible with everything.\nTo lock a node in S (or X), MGL has the transaction lock on all of its ancestors with IS (or IX), so if a transaction locks a node in S (or X), no other transaction can access its ancestors in X (or S and X). This protocol is shown in the following table:\n{| class=\"wikitable\"\n| To Get || Must have on all ancestors\n|-\n| IS or S || IS or IX\n|-\n| IX, SIX or X || IX or SIX\n|}\nDetermining what level of granularity to use for locking is done by locking the finest level possible (i.e., at the lowest leaf), and then escalating these locks to higher levels in the file hierarchy to cover more records or file elements as needed in a process known as \"lock escalation\". MGL locking modes are compatible with each other as defined in the following matrix.\n{| class=\"wikitable\"\n|-\n! Mode || NL || IS || IX || S || SIX || X\n|-\n! NL\n|  ||  ||  ||  ||  ||\n|-\n! IS\n|  ||  ||  ||  ||  ||\n|-\n! IX\n|  ||  ||  ||  ||  ||\n|-\n! S\n|  ||  ||  ||  ||  ||\n|-\n! SIX\n|  ||  ||  ||  ||  ||\n|-\n! X\n|  ||  ||  ||  ||  ||\n|}\nFollowing the locking protocol and the compatibility matrix, if one transaction holds a node in S mode, no other transactions can have locked any ancestor in X mode.\nSee also\n* Atomicity (programming)\n* Concurrency control\n* Lock (computer science)\nReferences"
    }
  ]
}