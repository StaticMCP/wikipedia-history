{
  "content": [
    {
      "type": "text",
      "text": "# Software requirements__disambig_1\n\nSoftware requirements for a system are the description of what the system should do, the service or services that it provides and the constraints on its operation.  The IEEE Standard Glossary of Software Engineering Terminology defines a requirement as:\n# A condition or capability needed by a user to solve a problem or achieve an objective\n# A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed document\n# A documented representation of a condition or capability as in 1 or 2\nThe activities related to working with software requirements can broadly be broken down into elicitation, analysis, specification, and management.\nNote that the wording Software requirements is additionally used in software release notes to explain, which depending on software packages are required for a certain software to be built/installed/used.\nElicitation\nElicitation is the gathering and discovery of requirements from stakeholders and other sources.  A variety of techniques can be used such as joint application design (JAD) sessions, interviews, document analysis, focus groups, etc. Elicitation is the first step of requirements development.\nAnalysis\nAnalysis is the logical breakdown that proceeds from elicitation. Analysis involves reaching a richer and more precise understanding of each requirement and representing sets of requirements in multiple, complementary ways.\nRequirements Triage or prioritization of requirements is another activity which often follows analysis. This relates to Agile software development in the planning phase, e.g. by Planning poker, however it might not be the same depending on the context and nature of the project and requirements or product/service that is being built.\nSpecification\nSpecification involves representing and storing the collected requirements knowledge in a persistent and well-organized fashion that facilitates effective communication and change management. Use cases, user stories, functional requirements, and visual analysis models are popular choices for requirements specification.\nValidation\nValidation involves techniques to confirm that the correct set of requirements has been specified to build a solution that satisfies the project's business objectives.\nManagement\nRequirements change during projects and there are often many of them. Management of this change becomes paramount to ensuring that the correct software is built for the stakeholders.\nTool support for Requirements Engineering\nTools for Requirements Elicitation, Analysis and Validation\nTaking into account that these activities may involve some artifacts such as observation reports (user observation), questionnaires (interviews, surveys and polls), use cases, user stories; activities such as requirement workshops (charrettes), brainstorming, mind mapping, role-playing; and even, prototyping; software products providing some or all of these capabilities can be used to help achieve these tasks.\nThere is at least one author who advocates, explicitly, for mind mapping tools such as FreeMind; and, alternatively, for the use of specification by example tools such as Concordion.\nAdditionally, the ideas and statements resulting from these activities may be gathered and organized with wikis and other collaboration tools such as Trello.\nThe features actually implemented and standards compliance vary from product to product.\nTools for Requirements Specification\nA Software requirements specification (SRS) document might be created using general-purpose software like a word processor or one of several specialized tools. Some of these tools can import, edit, export and publish SRS documents. It may help to make SRS documents while following a standardised structure and methodology, such as ISO/IEC/IEEE 29148:2018. Likewise, software may or not use some standard to import or export requirements (such as ReqIF) or not allow these exchanges at all.\nTools for Requirements Document Verification\nTools of this kind verify if there are any errors in a requirements document according to some expected structure or standard.\nTools for Requirements Comparison\nTools of this kind compare two requirement sets according to some expected document structure and standard.\nTools for Requirements Merge and Update\nTools of this kind allow the merging and update of requirement documents.\nTools for Requirements Traceability\nTools of this kind allow tracing requirements to other artifacts such as models and source code (forward traceability) or, to previous ones such as business rules and constraints (backwards traceability).\nTools for Model-Based Software or Systems Requirement Engineering\nModel-based systems engineering (MBSE) is the formalised application of modelling to support system requirements, design, analysis, verification and validation activities beginning in the conceptual design phase and continuing throughout development and later lifecycle phases.\nIt is also possible to take a model-based approach for some stages of the requirements engineering and, a more traditional one, for others. Very many combinations might be possible.\nThe level of formality  and complexity depends on the underlying methodology involved (for instance, i* is much more formal than SysML and, even more formal than UML)\nTools for general Requirements Engineering\nTools in this category may provide some mix of the capabilities mentioned previously and others such as requirement configuration management and collaboration. The features actually implemented and standards compliance vary from product to product.\nThere are even more capable or general tools that support other stages and activities. They are classified as ALM tools.\nSee also\n*Requirement\n*Requirements engineering\n*Software requirements specification (SRS)\n*List of requirements engineering tools\n*Non-functional requirement\n*Performance requirements which are covered by Software performance testing\n*Safety requirements\n*Security requirements\nReferences\nFurther reading\n*\n*\n*\n*Burek, Paul (2008). [https://www.pmi.org/learning/library/clear-project-requirements-joint-application-design-6928 Creating clear project requirements differentiating \"what\" from \"how\"]. Conference Paper. Requirements Management, Business Analysis, Scope Management.\n*Koopman, Philip (2020). [https://users.ece.cmu.edu/~koopman/lectures/ece642_fall2020/07_Requirements.pdf Embedded Software Requirements]. Fall Lectures.\n*IEEE Xplore Search. [https://ieeexplore.ieee.org/search/searchresult.jsp?newsearch=true&queryText=software%20requirements \"Software Requirements\"]."
    }
  ]
}