{
  "content": [
    {
      "type": "text",
      "text": "# Selenium (software)__disambig_1\n\n| discontinued =\n| latest release version =\n| latest release date    = }}\n| latest preview version =\n| latest preview date =\n| programming language = Selenium Server: Java; Selenium WebDriver (works without Selenium Server), official support: JavaScript (Node.js), Python, Ruby, Java, C++ or C#\n| operating system = Cross-platform\n| platform =\n| size =\n| language =\n| language count =\n| language footnote =\n| genre = Software testing framework for web applications\n| license = Apache License 2.0\n| alexa =\n| standard =\n| AsOf =\n}}\nSelenium is an open source umbrella project for a range of tools and libraries aimed at supporting browser automation. It provides a playback tool for authoring functional tests across most modern web browsers, without the need to learn a test scripting language (Selenium IDE). It also provides a test domain-specific language (Selenese) to write tests in a number of popular programming languages, including JavaScript (Node.js), C#, Groovy, Java, C++, Perl, PHP, Python, Ruby and Scala. Selenium runs on Windows, Linux, and macOS. It is open-source software released under the Apache License 2.0.\nSelenium is an open-source automation framework for web applications, enabling testers and developers to automate browser interactions and perform functional testing. With versatile tools like WebDriver, Selenium supports various programming languages and facilitates cross-browser testing, making it a go-to choice for efficient and scalable web automation.\nHistory\nSelenium was originally developed by Jason Huggins in 2004 as an internal tool at ThoughtWorks. Huggins was later joined by other programmers and testers at ThoughtWorks, before Paul Hammant joined the team and steered the development of the second mode of operation that would later become \"Selenium Remote Control\" (RC). The tool was open sourced that year.\nIn 2005 Dan Fabulich and Nelson Sproul (with help from Pat Lightbody) made an offer to accept a series of patches that would transform Selenium-RC into what it became best known for. In the same meeting, the steering of Selenium as a project would continue as a committee, with Huggins and Hammant being the ThoughtWorks representatives.\nIn 2007, Huggins joined Google. Together with others like Jennifer Bevan, he continued with the development and stabilization of Selenium RC. At the same time, Simon Stewart at ThoughtWorks developed a superior browser automation tool called WebDriver. In 2009, after a meeting between the developers at the Google Test Automation Conference, it was decided to merge the two projects, and call the new project Selenium WebDriver, or Selenium 2.0.\nIn 2008, Philippe Hanrigou (then at ThoughtWorks) made \"Selenium Grid\", which provides a hub allowing the running of multiple Selenium tests concurrently on any number of local or remote systems, thus minimizing test execution time. Grid offered, as open source, a similar capability to the internal/private Google cloud for Selenium RC. Pat Lightbody had already made a private cloud for \"HostedQA\" which he went on to sell to Gomez, Inc.\nThe name Selenium comes from a joke made by Huggins in an email, mocking a competitor named Mercury, saying that you can cure mercury poisoning by taking selenium supplements. The others that received the email took the name and ran with it.\nComponents\nSelenium is composed of several components with each taking on a specific role in aiding the development of web application test automation.\nSelenium IDE\nSelenium IDE is a complete integrated development environment (IDE) for Selenium tests. It is implemented as a Firefox Add-On and as a Chrome Extension. It allows for recording, editing and debugging of functional tests. It was previously known as Selenium Recorder. Selenium-IDE was originally created by Shinya Kasatani and donated to the Selenium project in 2006. Selenium IDE began being actively maintained in 2018.\nScripts may be automatically recorded and edited manually providing autocompletion support and the ability to move commands around quickly. Scripts are recorded in Selenese, a special test scripting language for Selenium. Selenese provides commands for performing actions in a browser (click a link, select an option) and for retrieving data from the resulting pages. Selenese serves as the language for composing Selenium Commands, which are utilized in the testing of web applications. These commands, tailored to the HTML tags of UI elements, facilitate the verification of their existence. They guide Selenium in comprehending the specific actions or operations to execute.\nSelenium client API\nAs an alternative to writing tests in Selenese, tests can also be written in various programming languages. These tests then communicate with Selenium by calling methods in the Selenium Client API. Selenium currently provides client APIs for Java, C#, Ruby, JavaScript, R and Python.\nSelenium Remote Control\nSelenium Remote Control (RC) is a server, written in Java, that accepts commands for the browser via HTTP. RC makes it possible to write automated tests for a web application in any programming language, which allows for better integration of Selenium in existing unit test frameworks. To make writing tests easier, Selenium project currently provides client drivers for PHP, Python, Ruby, .NET, Perl and Java. The Java driver can also be used with JavaScript (via the Rhino engine). An instance of selenium RC server is needed to launch html test case - which means that the port should be different for each parallel run. However, for Java/PHP test case only one Selenium RC instance needs to be running continuously.\nSelenium Remote Control was a refactoring of Driven Selenium or Selenium B designed by Paul Hammant, credited with Jason as co-creator of Selenium. The original version directly launched a process for the browser in question, from the test language of Java, .NET, Python or Ruby. The wire protocol (called 'Selenese' in its day) was reimplemented in each language port. After the refactor by Dan Fabulich and Nelson Sproul (with help from Pat Lightbody) there was an intermediate daemon process between the driving test script and the browser. The benefits included the ability to drive remote browsers and the reduced need to port every line of code to an increasingly growing set of languages. Selenium Remote Control completely took over from the Driven Selenium code-line in 2006. The browser pattern for 'Driven'/'B' and 'RC' was response/request, which subsequently became known as Comet.\nSelenium RC served as the flagship testing framework of the entire project of selenium for a long-standing time. And significantly Selenium RC is the first and foremost automated web testing tool that enabled users to adopt their preferred programming language.\nWith the release of Selenium 2, Selenium RC has been officially deprecated in favor of Selenium WebDriver.\nSelenium WebDriver\nAt the core of Selenium is Selenium WebDriver, an interface to write instructions that work interchangeably across browsers. It is the successor to Selenium RC. Selenium WebDriver accepts commands (sent in Selenese, or via a Client API) and sends them to a browser. This is implemented through a browser-specific browser driver, which sends commands to a browser and retrieves results. Most browser drivers actually launch and access a browser application (such as Firefox, Google Chrome, Internet Explorer, Safari, or Microsoft Edge); there is also an HtmlUnit browser driver, which simulates a browser using the headless browser HtmlUnit.\nUnlike in Selenium 1, where the Selenium server was necessary to run tests, Selenium WebDriver does not need a special server to execute tests. Instead, the WebDriver directly starts a browser instance and controls it. However, Selenium Grid can be used with WebDriver to execute tests on remote systems (see below). Where possible, WebDriver uses native operating system level functionality rather than browser-based JavaScript commands to drive the browser. This bypasses problems with subtle differences between native and JavaScript commands, including security restrictions.\nAs of early 2012, Simon Stewart (inventor of WebDriver), who was then with Google, and David Burns of Mozilla were negotiating with the W3C to make WebDriver an Internet standard. In July 2012, the working draft was released and the recommendation followed in June 2018. Selenium WebDriver (Selenium 2.0) is fully implemented and supported in JavaScript (Node.js), Python, Ruby, Java, Kotlin, and C#. As of 2021, Selenium 4 is a release candidate.\nExamples\nBelow are some of the simplest instructions one can make:\nPython\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support.expected_conditions import presence_of_element_located\n#This example requires Selenium WebDriver 3.13 or newer\nwith webdriver.Firefox() as driver:\nwait = WebDriverWait(driver, 10)\ndriver.get(\"https://google.com/ncr\")\ndriver.find_element(By.NAME, \"q\").send_keys(\"cheese\" + Keys.RETURN)\nfirst_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \"h3\")))\nprint(first_result.get_attribute(\"textContent\"))\nJava\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.support.ui.WebDriverWait;\nimport static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated;\nimport java.time.Duration;\npublic class HelloSelenium {\npublic static void main(String[] args) {\nWebDriver driver = new FirefoxDriver()\nWebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\ntry\n{\ndriver.get(\"https://google.com/ncr\");\ndriver.findElement(By.name(\"q\")).sendKeys(\"cheese\" + Keys.ENTER);\nWebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\"h3\")));\nSystem.out.println(firstResult.getAttribute(\"textContent\"));\ndriver.quit();\n}\n}\n}\nC#\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Firefox;\nusing OpenQA.Selenium.Support.UI;\nusing IWebDriver driver = new FirefoxDriver;\nWebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));\ndriver.Navigate().GoToUrl(\"https://www.google.com/\");\ndriver.FindElement(By.Name(\"q\")).SendKeys(\"cheese\" + Keys.Enter);\nwait.Until(webDriver => webDriver.FindElement(By.CssSelector(\"h3\")).Displayed);\nIWebElement firstResult = driver.FindElement(By.CssSelector(\"h3\"));\nConsole.WriteLine(firstResult.GetAttribute(\"textContent\"));\nSelenium Grid\nSelenium Grid is a server that allows tests to use web browser instances running on remote machines. With Selenium Grid, one server acts as the central hub. Tests contact the hub to obtain access to browser instances. The hub has a list of servers that provide access to browser instances (WebDriver nodes), and lets tests use these instances. Selenium Grid allows running tests in parallel on multiple machines and to manage different browser versions and browser configurations centrally (instead of in each individual test).\nThe ability to run tests on remote browser instances is useful to spread the load of testing across several machines and to run tests in browsers running on different platforms or operating systems. The latter is particularly useful in cases where not all browsers to be used for testing can run on the same platform.\nSee also\n* Appium, mobile and desktop apps automation using WebDriver\n* Acceptance testing\n* Capybara (software)\n* Given-When-Then\n* List of web testing tools\n* MediaWiki Selenium\n* Regression testing\n* Robot Framework\n* Cypress\nReferences\nExternal links\n*"
    }
  ]
}