{
  "content": [
    {
      "type": "text",
      "text": "# Hardware emulation\n\nIkos NSIM-64 Hardware simulation accelerator.\nIn integrated circuit design, hardware emulation is the process of imitating the behavior of one or more pieces of hardware (typically a system under design) with another piece of hardware, typically a special purpose emulation system.  The emulation model is usually based on a hardware description language (e.g. Verilog)  source code, which is compiled into the format used by emulation system. The goal is normally debugging and functional verification of the system being designed.  Often an emulator is fast enough to be plugged into a working target system in place of a yet-to-be-built chip, so the whole system can be debugged with live data.  This is a specific case of in-circuit emulation.\nSometimes hardware emulation can be confused with hardware devices such as expansion cards with hardware processors that assist functions of software emulation, such as older daughterboards with x86 chips to allow x86 OSes to run on motherboards of different processor families.\nIntroduction\nThe largest portion of silicon integrated circuit respins and steppings are due at least in part to functional errors and bugs inadvertently introduced  at the RTL stage of the design process. Thus, comprehensive functional verification is key to reducing development costs and delivering a product on time. Functional verification of a design is most often performed using logic simulation and/or prototyping on field-programmable gate arrays (FPGAs). There are advantages and disadvantages to each and often both are used. Logic simulation is easy, accurate, flexible, and low cost. However, simulation is often not fast enough for large designs and almost always too slow to run application software against the hardware design. FPGA-based prototypes are fast and inexpensive, but the time required to implement a large design into several FPGAs can be very long and is error-prone. Changes to fix design flaws also take a long time to implement and may require board wiring changes. With traditional vendor tools, FPGA prototypes have little debugging capability, probing signals inside the FPGAs in real time is very difficult, and recompiling FPGAs to move probes takes too long. This is changing with the emergence of more advanced FPGA prototype debug tools that remove limitations on signal visibility. The usual compromise is to use simulation early in the verification process when bugs and fixes are frequent, and prototyping at the end of the development cycle when the design is basically complete and speed is needed to get sufficient testing to uncover any remaining system-level bugs. FPGA prototyping is also popular for testing software.\nSimulation acceleration can address the performance shortcomings of simulation to an extent. Here the design is mapped into a hardware accelerator to run much faster and the testbench (and any behavioral design code) continues to run on the simulator on the workstation. A high-bandwidth, low latency channel connects the workstation to the accelerator to exchange signal data between testbench and design. By Amdahl's law, the slowest device in the chain will determine the speed achievable. Normally, this is the testbench in the simulator. With a very efficient testbench (written in C or transaction-based), the channel may become the bottleneck. In some cases, a transaction-level testbench is able to feed as much data to the design being emulated as \"live\" stimulus.\nIn-circuit emulation improves somewhat on FPGA prototyping's implementation times, and provides a comprehensive, efficient debugging capability. Emulation does this at the expense of running speed and high cost ($1M+) compared to FPGA prototypes ($75K). Looking at emulation from the other direction, it improves on acceleration's performance by substituting \"live\" stimulus for the simulated testbench. This stimulus can come from a target system (the product being developed), or from test equipment. At 10,000 to 100,000 times the speed of simulation, emulation makes it possible to test application software while still providing a comprehensive hardware debug environment.\nDebugging simulations vs. emulations/prototyping\nSimulation and prototyping involve two different styles of execution. Simulation executes the RTL code serially while a prototype executes fully in parallel. This leads to differences in debugging. In simulation:\n*The user can set a breakpoint and stop simulation to inspect the design state, interact with the design, and resume simulation.\n*The user can stop execution “mid-cycle” as it were with only part of the code executed.\n*The user can see any signal in the design and the contents of any memory location at any time.\n*The user can even back up time (if they saved checkpoint(s)) and re-run.\nWith a prototype:\n*The user employs a logic analyzer for visibility, and so can see only a limited number of signals which they determined ahead of time (by clipping on probes). This is changing with emerging FPGA prototype tools that provide full visibility to 10,000s of internal signals, such as Certus.\n*The target does not stop when the logic analyzer triggers, so each time the user changes the probes or trigger condition, they have to reset the environment and start again from the beginning.\n*Probes are added directly to the RTL design to make specific signals available for observation. When the system is run, the RTL-based probe connected to each of the instrumented signals collects the signal's value at each clock cycle. The data is stored in a trace buffer in FPGA block RAM. An analyzer connected to the prototype downloads the information giving the user offline visibility into the system for efficient debug.\nAcceleration and emulation are more like prototyping and silicon in terms of RTL execution and debugging since the entire design executes simultaneously as it will in the silicon. Since the same hardware is often used to provide both simulation acceleration and in-circuit emulation, these systems provide a blend of these two very different debugging styles.\nHigh end hardware emulators provide a debugging environment with many features that can be found in logic simulators, and in some cases even surpass their debugging capabilities:\n*The user can set a breakpoint and stop emulation to inspect the design state, interact with the design, and resume emulation. The emulator always stops on cycle boundaries.\n*The user has visibility to any signal or memory contents in the design without the need to set up probes before the run. While visibility is provided also for past time, the amount of time that it can show in the past might be limited in some cases to the depth of the emulator's trace memory.\n*The user can even back up time (if they saved checkpoint(s)) and re-run.\n*Because of their high cost, emulators are beyond the reach of many developers, leading to the rise of advanced FPGA prototyping platforms and debug tools.\nEmulation and 2-state logic\nAnother difference between simulation and acceleration and emulation is a consequence of accelerators using hardware for implementation&nbsp;– they have only two logic states&nbsp;– acting the way the silicon will when fabricated. This implies:\n*They are not useful for analyzing X-state initialization.\n*They cannot analyze strength resolution, or at least this must be done statically at compile time.\n*Emulators do not model precise circuit timing, and hence they will probably not find any race conditions or setup and hold time violations.\nThese tasks are properly carried out during logic simulation or with a static timing analysis tool.\nEmulation versus prototyping\nA key traditional distinction between an emulator and an FPGA prototyping system has been that the emulator provides a rich debug environment, while a prototyping system has little or no debug capability and is primarily used after the design is debugged to create multiple copies for system analysis and software development. New tools that enable full RTL signal visibility with a small FPGA LUT impact, allow deep capture depth and provide multi-chip and clock domain analysis are emerging to allow efficient debug, comparable to the emulator.\nSee also\n*Hardware-assisted virtualization\n*Emulator\n*In-circuit emulator\n*Background debug mode interface\n* Examples:\n** Microprocessor Emulator HP 64000 (different CPUs)\nReferences\n*Electronic Design Automation For Integrated Circuits Handbook, by Lavagno, Martin, and Scheffer,  A survey of the field, from which the above summary was derived, with permission.\nFurther reading\n*[http://blogs.nvidia.com/blog/2011/05/16/sneak-peak-inside-nvidia-emulation-lab/  SNEAK PEEK: INSIDE NVIDIA’S EMULATION LAB]\n*[https://www.cadence.com/content/cadence-www/global/en_US/home/tools/system-design-and-verification/acceleration-and-emulation/palladium-z1.html Cadence Palladium Z1 Enterprise Emulation Platform]\n*[http://www.synopsys.com/tools/verification/hardware-verification/emulation/Pages/default.aspx Synopsys Zebu Server emulator]\n*[http://www.mentor.com/products/fv/emulation-systems Mentor Graphics Veloce emulation systems]"
    }
  ]
}