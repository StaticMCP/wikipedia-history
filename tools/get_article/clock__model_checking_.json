{
  "content": [
    {
      "type": "text",
      "text": "# Clock (model checking)\n\nIn model checking, a subfield of computer science, a clock is a mathematical object used to model time. More precisely, a clock measures how much time passed since a particular event occurs, in this sense, a clock is more precisely an abstraction of a stopwatch. In a model of some particular program, the value of the clock may either be the time since the program was started, or the time since a particular event occurred in the program. Those clocks are used in the definition of timed automaton, signal automaton, timed propositional temporal logic and clock temporal logic. They are also used in programs such as UPPAAL which implement timed automata.\nGenerally, the model of a system uses many clocks. Those multiple clocks are required in order to track a bounded number of events. All of those clocks are synchronized. That means that the difference in value between two fixed clocks is constant until one of them is restarted. In the language of electronics, it means that clock's jitter is null.\nExample\nLet us assume that we want to modelize an elevator in a building with ten floors. Our model may have n clocks c_{0},\\dots,c_{9}, such that the value of the clock c_i is the time someone had wait for the elevator at floor i. This clock is started when someone calls the elevator on floor i (and the elevator was not already called on this floor since last time it visited that floor). This clock can be turned off when the elevator arrives at floor i. In this example, we actually need ten distinct clocks because we need to track ten independent events. Another clock s may be used to check how much time an elevator spent at a particular floor.\nA model of this elevator can then use those clocks to assert whether the elevator's program satisfies properties such as \"assuming the elevator is not kept on a floor for more than fifteen seconds, then no one has to wait for the elevator for more than three minutes\". In order to check whether this statement holds, it suffices to check that, in every run of the model in which the clock s is always smaller than fifteen seconds, each clock c_i is turned off before it reaches three minutes.\nDefinition\nFormally, a set X of clocks is simply a finite set. Each element of a set of clocks is called a clock. Intuitively, a clock is similar to a variable in first-order logic, it is an element which may be used in a logical formula and which may take a number of different values.\nClock valuations\nA clock valuation or clock interpretation \\nu over X=\\{x_1,\\dots,x_n\\} is usually defined as a function from X to the set of non-negative reals. Equivalently, a valuation can be considered as a point in \\mathbb R_{\\ge0}^n.\nThe initial assignment \\nu_0 is the constant function sending each clock to 0. Intuitively, it represents the initial time of the program, where all clocks are initialized simultaneously.\nGiven a clock assignment \\nu, and a real t\\ge0, \\nu+t denotes the clock assignment sending each clock x\\in C to \\nu(x)+t. Intuitively, it represents the valuation \\nu after which t time units passed.\nGiven a subset r\\subseteq C of clocks, \\nu[r\\rightarrow 0] denotes  the assignment similar to \\nu in which the clocks of r are reset. Formally, \\nu[r\\rightarrow 0] sends each clock x\\in r to 0 and each clock x\\not\\in r to \\nu(x).\nInactive clocks\nThe program UPPAAL introduces the notion of inactive clocks. A clock is inactive at some time if there is no possible future in which the clock's value is checked without being reset first. In our example above, the clock c_i is considered to be inactive when the elevator arrive at floor i, and remains inactive until someone call the elevator at floor i.\nWhen allowing for inactive clocks, a valuation may associate a clock x to some special value \\bot to indicate that it is inactive. If \\nu(x)=\\bot then (\\nu+t)(x) also equals \\bot.\nClock constraint\nAn atomic clock constraint is simply a term of the form x\\sim c, where x is a clock, \\sim is a comparison operator, such as &lt;, &le;, = &ge;, or &gt;, and c\\in\\mathbb N is an integral constant. In our previous example, we may use the atomic clock constraints c_i\\le180 to state that the person at floor i waited for less than three minutes, and s>15 to state that the elevator stayed at some floor for more than fifteen seconds. A valuation \\nu satisfies an atomic clock valuation x\\sim c if and only if \\nu(x)\\sim c.\nA clock constraint is either a finite conjunction of atomic clock constraint or is the constant \"true\" (which can be considered as the empty conjunction). A valuation \\nu satisfies a clock constraint \\bigwedge_{i=1}^nx_i\\sim_ic_i if it satisfies each atomic clock constraint x_i\\sim_ic_i.\nDiagonal constraint\nDepending on the context, an atomic clock constraint may also be of the form x_i\\sim x_j+c. Such a constraint is called a diagonal constraint, because x_1=x_2+c defines a diagonal line in \\mathbb R_{\\ge0}^2.\nAllowing diagonal constraints may allow to decrease the size of a formula or of an automaton used to describe a system. However, algorithm's complexity may increase when diagonal constraints are allowed. In most system using clocks, allowing diagonal constraint does not increase the expressivity of the logic. We now explain how to encode such a constraint with Boolean variables and non-diagonal constraints.\nA diagonal constraint x_i\\sim x_j+c may be simulated using non-diagonal constraints as follows.  When x_j is reset, check whether x_i\\sim c holds or not. Recall this information in a Boolean variable b_{i,j,c} and replace x_i\\sim x_j+c by this variable. When x_i is reset, set b_{i,j,c} to true if \\sim is &lt; or &le; or if \\sim is = and c=0.\nThe way to encode a Boolean variable depends on the system which uses the clock. For example, UPPAAL supports Boolean variables directly. Timed automata and signal automata can encode a Boolean value in their locations. In clock temporal logic over timed words, the Boolean variable may be encoded using a new clock x_{i,j,c}, whose value is 0 if and only if b_{i,j,c} is false. That is, x_{i,j,c} is reset as long as x_{i,j,c} is supposed to be false. In timed propositional temporal logic, the formula x_i.\\phi, which restart x_i and then evaluates \\phi, can be replaced by the formula x_i.((x_i\\sim x_j+c\\implies\\phi_\\top)\\land(\\neg x_i\\sim x_j+c\\implies\\phi\\bot)), where \\phi_\\top and \\phi_\\bot are copies of the formulas \\phi, where x_i\\sim x_j+c are replaced by the true and false constant respectively.\nSets defined by clock constraints\nA clock constraint defines a set of valuations. Two kinds of such sets are considered in the literature.\nA zone is a non-empty set of valuations satisfying a clock constraint. Zones and clock constraints are implemented using difference bound matrix.\nGiven a model  M, it uses a finite number of constants in its clock constraints. Let K be the greatest constant used. A region is a non-empty zone in which no constraint greater than K are used, and furthermore, such that it is minimal for the inclusion.\nSee also\n* Timed automaton\n* Signal automaton\n* Clock temporal logic\n* Timed propositional temporal logic\nNotes"
    }
  ]
}