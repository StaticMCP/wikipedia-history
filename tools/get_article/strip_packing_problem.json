{
  "content": [
    {
      "type": "text",
      "text": "# Strip packing problem\n\nThe strip packing problem is a 2-dimensional geometric minimization problem.\nGiven a set of axis-aligned rectangles and a strip of bounded width and infinite height, determine an overlapping-free packing of the rectangles into the strip, minimizing its height.\nThis problem is a cutting and packing problem and is classified as an Open Dimension Problem according to Wäscher et al.\nThis problem arises in the area of scheduling, where it models jobs that require a contiguous portion of the memory over a given time period. Another example is the area of industrial manufacturing, where rectangular pieces need to be cut out of a sheet of material (e.g., cloth or paper) that has a fixed width but infinite length, and one wants to minimize the wasted material.\nThis problem was first studied in 1980. It is strongly-NP hard and there exists no polynomial-time approximation algorithm with a ratio smaller than  3/2 unless P = NP. However, the best approximation ratio achieved so far (by a polynomial time algorithm by Harren et al.) is (5/3 + \\varepsilon), imposing an open question of whether there is an algorithm with approximation ratio 3/2.\nDefinition\nAn instance  I = (\\mathcal{I},W) of the strip packing problem consists of a strip with width W = 1 and infinite height, as well as a set \\mathcal{I} of rectangular items.\nEach item i \\in \\mathcal{I} has a width w_i \\in (0,1] \\cap \\mathbb{Q} and a height  h_i \\in (0,1] \\cap \\mathbb{Q}.\nA packing of the items is a mapping that maps each lower-left corner of an item i \\in \\mathcal{I} to a position  (x_i,y_i)  \\in ([0,1-w_i] \\cap \\mathbb{Q}) \\times \\mathbb{Q}_{\\geq 0}  inside the strip.\nAn inner point of a placed item i \\in \\mathcal{I} is a point from the set \\mathrm{inn}(i) = \\{(x,y) \\in \\mathbb{Q} \\times \\mathbb{Q}| x_i .\nTwo (placed) items overlap if they share an inner point.\nThe height of the packing is defined as \\max \\{y_i+h_i | i \\in \\mathcal{I}\\}.\nThe objective is to find an overlapping-free packing of the items inside the strip while minimizing the height of the packing.\nThis definition is used for all polynomial time algorithms. For pseudo-polynomial time and FPT-algorithms, the definition is slightly changed for the simplification of notation. In this case, all appearing sizes are integral. Especially the width of the strip is given by an arbitrary integer number larger than 1. Note that these two definitions are equivalent.\nVariants\nThere are several variants of the strip packing problem that have been studied. These variants concern the objects' geometry, the problem's dimension, the rotateability of the items, and the structure of the packing.\nGeometry: In the standard variant of this problem, the set of given items consists of rectangles.\nIn an often considered subcase, all the items have to be squares. This variant was already considered in the first paper about strip packing.\nAdditionally, variants where the shapes are circular or even irregular have been studied. In the latter case, it is referred to as irregular strip packing.\nDimension:\nWhen not mentioned differently, the strip packing problem is a 2-dimensional problem. However, it also has been studied in three or even more dimensions. In this case, the objects are hyperrectangles, and the strip is open-ended in one dimension and bounded in the residual ones.\nRotation: In the classical strip packing problem, the items are not allowed to be rotated. However, variants have been studied where rotating by 90 degrees or even an arbitrary angle is allowed.\nStructure:\nIn the general strip packing problem, the structure of the packing is irrelevant.\nHowever, there are applications that have explicit requirements on the structure of the packing. One of these requirements is to be able to cut the items from the strip by horizontal or vertical edge-to-edge cuts.\nPackings that allow this kind of cutting are called guillotine packing.\nHardness\nThe strip packing problem contains the bin packing problem as a special case when all the items have the same height 1.\nFor this reason, it is strongly NP-hard, and there can be no polynomial time approximation algorithm that has an approximation ratio smaller than 3/2 unless P = NP.\nFurthermore, unless P = NP, there cannot be a pseudo-polynomial time algorithm that has an approximation ratio smaller than 5/4, which can be proven by a reduction from the strongly NP-complete 3-partition problem.\nNote that both lower bounds 3/2 and 5/4 also hold for the case that a rotation of the items by 90 degrees is allowed.\nAdditionally, it was proven by Ashok et al. that strip packing is [[Parameterized complexity | W[1]-hard]] when parameterized by the height of the optimal packing.\nProperties of optimal solutions\nThere are two trivial lower bounds on optimal solutions.\nThe first is the height of the largest item.\nDefine h_{\\max}(I) := \\max\\{h(i) | i \\in \\mathcal{I}\\}.\nThen it holds that\nOPT(I) \\geq h_{\\max}(I).\nAnother lower bound is given by the total area of the items.\nDefine \\mathrm{AREA}(\\mathcal{I}) := \\sum_{i \\in \\mathcal{I}}h(i)w(i) then it holds that\nOPT(I) \\geq \\mathrm{AREA}(\\mathcal{I})/W.\nThe following two lower bounds take notice of the fact that certain items cannot be placed next to each other in the strip, and can be computed in \\mathcal{O}(n \\log(n)).\nFor the first lower bound assume that the items are sorted by non-increasing height. Define k := \\max \\{i : \\sum_{j = 1}^k w(j) \\leq W\\}. For each l > k  define i(l) \\leq k the first index such that  w(l) + \\sum_{j = 1}^{i(l)} w(j) > W. Then it holds that\nOPT(I) \\geq \\max \\{h(l) + h(i(l))| l >k \\wedge  w(l) + \\sum_{j = 1}^{i(l)} w(j) > W\\}.\nFor the second lower bound, partition the set of items into three sets. Let \\alpha \\in [1, W/2]\\cap \\mathbb{N} and define \\mathcal{I}_1(\\alpha) := \\{i \\in \\mathcal{I} | w(i) > W - \\alpha\\},  \\mathcal{I}_2(\\alpha) := \\{i \\in \\mathcal{I} | W - \\alpha \\geq w(i) > W/2\\}, and \\mathcal{I}_3(\\alpha) := \\{i \\in \\mathcal{I} | W/2 \\geq w(i) > \\alpha \\}. Then it holds that\nOPT(I) \\geq\n\\max_{\\alpha \\in [1, W/2]\\cap \\mathbb{N}}\n\\Bigg\\{ \\sum_{i \\in \\mathcal{I}_1(\\alpha) \\cup \\mathcal{I}_2(\\alpha)} h(i) + \\left(\\frac{\\sum_{i \\in \\mathcal{I}_3(\\alpha) h(i)w(i) - \\sum_{i \\in \\mathcal{I}_2(\\alpha)}(W -w(i))h(i)}}{W}\\right)_+\n\\Bigg\\}, where  (x)_+ := \\max\\{x,0\\} for each x \\in \\mathbb{R}.\nOn the other hand, Steinberg has shown that the height of an optimal solution can be upper bounded by\nOPT(I) \\leq 2\\max\\{h_{\\max}(I),\\mathrm{AREA}(\\mathcal{I})/W\\}.\nMore precisely he showed that given a W \\geq w_{\\max}(\\mathcal{I}) and a H \\geq h_{\\max}(I) then the items \\mathcal{I} can be placed inside a box with width W and height H if\nWH  \\geq 2\\mathrm{AREA}(\\mathcal{I}) + (2w_{\\max}(\\mathcal{I}) - W)_+(2h_{\\max}(I) - H)_+, where  (x)_+ := \\max\\{x,0\\}.\nPolynomial time approximation algorithms\nSince this problem is NP-hard, approximation algorithms have been studied for this problem.\nMost of the heuristic approaches have an approximation ratio between 3 and 2.\nFinding an algorithm with a ratio below 2 seems complicated, and\nthe complexity of the corresponding algorithms increases regarding their running time and their descriptions.\nThe smallest approximation ratio achieved so far is (5/3+\\varepsilon).\n{| class=\"wikitable\"\n|+Overview of polynomial time approximations\n|-\n! Year !! Name !! Approximation guarantee !! Source\n|-\n| 1980 || Bottom-Up Left-Justified (BL) ||3 OPT(I)   || Baker et al.\n|-\n|rowspan=\"3\"| 1980\n|Next-Fit Decreasing-Height (NFDH)\n|2 OPT(I) + h_{\\max}(I) \\leq 3 OPT(I)\n|rowspan=\"3\"|Coffman et al.\n|-\n|First-Fit Decreasing-Height (FFDH)\n|1.7 OPT(I) + h_{\\max}(I) \\leq 2.7 OPT(I)\n|-\n| Split-Fit (SF)\n|1.5 OPT(I) + 2h_{\\max}(I)\n|-\n| 1980 || ||2 OPT(I) + h_{\\max}(I)/2 \\leq 2.5  OPT(I) || Sleator\n|-\n|rowspan=\"2\"| 1981\n| Split Algorithm (SP)\n|3 OPT(I)\n|rowspan=\"2\"| Golan\n|-\n|Mixed Algoritghm\n| (4/3)OPT(I) + 7\\frac{1}{18} h_{\\max}(I)\n|-\n| 1981 || Up-Down (UD)||(5/4)OPT(I) + 6\\frac{7}{8}h_{\\max}(I) || Baker et al.\n|-\n| 1994 || Reverse-Fit ||2 OPT(I)  || Schiermeyer\n|-\n| 1997 || ||2 OPT(I)  || Steinberg\n|-\n| 2000\n|\n|(1+\\varepsilon) OPT(I) + \\mathcal{O}(1/\\varepsilon^2)h_{\\max}(I)\n| Kenyon, Rémila\n|-\n| 2009\n|\n|1.9396 OPT(I)\n| Harren, van Stee\n|-\n| 2009 || ||(1+\\varepsilon) OPT(I) + h_{\\max}(I)  || Jansen, Solis-Oba\n|-\n| 2011\n|\n|(1+\\varepsilon) OPT(I) + \\mathcal{O}(\\log(1/\\varepsilon)/\\varepsilon)h_{\\max}(I)\n| Bougeret et al.\n|-\n| 2012\n|\n|(1+\\varepsilon) OPT(I) + \\mathcal{O}(\\log(1/\\varepsilon)/\\varepsilon)h_{\\max}(I)\n| Sviridenko\n|-\n| 2014 || ||(5/3+\\varepsilon) OPT(I) || Harren et al.\n|}\nBottom-up left-justified (BL)\nThis algorithm was first described by Baker et al. It works as follows:\nLet  L  be a sequence of rectangular items.\nThe algorithm iterates the sequence in the given order.\nFor each considered item  r \\in L , it searches for the bottom-most position to place it and then shifts it as far to the left as possible.\nHence, it places  r  at the bottom-most left-most possible coordinate  (x,y) in the strip.\nThis algorithm has the following properties:\n* The approximation ratio of this algorithm cannot be bounded by a constant. More precisely they showed that for each  M > 0  there exists a list  L   of rectangular items ordered by increasing width such that  BL(L)/ OPT(L) > M , where  BL(L)  is the height of the packing created by the BL algorithm and  OPT(L)  is the height of the optimal solution for  L .\n* If the items are ordered by decreasing widths, then  BL(L)/ OPT(L) \\leq 3 .\n* If the item are all squares and are ordered by decreasing widths, then  BL(L)/ OPT(L) \\leq 2 .\n* For any  \\delta > 0 , there exists a list  L  of rectangles ordered by decreasing widths such that  BL(L)/ OPT(L) > 3 - \\delta .\n* For any  \\delta > 0 , there exists a list  L  of squares ordered by decreasing widths such that  BL(L)/ OPT(L) > 2 - \\delta .\n* For each  \\varepsilon \\in (0,1] , there exists an instance containing only squares where each order of the squares  L  has a ratio of  BL(L)/ OPT(L) > \\frac{12}{11 +\\varepsilon} , i.e., there exist instances where BL does not find the optimum even when iterating all possible orders of the items. In 2024 this lower bound has been improved by Hougardy and Zondervan to  BL(L)/ OPT(L) > \\frac{4}{3 +\\varepsilon} .\n* In 2025, Hougardy and Zondervan constructed an ordering of rectangles (called the  \\mathcal{FQW} -ordering), such that  BL(L)/ OPT(L) \\leq \\frac{13}{6} .\nNext-fit decreasing-height (NFDH)\nThis algorithm was first described by Coffman et al. in 1980 and works as follows:\nLet  \\mathcal{I}  be the given set of rectangular items.\nFirst, the algorithm sorts the items by order of nonincreasing height.\nThen, starting at position  (0,0) , the algorithm places the items next to each other in the strip until the next item will overlap the right border of the strip.\nAt this point, the algorithm defines a new level at the top of the tallest item in the current level and places the items next to each other in this new level.\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}| \\log(|\\mathcal{I}|)) and if the items are already sorted even by \\mathcal{O}(|\\mathcal{I}|).\n* For every set of items  \\mathcal{I} , it produces a packing of height  NFDH(\\mathcal{I}) \\leq 2 OPT(\\mathcal{I}) + h_{\\max} \\leq 3 OPT(\\mathcal{I}), where  h_{\\max}  is the largest height of an item in  \\mathcal{I} .\n* For every  \\varepsilon > 0  there exists a set of rectangles  \\mathcal{I}  such that  NFDH(\\mathcal{I}|) > (2-\\varepsilon) OPT(\\mathcal{I}).\n* The packing generated is a guillotine packing. This means the items can be obtained through a sequence of horizontal or vertical edge-to-edge cuts.\nFirst-fit decreasing-height (FFDH)\nThis algorithm, first described by Coffman et al. in 1980, works similar to the NFDH algorithm.\nHowever, when placing the next item, the algorithm scans the levels from bottom to top and places the item in the first level on which it will fit.\nA new level is only opened if the item does not fit in any previous ones.\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}|^2), since there are at most  |\\mathcal{I}| levels.\n* For every set of items  \\mathcal{I}  it produces a packing of height  FFDH(\\mathcal{I}) \\leq 1.7 OPT(\\mathcal{I}) + h_{\\max} \\leq 2.7 OPT(\\mathcal{I}), where  h_{\\max}  is the largest height of an item in  \\mathcal{I} .\n* Let  m \\geq 2 . For any set of items  \\mathcal{I}  and strip with width W such that  w(i) \\leq W/m  for each  i \\in \\mathcal{I} , it holds that  FFDH(\\mathcal{I}) \\leq \\left(1 + 1/m\\right) OPT(\\mathcal{I}) + h_{\\max}. Furthermore, for each  \\varepsilon > 0 , there exists such a set of items  \\mathcal{I}   with   FFDH(\\mathcal{I}) > \\left(1 + 1/m -\\varepsilon\\right)OPT(\\mathcal{I}).\n* If all the items in  \\mathcal{I}  are squares, it holds that  FFDH(\\mathcal{I}) \\leq (3/2) OPT(\\mathcal{I}) + h_{\\max}. Furthermore, for each  \\varepsilon >0, there exists a set of squares  \\mathcal{I}   such that   FFDH(\\mathcal{I}) > \\left(3/2-\\varepsilon\\right)OPT(\\mathcal{I}).\n* The packing generated is a guillotine packing. This means the items can be obtained through a sequence of horizontal or vertical edge-to-edge cuts.\nThe split-fit algorithm (SF)\nThis algorithm was first described by Coffman et al.\nFor a given set of items  \\mathcal{I}  and strip with width  W, it works as follows:\n# Determinate  m \\in \\mathbb{N} , the largest integer such that the given rectangles have width  W/m  or less.\n# Divide  \\mathcal{I}  into two sets  \\mathcal{I}_{wide}  and  \\mathcal{I}_{narrow} , such that  \\mathcal{I}_{wide}  contains all the items  i \\in \\mathcal{I} with a width  w(i) > W/(m+1)  while  \\mathcal{I}_{narrow}  contains all the items with  w(i) \\leq W/(m+1) .\n# Order  \\mathcal{I}_{wide}  and  \\mathcal{I}_{narrow}  by nonincreasing height.\n# Pack the items in  \\mathcal{I}_{wide}  with the FFDH algorithm.\n# Reorder the levels/shelves constructed by FFDH such that all the shelves with a total width larger than  W(m+1)/(m+2)  are below the more narrow ones.\n# This leaves a rectangular area  R  of with  W/(m+2) , next to more narrow levels/shelves, that contains no item.\n# Use the FFDH algorithm to pack the items in  \\mathcal{I}_{narrow}  using the area  R  as well.\nThis algorithm has the following properties:\n* For every set of items  \\mathcal{I}  and the corresponding  m , it holds that  SF(\\mathcal{I}) \\leq (m+2)/(m+1)OPT(\\mathcal{I}) + 2h_{\\max}. Note that for  m=1 , it holds that  SF(\\mathcal{I}) \\leq (3/2) OPT(\\mathcal{I}) + 2h_{\\max}\n* For each  \\varepsilon >0, there is a set of items  \\mathcal{I}   such that   SF(\\mathcal{I}) > \\left((m+2)/(m+1) -\\varepsilon\\right)OPT(\\mathcal{I}).\nSleator's algorithm\nFor a given set of items  \\mathcal{I}  and strip with width  W, it works as follows:\n# Find all the items with a width larger than  W/2  and stack them at the bottom of the strip (in random order). Call the total height of these items  h_0 . All the other items will be placed above  h_0 .\n# Sort all the remaining items in nonincreasing order of height. The items will be placed in this order.\n# Consider the horizontal line at  h_0  as a shelf. The algorithm places the items on this shelf in nonincreasing order of height until no item is left or the next one does not fit.\n# Draw a vertical line at  W/2 , which cuts the strip into two equal halves.\n# Let  h_l  be the highest point covered by any item in the left half and  h_r  the corresponding point on the right half. Draw two horizontal line segments of length  W/2  at  h_l  and  h_r  across the left and the right half of the strip. These two lines build new shelves on which the algorithm will place the items, as in step 3. Choose the half which has the lower shelf and place the items on this shelf until no other item fits. Repeat this step until no item is left.\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}| \\log(|\\mathcal{I}|)) and if the items are already sorted even by \\mathcal{O}(|\\mathcal{I}|).\n* For every set of items  \\mathcal{I}  it produces a packing of height  A(\\mathcal{I}) \\leq 2 OPT(\\mathcal{I}) + h_{\\max}/2 \\leq 2.5 OPT(\\mathcal{I}), where  h_{\\max}  is the largest height of an item in  \\mathcal{I} .\nThe split algorithm (SP)\nThis algorithm is an extension of Sleator's approach and was first described by Golan.\nIt places the items in nonincreasing order of width.\nThe intuitive idea is to split the strip into sub-strips while placing some items.\nWhenever possible, the algorithm places the current item  i  side-by-side of an already placed item  j .\nIn this case, it splits the corresponding sub-strip into two pieces: one containing the first item  j  and the other containing the current item  i .\nIf this is not possible, it places  i  on top of an already placed item and does not split the sub-strip.\nThis algorithm creates a set  S  of sub-strips. For each sub-strip  s ∈ S we know its lower left corner  s.xposition and  s.yposition, its width  s.width, the horizontal lines parallel to the upper and lower border of the item placed last inside this sub-strip  s.upper and  s.lower, as well as the width of it  s.itemWidth.\nfunction Split Algorithm (SP) is\ninput: items  I, width of the strip W\noutput: A packing of the items\nSort I in nonincreasing order of widths;\nDefine empty list S of sub-strips;\nDefine a new sub-strip s with s.xposition = 0, s.yposition = 0, s.width = W, s.lower = 0, s.upper = 0, s.itemWidth = W;\nAdd s to S;\nwhile I not empty do\ni := I.pop(); Removes widest item from I\nDefine new list S_2 containing all the substrips with s.width - s.itemWidth ≥ i.width;\nS_2 contains all sub-strips where i fits next to the already placed item\nif S_2 is empty then\nIn this case, place the item on top of another one.\nFind the sub-strip s in S with smallest s.upper; i.e. the least filled sub-strip\nPlace i at position (s.xposition, s.upper);\nUpdate s: s.lower := s.upper; s.upper := s.upper+i.height; s.itemWidth := i.width;\nelse\nIn this case, place the item next to another one at the same level and split the corresponding sub-strip at this position.\nFind s ∈ S_2 with the smallest s.lower;\nPlace i at position (s.xposition + s.itemWidth, s.lower);\nRemove s from S;\nDefine two new sub-strips s1 and s2 with\ns1.xposition = s.xposition, s1.yposition = s.upper, s1.width = s.itemWidth, s1.lower = s.upper, s1.upper = s.upper, s1.itemWidth = s.itemWidth;\ns2.xposition = s.xposition+s.itemWidth, s2.yposition = s.lower, s2.width = s.width - s.itemWidth, s2.lower = s.lower, s2.upper = s.lower + i.height, s2.itemWidth = i.width;\nS.add(s1,s2);\nreturn\nend function\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}|^2) since the number of substrips is bounded by  |\\mathcal{I}|.\n* For any set of items \\mathcal{I} it holds that  SP(\\mathcal{I}) \\leq 2 OPT(\\mathcal{I}) + h_{\\max} \\leq 3 OPT(\\mathcal{I}).\n* For any \\varepsilon >0, there exists a set of items \\mathcal{I} such that  SP(\\mathcal{I}) > (3-\\varepsilon) OPT(\\mathcal{I}).\n* For any \\varepsilon >0 and C>0, there exists a set of items \\mathcal{I} such that  SP(\\mathcal{I}) > (2-\\varepsilon) OPT(\\mathcal{I})+C.\nReverse-fit (RF)\nThis algorithm was first described by Schiermeyer.\nThe description of this algorithm needs some additional notation.\nFor a placed item i \\in \\mathcal{I}, its lower left corner is denoted by (a_i,c_i) and its upper right corner by (b_i,d_i).\nGiven a set of items \\mathcal{I} and a strip of width W, it works as follows:\n# Stack all the rectangles of width greater than W/2 on top of each other (in random order) at the bottom of the strip. Denote by H_0 the height of this stack. All other items will be packed above H_0.\n# Sort the remaining items in order of nonincreasing height and consider the items in this order in the following steps. Let h_{\\max} be the height of the tallest of these remaining items.\n# Place the items one by one left aligned on a shelf defined by H_0 until no other item fit on this shelf or there is  no item left. Call this shelf the first level.\n# Let h_1 be the height of the tallest unpacked item. Define a new shelf at H_0 + h_{\\max} + h_1. The algorithm will fill this shelf from right to left, aligning  the items to the right, such that the items touch this shelf with their top. Call this shelf the second reverse-level.\n# Place the items into the two shelves due to First-Fit, i.e., placing the items in the first level where they fit and in the second one otherwise. Proceed until there are no items left, or the total width of the items in the second shelf is at least W/2.\n# Shift the second reverse-level down until an item from it touches an item from the first level. Define H_1 as the new vertical position of the shifted shelf. Let f and s be the right most pair of touching items with f placed on the first level and s on the second reverse-level. Define x_r := \\max(b_f,b_s).\n# If x_r  then s is the last rectangle placed in the second reverse-level. Shift all the other items from this level further down (all the same amount) until the first one touches an item from the first level. Again the algorithm determines the rightmost pair of touching items f' and s'. Define h_2 as the amount by which the shelf was shifted down.\n## If h_2 \\leq h(s) then shift s to the left until it touches another item or the border of the strip. Define the third level at the top of s'.\n## If h_2 > h(s) then shift s define the third level at the top of s'. Place s left-aligned in this third level, such that it touches an item from the first level on its left.\n# Continue packing the items using the First-Fit heuristic. Each following level (starting at level three) is defined by a horizontal line through the top of the largest item on the previous level. Note that the first item placed in the next level might not touch the border of the strip with their left side, but an item from the first level or the item s.\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}|^2), since there are at most  |\\mathcal{I}| levels.\n* For every set of items  \\mathcal{I}  it produces a packing of height  RF(\\mathcal{I}) \\leq 2 OPT(\\mathcal{I}).\nSteinberg's algorithm (ST)\nSteinbergs algorithm is a recursive one. Given a set of rectangular items  \\mathcal{I} and a rectangular target region with width  W and height  H, it proposes four reduction rules, that place some of the items and leaves a smaller rectangular region with the same properties as before regarding of the residual items.\nConsider the following notations: Given a set of items  \\mathcal{I} we denote by  h_{\\max}(\\mathcal{I}) the tallest item height in   \\mathcal{I},  w_{\\max}(\\mathcal{I}) the largest item width appearing in   \\mathcal{I} and by  \\mathrm{AREA}(\\mathcal{I}) := \\sum_{i \\in \\mathcal{I}} w(i)h(i) the total area of these items.\nSteinbergs shows that if\nh_{\\max}(\\mathcal{I}) \\leq H ,  w_{\\max}(\\mathcal{I}) \\leq W , and  \\mathrm{AREA}(\\mathcal{I}) \\leq W\\cdot H - (2h_{\\max}(\\mathcal{I}) -h)_+(2w_{\\max}(\\mathcal{I}) - W)_+ , where (a)_+ := \\max\\{0,a\\},\nthen all the items can be placed inside the target region of size  W \\times H .\nEach reduction rule will produce a smaller target area and a subset of items that have to be placed. When the condition from above holds before the procedure started, then the created subproblem will have this property as well.\nProcedure 1: It can be applied if  w_{\\max}(\\mathcal{I}') \\geq W/2.\n# Find all the items i \\in \\mathcal{I} with width  w(i) \\geq W/2 and remove them from \\mathcal{I}.\n# Sort them by nonincreasing width and place them left-aligned at the bottom of the target region. Let h_0 be their total height.\n# Find all the items i \\in \\mathcal{I} with width  h(i) > H-h_0. Remove them from \\mathcal{I} and place them in a new set \\mathcal{I}_H.\n# If \\mathcal{I}_H is empty, define the new target region as the area above h_0, i.e. it has height H-h_0 and width W. Solve the problem consisting of this new target region and the reduced set of items with one of the procedures.\n# If \\mathcal{I}_H is not empty, sort it by nonincreasing height and place the items right allinged one by one in the upper right corner of the target area. Let w_0 be the total width of these items. Define a new target area with width W-w_0 and height H - h_0 in the upper left corner. Solve the problem consisting of this new target region and the reduced set of items with one of the procedures.\nProcedure 2: It can be applied if the following conditions hold:  w_{\\max}(\\mathcal{I}) \\leq W/2,  h_{\\max}(\\mathcal{I}) \\leq H/2, and there exist two different items i,i' \\in \\mathcal{I} with  w(i) \\geq W/4,  w(i') \\geq W/4,  h(i) \\geq H/4,  h(i') \\geq H/4 and  2(\\mathrm{AREA}(\\mathcal{I}) - w(i)h(i) -w(i')h(i')) \\leq (W- \\max\\{w(i),w(i')\\})H.\n# Find i and i' and remove them from \\mathcal{I}.\n# Place the wider one in the lower-left corner of the target area and the more narrow one left-aligned on the top of the first.\n# Define a new target area on the right of these both items, such that it has the width  W- \\max\\{w(i),w(i')\\} and height  H.\n# Place the residual items in \\mathcal{I} into the new target area using one of the procedures.\nProcedure 3: It can be applied if the following conditions hold:  w_{\\max}(\\mathcal{I}) \\leq W/2,  h_{\\max}(\\mathcal{I}) \\leq H/2,  |\\mathcal{I}| > 1, and when sorting the items by decreasing width there exist an index m  such that when defining \\mathcal{I'} as the first m  items it holds that\n\\mathrm{AREA}(\\mathcal{I})- WH/4 \\leq \\mathrm{AREA}(\\mathcal{I'}) \\leq 3WH/8 as well as w(i_{m+1})\\leq W/4\n# Set  W_1 := \\max{W/2, 2\\mathrm{AREA}(\\mathcal{I'})/H}.\n# Define two new rectangular target areas one at the lower-left corner of the original one with height H and width W_1 and the other left of it with height H and width W-W_1.\n# Use one of the procedures to place the items in \\mathcal{I'} into the first new target area and the items in \\mathcal{I}\\setminus\\mathcal{I'} into the second one.\nNote that procedures 1 to 3 have a symmetric version when swapping the height and the width of the items and the target region.\nProcedure 4: It can be applied if the following conditions hold:  w_{\\max}(\\mathcal{I}) \\leq W/2,  h_{\\max}(\\mathcal{I}) \\leq H/2, and there exists an item i \\in \\mathcal{I} such that w(i) h(i) \\geq \\mathrm{AREA}(\\mathcal{I}) - WH/4.\n# Place the item i in the lower-left corner of the target area and remove it from \\mathcal{I}.\n# Define a new target area right of this item such that it has the width W-w(i) and height H and place the residual items inside this area using one of the procedures.\nThis algorithm has the following properties:\n* The running time can be bounded by  \\mathcal{O}(|\\mathcal{I}| \\log(|\\mathcal{I}|)^2/\\log(\\log(|\\mathcal{I}|))).\n* For every set of items  \\mathcal{I}  it produces a packing of height  ST(\\mathcal{I}) \\leq 2 OPT(\\mathcal{I}).\nPseudo-polynomial time approximation algorithms\nTo improve upon the lower bound of 3/2 for polynomial-time algorithms, pseudo-polynomial time algorithms for the strip packing problem have been considered.\nWhen considering this type of algorithms, all the sizes of the items and the strip are given as integrals. Furthermore, the width of the strip W is allowed to appear polynomially in the running time.\nNote that this is no longer considered as a polynomial running time since, in the given instance, the width of the strip needs an encoding size of  \\log(W).\nThe pseudo-polynomial time algorithms that have been developed mostly use the same approach. It is shown that each optimal solution can be simplified and transformed into one that has one of a constant number of structures. The algorithm then iterates all these structures and places the items inside using linear and dynamic programming. The best ratio accomplished so far is (5/4 +\\varepsilon) OPT(I) . while there  cannot be a pseudo-polynomial time algorithm with ratio better than 5/4  unless P = NP\n{| class=\"wikitable\"\n|+Overview of pseudo-polynomial time approximations\n|-\n! Year !! Approximation Ratio !! Source !! Comment\n|-\n|2010\n| (3/2 +\\varepsilon)\n| Jansen, Thöle\n|-\n|2016\n| (7/5 +\\varepsilon)\n|Nadiradze, Wiese\n|-\n|2016\n| (4/3 +\\varepsilon)\n|Gálvez, Grandoni, Ingala, Khan\n| also for 90 degree rotations\n|-\n|2017\n|(4/3 +\\varepsilon)\n|Jansen, Rau\n|-\n|2019\n|(5/4 +\\varepsilon)\n|Jansen, Rau\n| also for 90 degree rotations and contiguous moldable jobs\n|}\nOnline algorithms\nIn the online variant of strip packing, the items arrive over time. When an item arrives, it has to be placed immediately before the next item is known. There are two types of online algorithms that have been considered. In the first variant, it is not allowed to alter the packing once an item is placed. In the second, items may be repacked when another item arrives. This variant is called the migration model.\nThe quality of an online algorithm is measured by the (absolute) competitive ratio\n\\mathrm{sup}_I A(I)/OPT(I) ,\nwhere  A(I)  corresponds to the solution generated by the online algorithm and  OPT(I)  corresponds to the size of the optimal solution.\nIn addition to the absolute competitive ratio, the asymptotic competitive ratio of online algorithms has been studied. For instances I with h_{\\max}(I)\\leq 1  it is defined as\n\\lim \\mathrm{sup}_{OPT(I) \\rightarrow \\infty} A(I)/OPT(I) .\nNote that all the instances can be scaled such that h_{\\max}(I)\\leq 1 .\n{| class=\"wikitable\"\n|+Overview of online algorithms without migration\n|-\n! Year !! Competitive Ratio !! Asymptotic Competitive Ratio !! Source\n|-\n| 1983\n| 6.99\n|  \\approx 1.7\n| Baker and Schwarz\n|-\n| 1997\n|\n|  1.69+\\varepsilon\n| Csirik and Woeginger\n|-\n| 2007\n|6.6623\n|\n|Hurink and Paulus\n|-\n| 2009\n|6.6623\n|\n|Ye, Han, and Zhang\n|-\n|2007\n|\n|1.58889\n| Han et al. + Seiden\n|}\nThe framework of Han et al. is applicable in the online setting if the online bin packing\nalgorithm belongs to the class Super Harmonic. Thus, Seiden's online bin packing algorithm\nHarmonic++ implies an algorithm for online strip packing with asymptotic ratio 1.58889.\n{| class=\"wikitable\"\n|+Overview of lower bounds for online algorithms without migration\n|-\n! Year !! Competitive Ratio !! Asymptotic Competitive Ratio !! Source !! Comment\n|-\n| 1982\n| 2\n|\n| Brown, Baker, and Katseff\n|-\n| 2006\n|2.25\n|\n|Johannes\n| also holds for the parallel task scheduling problem\n|-\n| 2007\n|2.43\n|\n| Hurink and Paulus\n| also holds for the parallel task scheduling problem\n|-\n| 2009\n| 2.457\n|\n| Kern and Paulus\n|-\n| 2012\n|\n|  1.5404\n| Balogh and Békési\n| lower bound due to the underlying bin packing problem\n|-\n| 2016\n| 2.618\n|\n| Yu, Mao, and Xiao\n|}\nReferences"
    }
  ]
}