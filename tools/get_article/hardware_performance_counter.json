{
  "content": [
    {
      "type": "text",
      "text": "# Hardware performance counter\n\nIn computers, hardware performance counters (HPCs), or hardware counters are a set of special-purpose registers built into modern microprocessors to store the counts of hardware-related activities. Advanced users often rely on those counters to conduct low-level performance analysis or tuning.\nImplementations\nThe number of available hardware counters in a processor is limited while each CPU model might have a lot of different events that a developer might like to measure. Each counter can be programmed with the index of an event type to be monitored, like a L1 cache miss or a branch misprediction.\nOne of the first processors to implement a hardware counter and an associated instruction to access it (the RDPMC instruction) was the Intel Pentium, but they were not documented until Terje Mathisen wrote an article about reverse engineering them in Byte July 1994.\nThe following table shows some examples of CPUs and the number of available hardware counters:\n{| class=\"wikitable\"\n|-\n! Processor !! available HW counters\n|-\n! UltraSparc II\n|2\n|-\n! Pentium III\n|2\n|-\n! ARM11\n|2\n|-\n! AMD Athlon\n| 4\n|-\n! IA-64\n|4\n|-\n! ARM Cortex-A5\n|2\n|-\n! ARM Cortex-A8\n|4\n|-\n! ARM Cortex-A9 MPCore\n|6\n|-\n! POWER4\n|8\n|-\n! Pentium 4\n|18\n|}\nVersus software techniques\nCompared to software profilers, hardware counters provide low-overhead access to a wealth of detailed performance information related to CPU's functional units, caches and main memory etc. Another benefit of using them is that no source code modifications are needed in general. However, the types and meanings of hardware counters vary from one kind of architecture to another due to the variation in hardware organizations.\nThere can be difficulties correlating the low level performance metrics back to source code.  The limited number of registers to store the counters often force users to conduct multiple measurements to collect all desired performance metrics.\nInstruction based sampling\n.]]\nModern superscalar processors schedule and execute multiple instructions out-of-order at one time. These \"in-flight\" instructions can retire at any time, depending on memory access, hits in cache, stalls in the pipeline and many other factors. This can cause performance counter events to be attributed to the wrong instructions, making precise performance analysis difficult or impossible.\nAMD introduced methods to mitigate some of these drawbacks. For example, the Opteron processors have implemented  in 2007 a technique known as Instruction Based Sampling (IBS). AMD's implementation of IBS provides hardware counters for both fetch sampling (the front of the superscalar pipeline) and op sampling (the back of the pipeline). This results in discrete performance data associating retired instructions with the \"parent\" AMD64 instruction.\nSee also\n* perf (Linux)\n* Row hammer\nReferences"
    }
  ]
}