{
  "content": [
    {
      "type": "text",
      "text": "# Top (software)\n\n| latest release version =\n| latest release date    =\n| genre                  = Process viewer / System monitor\n| license                =\n| website                = hide\n| operating_system       = Unix-like\n| programming_language   = C\n}}\ntop is a task manager or system monitor program, found in many Unix-like operating systems, that displays information about CPU and memory utilization.\nOverview\nThe program produces an ordered list of running processes selected by user-specified criteria, and updates it periodically. Default ordering is by CPU usage, and only the top CPU consumers are shown (hence the name). top shows how much processing power and memory are being used, as well as other information about the running processes. Some versions of top allow extensive customization of the display, such as choice of columns or sorting method.\ntop is useful for system administrators, as it shows which users and processes are consuming the most system resources at any given time.\nImplementations\nThere are several different versions of top. The traditional Unix version was written by William LeFebvre and originally copyrighted in 1984. It is hosted on SourceForge, and release 3.7 was announced in 2008.\nThe Linux version of top is part of the procps-ng group of tools. It was originally written by Roger Binns and released in early 1992 but shortly thereafter taken over by others.\nOn Solaris, the roughly equivalent program is prstat. Microsoft Windows has the tasklist command and the graphical Task Manager utility. IBM AIX has an updating running processes list as part of the topas and topas_nmon commands.\nThe load average numbers in Linux refers to the sum of the number of processes waiting in the run-queue plus the number currently executing. The number is absolute, not relative. And thus it can be unbounded; unlike utilization. The instant variations of the number of processes are damped with an exponential decay formula which is calculated using fixed point math.\nThe ps program is similar to top, but instead produces a snapshot of processes taken at the time of invocation. top's  (number of iterations) option can product a similar result, causing the program to run the specified number of iterations, then exit after printing its output.\nExample\nThe first 5 rows overview the entire system.\n, ,  :\n: 1552 total,   8 running, 1544 sleeping,   0 stopped,   0 zombie\n:  9.6 ,  0.7 ,  0.0 , 89.5 ,  0.0 ,  0.0 ,  0.2 ,  0.0\n: 1031911.+total, 368915.2 free, 172285.0 used, 490711.5 buff/cache\n:   2048.0 total,   2048.0 free,      0.0 used. 807110.1 avail Mem\n}}\n;: The exponential moving average of the run-queue length over the past 1/5/15 minutes. The run-queue includes both processes being run and waiting to be run. At complete utilization with no task switching, the load average is equal to the number of CPUs.\n;: counts the processes their statuses.\n;: counts the percentage of CPU usage, broken down into categories.\n;: Memory usage in units of mebibyte. The buff/cache is for memory used by buffers and cache.\n;: Swap space usage in units of mebibyte. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. In this snapshot, there's a total of  of swap, all free, indicating that no swapping is occurring, which is good for performance.\n;: The amount of memory available for new applications, without swapping. This considers not just the unused RAM, but also the memory that can be reclaimed from RAM caches.\nThe rest of the text provides a table with each row being a process, with the following columns often used out of many possible columns (the choice and ordering of columns are configurable):\n1 root      20   0    2456   1612   1500 S   0.0   0.0   0:00.07 init(Ubuntu)\n4 root      20   0    2456      4      0 S   0.0   0.0   0:00.00 init\n656403 user2     20   0   80.0g   3.6g 370000 S 100.0   0.4   1594:38 python3\n2024198 longnam+  20   0   50.5g   4.7g 609200 S   1.6   0.5 204:46.85 long-name-proc\n2056804 longnam+  20   0  237.1g  31.1g  23.1g S 136.8   3.1  69:54.11 python3\n}}\n;: Process ID, a unique number identifying each running process.\n;: The user who started the process. If the username is too long, it is cut-off with a + at the end.\n;: Real-time priority of the task, computed by the system scheduler. Lower PR numbers are considered more important by the scheduler and more likely to be scheduled, which means it tends to have more CPU-time per real-time.\n;: The niceness of the task, manually set by users and administrators to influence the real-time priority. A lower nice value tends to favor the process, and a higher nice value tends to disfavor the process. It ranges from -20 (most favored) to 19 (least favored).\n;: Virtual memory size of the process. This includes all memory that the process can access, including memory that is swapped out, memory that is allocated but not used, and shared memory.\n;: Resident set size, the portion of a process's memory that is held in RAM. Compared with , this excludes memory that is swapped out, not yet used, or shared.\n;: Shared memory size: how much of the RAM claimed by the process is sharable with other processes.\n;: Status of process. The status can be:\n:\n;: The percentage of the CPU time that the process is currently using.\n;: The percentage of the physical RAM used by the process.\n;: The total CPU time the task has used since it started. This is shown in minutes:seconds . The plus sign in TIME+ means that it is accurate to 0.01 second. If it shows TIME then it is accurate to 1 second.\n;: The command line argument that started the process. Unlike USER , if the command is too long, it is cut-off without a + at the end.\nSee also\nReferences\nExternal links\n*\n*\n*\n* . A deep dive into the mechanics of top.\n*\n*"
    }
  ]
}