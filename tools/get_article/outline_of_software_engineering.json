{
  "content": [
    {
      "type": "text",
      "text": "# Outline of software engineering\n\nThe following outline is provided as an overview of and topical guide to software engineering:\nSoftware engineering &ndash; application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is the application of engineering to software.\nThe ACM Computing Classification system is a poly-hierarchical ontology that organizes the topics of the field and can be used in semantic web applications and as a de facto standard classification system for the field.   The major section \"Software and its Engineering\" provides an outline and ontology for software engineering.\nSoftware applications\nSoftware engineers build software (applications, operating systems, system software) that people use.\nApplications influence software engineering by pressuring developers to solve problems in new ways. For example, consumer software emphasizes low cost, medical software emphasizes high quality, and Internet commerce software emphasizes rapid development.\n*Business software\n**Accounting software\n*Analytics\n**Data mining closely related to database\n**Decision support systems\n*Airline reservations\n*Banking\n**Automated teller machines\n**Cheque processing\n**Credit cards\n*Commerce\n**Trade\n**Auctions (e.g. eBay)\n**Reverse auctions (procurement)\n**Bar code scanners\n*Compilers\n**Parsers\n**Compiler optimization\n**Interpreters\n**Linkers\n**Loaders\n*Communication\n**E-mail\n**Instant messengers\n**VOIP\n**Calendars — scheduling and coordinating\n**Contact managers\n*Computer graphics\n**Animation\n**Special effects for video and film\n**Editing\n**Post-processing\n*Cryptography\n*Databases, support almost every field\n*Embedded systems Both software engineers and traditional engineers write software control systems for embedded products.\n**Automotive software\n**Avionics software\n**Heating ventilating and air conditioning (HVAC) software\n**Medical device software\n**Telephony\n**Telemetry\n*Engineering All traditional engineering branches use software extensively. Engineers use spreadsheets, more than they ever used calculators. Engineers use custom software tools to design, analyze, and simulate their own projects, like bridges and power lines. These projects resemble software in many respects, because the work exists as electronic documents and goes through analysis, design, implementation, and testing phases. Software tools for engineers use the tenets of computer science; as well as the tenets of calculus, physics, and chemistry.\n**Computer Aided Design (CAD)\n**Electronic Design Automation (EDA)\n**Numerical Analysis\n**Simulation\n*File\n**FTP\n**File sharing\n**File synchronization\n*Finance\n**Bond market\n**Futures market\n**Stock market\n*Games\n**Poker\n**Multiuser Dungeons\n**Video games\n*Information systems, support almost every field\n**LIS Management of laboratory data\n**MIS Management of financial and personnel data\n*Logistics\n**Supply chain management\n*Manufacturing\n**Computer Aided Manufacturing (CAM)\n**Distributed Control Systems (DCS)\n*Music\n**Music sequencers\n**Sound effects\n**Music synthesis\n*Network Management\n**Network management system\n**Element Management System\n**Operations Support System\n**Business Support Systems\n*Networks and Internet\n**Domain Name System\n**Protocols\n**Routers\n*Office suites\n**Word processors\n**Spreadsheets\n**Presentations\n*Operating systems\n**Embedded\n**Graphical\n**Multitasking\n**Real-time\n*Robotics\n*Signal processing, encoding and interpreting signals\n**Image processing, encoding and interpreting visual information\n**Speech processing\n**Text recognition\n**Handwriting recognition\n*Simulation, supports almost every field.\n**Engineering, A software simulation can be cheaper to build and more flexible to change than a physical engineering model.\n**Sciences\n*Sciences\n**Genomics\n*Traffic Control\n**Air traffic control\n**Ship traffic control\n**Road traffic control\n*Training\n**Drill\n**Simulation\n**Testing\n*Visualization, supports almost every field\n**Architecture\n**Engineering\n**Sciences\n*Voting\n*World Wide Web\n**Browsers\n**Servers\nSoftware engineering topics\n{| class=\"wikitable\" style=\"text-align: center; width: 640px;\"\n|-\n! colspan=\"4\" | Programming languages\n|-\n| Ada || APL || B ||\n|-\n| COBOL || Pascal || C || C++\n|-\n| C# || Clojure || Common Lisp || D\n|-\n| ColdFusion || Delphi || Dylan || Eiffel\n|-\n| Erlang || Fortran || F# || Groovy\n|-\n| Java || Lasso || ML || OCaml\n|-\n| Perl || PHP || PL/SQL || Prolog\n|-\n| Go || Rust || Swift || JavaScript\n|-\n| Haskell || Python || Ruby || Scala\n|-\n| Scheme || Smalltalk || Tcl || T-SQL\n|-\n| Verilog || VHDL || Visual Basic || Visual Basic .NET\n|-\n! colspan=\"4\" | Assembly language • • •  Scripting language • • •  List of programming languages\n|}\nProgramming paradigm, based on a programming language technology\n*Object-oriented programming\n*Aspect-oriented programming\n*Functional decomposition\n*Structured programming\n*Rule-based programming\nDatabases\n*Hierarchical\n*Object\n*Relational\n*SQL/XML\n*SQL\n*NoSQL\nGraphical user interfaces\n*GTK+ GIMP Toolkit\n*wxWidgets\n*Ultimate++\n*Qt toolkit\n*FLTK\nProgramming tools\n*Configuration management and source code management\n**CVS\n**Subversion\n**Git\n**Mercurial\n**RCS\n**GNU Arch\n**LibreSource Synchronizer\n**Team Foundation Server\n**Visual Studio Team Services\n*Build tools\n**Make\n**Rake\n**Cabal\n**Ant\n**CADES\n**Nant\n**Maven\n**Final Builder\n**Gradle\n**Team Foundation Server\n**Visual Studio Team Services\n**Visual Build Pro\n*Editors\n**Integrated development environments (IDEs)\n**Text editors\n**Word processors\n* Parser creation tools\n** Yacc/Bison\n* Static code analysis tools\nLibraries\n*Component-based software engineering\nDesign languages\n*Unified Modeling Language (UML)\nPatterns, document many common programming and project management techniques\n*Anti-patterns\n*Patterns\nProcesses and methodologies\n*Agile\n**Agile software development\n**Extreme programming\n**Lean software development\n**Rapid application development (RAD)\n**Rational Unified Process\n**Scrum\n*Heavyweight\n**Cleanroom\n**ISO/IEC 12207 — software life cycle processes\n**ISO 9000 and ISO 9001\n*Process Models\n**CMM and CMMI/SCAMPI\n**ISO 15504 (SPICE)\n*Metamodels\n**ISO/IEC 24744\n**SPEM\nPlatforms\nA platform combines computer hardware and an operating system. As platforms grow more powerful and less costly, applications and tools grow more widely available.\n*BREW\n*Cray supercomputers\n*DEC minicomputers\n*IBM mainframes\n*Linux PCs\n*Classic Mac OS and macOS PCs\n*Microsoft .NET\n*Palm PDAs\n*Sun Microsystems Solaris\n*Windows PCs (Wintel)\n*Symbian OS\nOther Practices\n*Communication\n*Method engineering\n*Pair programming\n*Performance Engineering\n*Programming productivity\n*Refactoring\n*Software inspections/Code reviews\n*Software reuse\n*Systems integration\n*Teamwork\nOther tools\n*Decision tables\n*Feature\n*User stories\n*Use cases\nComputer science topics\nSkilled software engineers know a lot of computer science including what is possible and impossible, and what is easy and hard for software.\n*Algorithms, well-defined methods for solving specific problems.\n**Searching\n**Sorting\n**Parsing\n**Numerical analysis\n* Compiler theory\n**Yacc/Bison\n*Data structures, well-defined methods for storing and retrieving data.\n**Lists\n**Trees\n**Hash tables\n*Computability, some problems cannot be solved at all\n**List of unsolved problems in computer science\n**Halting problem\n*Complexity, some problems are solvable in principle, yet unsolvable in practice\n**NP completeness\n**Computational complexity theory\n*Formal methods\n**Proof of correctness\n**Program synthesis\n*Adaptive Systems\n**Neural Networks\n**Evolutionary Algorithms\nMathematics topics\nDiscrete mathematics is a key foundation of software engineering.\n*Number representation\n*Set (computer science)\n*Bags\n*Graphs\n**Sequences\n**Trees\n**Graph (data structure)\n*Logic\n**Deduction\n**First-order logic\n**Higher-order logic\n**Combinatory logic\n*Induction\n*Combinatorics\nOther\n*Domain knowledge\n*Statistics\n*Decision theory\n*Type theory\nLife cycle phases\n*Development life cycle phase\n**Requirements gathering / analysis\n**Software architecture\n**Computer programming\n**Testing, detects bugs\n***Black box testing\n***White box testing\n**Quality assurance, ensures compliance with process.\n*Product Life cycle phase and Project lifecycle\n**Inception\n**First development\n**Major release\n**Minor release\n**Bug fix release\n**Maintenance\n**Obsolescence\n*Release development stage, near the end of a release cycle\n**Alpha\n**Beta\n**Gold master\n**1.0; 2.0\n*Software development lifecycle\n**Waterfall model — Structured programming and Stepwise refinement\n**SSADM\n**Spiral model — Iterative development\n**V-model\n**Agile software development\n**DSDM\n**Chaos model — Chaos strategy\nDeliverables\nDeliverables must be developed for many SE projects. Software engineers rarely make all of these deliverables themselves. They usually cooperate with the writers, trainers, installers, marketers, technical support people, and others who make many of these deliverables.\n*Application software — the software\n*Database — schemas and data.\n*Documentation, online and/or print, FAQ, Readme, release notes, Help, for each role\n**User\n**Administrator\n**Manager\n**Buyer\n*Administration and Maintenance policy, what should be backed-up, checked, configured, ...\n*Installers\n*Migration\n**Upgrade from previous installations\n**Upgrade from competitor's installations\n*Training materials, for each role\n**User\n**Administrator\n**Manager\n**Buyer\n*Support info for computer support groups.\n*Marketing and sales materials\n**White papers, explain the technologies used in the applications\nBusiness roles\n*Operations\n**Users\n**Administrators\n**Managers\n**Buyers\n*Development\n**Analysts\n**Programmers\n**Testers\n**Managers\n*Business\n**Consulting — customization and installation of applications\n**Sales\n**Marketing\n**Legal — contracts, intellectual property rights\n**Privacy and Privacy engineering\n**Support — helping customers use applications\n**Personnel — hiring and training qualified personnel\n**Finance — funding new development\n*Academe\n**Educators\n**Researchers\nManagement topics\n*Leadership\n**Coaching\n**Communication\n**Listening\n**Motivation\n**Vision, SEs are good at this\n**Example, everyone follows a good example best\n*Human resource management\n**Hiring, getting people into an organization\n**Training\n**Evaluation\n*Project management\n**Goal setting\n**Customer interaction (Rethink)\n**Estimation\n**Risk management\n**Change management\n*Process management\n**Software development processes\n**Metrics\nBusiness topics\n*Quality programs\n**Malcolm Baldrige National Quality Award\n**Six Sigma\n**Total Quality Management (TQM)\nSoftware engineering profession\n*Software engineering demographics\n*Software engineering economics\n*CCSE\n*History of software engineering\n*Software engineering professionalism\n**Ethics\n**Licensing\n*Legal\n**Intellectual property\n**Consumer protection\nHistory of software engineering\nHistory of software engineering\nPioneers\nMany people made important contributions to SE technologies, practices, or applications.\n*John Backus: Fortran, first optimizing compiler, BNF\n*Victor Basili: Experience factory.\n*F.L. Bauer: Stack principle, popularized the term Software Engineering\n*Kent Beck: Refactoring, extreme programming, pair programming, test-driven development.\n*Tim Berners-Lee: World Wide Web\n*Barry Boehm: SE economics, COCOMO, Spiral model.\n*Grady Booch: Object-oriented design, UML.\n*Fred Brooks: Managed System 360 and OS 360. Wrote The Mythical Man-Month and No Silver Bullet.\n*Larry Constantine: Structured design, coupling, cohesion\n*Edsger Dijkstra: Wrote Notes on Structured Programming, A Discipline of Programming and Go To Statement Considered Harmful, algorithms, formal methods, pedagogy.\n*Michael Fagan: Software inspection.\n*Tom Gilb: Software metrics, Software inspection, Evolutionary Delivery (\"Evo\").\n*Adele Goldstine: Wrote the Operators Manual for the ENIAC, the first electronic digital computer, and trained some of the first human computers\n*Lois Haibt: FORTRAN, wrote the first parser\n*Margaret Hamilton: Coined the term \"software engineering\", developed Universal Systems Language\n*Mary Jean Harrold: Regression testing, fault localization\n*Grace Hopper: The first compiler (Mark 1), COBOL, Nanoseconds.\n*Watts Humphrey: Capability Maturity Model, Personal Software Process, fellow of the Software Engineering Institute.\n*Jean Ichbiah: Ada\n*Michael A. Jackson: Jackson Structured Programming, Jackson System Development\n*Bill Joy: Berkeley Unix, vi, Java.\n*Alan Kay: Smalltalk\n*Brian Kernighan: C and Unix.\n*Donald Knuth: Wrote The Art of Computer Programming, TeX, algorithms, literate programming\n*Nancy Leveson: System safety\n*Bertrand Meyer: Design by Contract, Eiffel programming language.\n*Peter G. Neumann: RISKS Digest, ACM Sigsoft.\n*David Parnas: Module design, social responsibility, professionalism.\n*Jef Raskin: Developed the original Macintosh GUI, authored The Humane Interface\n*Dennis Ritchie: C and Unix.\n*Winston W. Royce: Waterfall model.\n*Mary Shaw: Software architecture.\n*Richard Stallman: Founder of the Free Software Foundation\n*Linus Torvalds: Linux kernel, free software / open source development.\n*Will Tracz: Reuse, ACM Software Engineering Notes.\n*Gerald Weinberg: Wrote The Psychology of Computer Programming.\n*Elaine Weyuker: Software testing\n*Jeannette Wing: Formal specifications.\n*Ed Yourdon: Structured programming, wrote The Decline and Fall of the American Programmer.\nSee also\n*List of programmers\n*List of computer scientists\nNotable publications\n*About Face: The Essentials of User Interface Design by Alan Cooper, about user interface design.\n*The Capability Maturity Model by Watts Humphrey. Written for the Software Engineering Institute, emphasizing management and process. (See Managing the Software Process )\n*The Cathedral and the Bazaar by Eric Raymond about open source development.\n*The Decline and Fall of the American Programmer by Ed Yourdon predicts the end of software development in the U.S.\n*Design Patterns by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.\n*Extreme Programming Explained by Kent Beck\n*\"[https://web.archive.org/web/20070703050443/http://www.acm.org/classics/oct95/ Go To Statement Considered Harmful]\" by Edsger Dijkstra.\n*\"Internet, Innovation and Open Source:Actors in the Network\" — First Monday article by Ilkka Tuomi (2000) [http://www.firstmonday.org/issues/issue6_1/tuomi/#t9 source]\n*The Mythical Man-Month by Fred Brooks, about project management.\n*Object-oriented Analysis and Design by Grady Booch.\n*Peopleware by Tom DeMarco and Tim Lister.\n*The pragmatic engineer versus the scientific designer by E. W. Dijkstra [https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD690.html]\n*Principles of Software Engineering Management by Tom Gilb about evolutionary processes.\n*The Psychology of Computer Programming by Gerald Weinberg. Written as an independent consultant, partly about his years at IBM.\n*Refactoring: Improving the Design of Existing Code by Martin Fowler, Kent Beck, John Brant, William Opdyke, and Don Roberts.\n*[http://www.pragmaticprogrammer.com The Pragmatic Programmer: from journeyman to master] by Andrew Hunt, and David Thomas.\n*Software Engineering Body of Knowledge (SWEBOK) ISO/IEC TR 19759\nRelated fields\n* Computer science\n* Information engineering\n*Information technology\n*Traditional engineering\n**Computer engineering\n**Electrical engineering\n*Software engineering\n**Domain engineering\n**Information technology engineering\n**Knowledge engineering\n**User interface engineering\n**Web engineering\n*Arts and Sciences\n**Mathematics\n**Computer science\n**Information science\n*Application software\n**Information systems\n*Programming\n* Systems Engineering\nSee also\n* Index of software engineering articles\n* Search-based software engineering\n* SWEBOK Software engineering body of knowledge\n* CCSE Computing curriculum for software engineering\n* Computer terms etymology, the origins of computer terms\n* Complexity or scaling\n* Second system syndrome\n* optimization\n* Source code escrow\n* Feature interaction problem\n* Certification (software engineering)\n* Engineering disasters#Failure due to software\n* Outline of software development\n* List of software development philosophies\nReferences\nExternal links\n*[https://dl.acm.org/ccs ACM Computing Classification System]\n*[http://www.swebok.org Guide to the Software Engineering Body of Knowledge (SWEBOK)]\n;Professional organizations\n* [http://www.bcs.org/ British Computer Society]\n* [http://www.acm.org/ Association for Computing Machinery]\n* [http://www.computer.org/ IEEE Computer Society]\n; Professionalism\n* [http://www.computer.org/tab/seprof/code.htm SE Code of Ethics]\n* [http://www.tbpe.state.tx.us/nm/sofupdt.htm Professional licensing in Texas]\n; Education\n* [http://sites.computer.org/ccse/ CCSE Undergraduate curriculum]\n; Standards:\n* [https://web.archive.org/web/20010216075021/http://standards.ieee.org/software/index.html IEEE Software Engineering Standards]\n* [http://www.ietf.org/ Internet Engineering Task Force]\n* [http://www.iso.org/ ISO]\n; Government organizations:\n* [http://www.esi.es European Software Institute]\n* [http://www.sei.cmu.edu/ Software Engineering Institute]\n; Agile:\n* [http://www.agilealliance.org/ Organization to promote Agile software development]\n* [http://www.testdriven.com Test driven development]\n* [http://www.extremeprogramming.org Extreme programming]\n; Other organizations:\n* [https://web.archive.org/web/20070202125936/http://www.software-engineer.org/ Online community for software engineers]\n* [http://www.ses.org/ Software Engineering Society]\n; Demographics\n* [http://www.bls.gov/oco/ocos267.htm U.S. Bureau of Labor Statistics on SE]\n;Surveys:\n* [http://www.ics.uci.edu/~redmiles/ David Redmiles page from the University of California site]\n;Other:\n* [http://homepages.cs.ncl.ac.uk/brian.randell/NATO/ Full text in PDF from the NATO conference in Garmisch]\n* [http://catless.ncl.ac.uk/Risks Computer Risks] Peter G. Neumann's risks column."
    }
  ]
}