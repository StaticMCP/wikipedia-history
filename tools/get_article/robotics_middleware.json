{
  "content": [
    {
      "type": "text",
      "text": "# Robotics middleware\n\nRobotics middleware is middleware to be used in complex robot control software systems.\n:\"...robotic middleware is designed to manage the complexity and heterogeneity of the hardware and applications, promote the integration of new technologies, simplify software design, hide the complexity of low-level communication and the sensor heterogeneity of the sensors, improve software quality, reuse robotic software infrastructure across multiple research efforts, and to reduce production costs.\"\nIt can be described as \"software glue\" to make it easier for robot builders focus on their specific problem area.\nRobotics middleware projects\nA wide variety of projects for robotics middleware exist, but no one of these dominates - and in fact many robotic systems do not use any middleware. Middleware products rely on a wide range of different standards, technologies, and approaches that make their use and interoperation difficult, and some developers may prefer to integrate their system themselves.\nPlayer Project\nThe Player Project (formerly the Player/Stage Project) is a project to create free software for research into robotics and sensor systems. Its components include the Player network server and the Stage robot platform simulators. Although accurate statistics are hard to obtain, Player is one of the most popular open-source robot interfaces in research and post-secondary education. Most of the major intelligent robotics journals and conferences regularly publish papers featuring real and simulated robot experiments using Player and Stage.\nRT-middleware\nRT-middleware is a common platform standards for Robots based on distributed object technology. RT-middleware supports the construction of various networked robotic systems by the integration of various network-enabled robotic elements called RT-Components. The specification standard of RT-components is discussed and defined by the Object Management Group (OMG).\nUrbi\nUrbi is an open source cross-platform software platform in C++ used to develop applications for robotics and complex systems. It is based on the UObject distributed C++ component architecture. It also includes the urbiscript orchestration language which is a parallel and event-driven script language. UObject components can be plugged into urbiscript and appear as native objects that can be scripted to specify their interactions and data exchanges. UObjects can be linked to the urbiscript interpreter, or executed as autonomous processes in \"remote\" mode, either in another thread, another process, a machine on the local network, or a machine on a distant network.\nMIRO\n[https://www.openhub.net/p/miro-middleware/ Miro] is a distributed object oriented framework for mobile robot control, based on CORBA (Common Object Request Broker Architecture) technology.\nThe Miro core components have been developed under the aid of ACE (Adaptive Communications Environment), an object oriented multi-platform framework for OS-independent interprocess, network and real time communication. They use TAO (The ACE ORB) as their ORB (Object Request Broker), a CORBA implementation designed for high performance and real time applications.\nCurrently supported platforms include Pioneers, the B21, some robot soccer robots and various robotic sensors.\nOrca\n[https://orca-robotics.sourceforge.net/ Orca] describes its goals as:\n* to enable software reuse by defining a set of commonly used interfaces;\n* to simplify software reuse by providing libraries with a high-level convenient API; and\n* to encourage software reuse by maintaining a repository of components.\nThey also state: \"To be successful, we think that a framework with such objectives must be: general, flexible and extensible; sufficiently robust, high-performance and full-featured for use in commercial applications, yet sufficiently simple for experimentation in university research environments.\"\nThey describe their approach as:\n* adopts a Component-Based Software Engineering approach without applying any additional architectural constraints\n* uses a commercial open-source library for communication and interface definition\n* provides tools to simplify component development but makes them strictly optional to maintain full access to the underlying communication engine and services\n* uses cross-platform development tools\nOrca software is released under LGPL and GPL licenses.\nOpenRDK\n[http://openrdk.sf.net/ OpenRDK] is an open-source software framework for robotics for developing loosely coupled modules. It provides transparent concurrency management, inter-process (via sockets) and intra-process (via shared memory) blackboard-based communication and a linking technique that allows for input/output data ports conceptual system design. Modules for connecting to simulators and generic robot drivers are provided.\nRock\n[https://robotik.dfki-bremen.de/en/research/softwaretools/rock.html Rock] (Robot Construction Kit), is a software framework for the development of robotic systems. The underlying component model is based on the Orocos RTT (Real Time Toolkit). Rock provides all the tools required to set up and run high-performance and reliable robotic systems for wide variety of applications in research and industry. It contains a rich collection of ready to use drivers and modules for use in your own system, and can easily be extended by adding new components.\nISAAC SDK / Simulation\n[https://developer.nvidia.com/isaac-sdk ISAAC], The NVIDIA Isaac Software Development Kit (SDK) is a developer toolbox for accelerating the development and deployment of Artificial Intelligence-powered robots. The SDK includes the Isaac Robot Engine, packages with high-performance robotics algorithms (to perform perception and navigation), and hardware reference applications. Isaac Sim is a virtual robotics laboratory and a high-fidelity 3D world simulator. It accelerates research, design, and development in robotics by reducing cost and risk. Developers can quickly and easily train and test their robots in detailed, highly realistic scenarios. There is an open source community version available at GitHub with supported hardware platform includes BOM details, refer [https://github.com/nvidia-isaac/kaya-robot kaya-robot]\nROS\n[http://www.ros.org/core-components/#communications_infrastructure ROS]  (Robot Operating System) is a collection of software frameworks for robot software development on a heterogeneous computer cluster. ROS provides standard operating system services such as hardware abstraction, low-level device control, implementation of commonly used functionality, message-passing between processes, and package management.\nYARP\nYARP is an open-source software package, written in C++ for interconnecting sensors, processors, and actuators in robots.\nDDX\n[https://research.csiro.au/software/spring/ DDX (Dynamic Data eXchange)] is (Linux/BSD/Unix) middleware developed by CSIRO to provide a lightweight real-time publish/subscribe service to distributed robot controllers. DDX allows a coalition of programs to share data at run-time through an efficient shared memory mechanism. Multiple machines can be linked by means of a global naming service and, when needed, data is multi-cast across machines. DDX was developed to automate a number of [https://research.csiro.au/robotics/our-work/solutions/miningtech/ large mining machines]: including draglines, LHD trucks, excavators and rock-breakers.\nSee also\n* Middleware for Robotic Applications\nReferences\nExternal links\n* [http://www.best-of-robotics.org/en/home.html BRICs]: a European project that attempts to establish best practices in robot development"
    }
  ]
}