{
  "content": [
    {
      "type": "text",
      "text": "# Glauber discovery system\n\nGlauber is a scientific discovery method written in the context of computational philosophy of science. It is related to machine learning in artificial intelligence.\nGlauber was written, among other programs, by Pat Langley, Herbert A. Simon, G. Bradshaw and J. Zytkow to demonstrate how scientific discovery may be obtained by problem solving methods, in their book Scientific Discovery, Computational Explorations on the Creative Mind.\nTheir programs simulate historical scientific discoveries based on the empirical evidence known at the time of discovery.\nGlauber was named after Johann Rudolph Glauber, a 17th-century alchemist whose work helped to develop acid-base theory. Glauber (the method) rediscovers the law of acid-alkali reactions producing salts, given the qualities of substances and observed facts, the result of mixing substances. From that knowledge Glauber discovers that substances that taste bitter react with substances tasting sour, producing substances tasting salty.\nIn few words, the law:\n: Acid + Alkali --> Salt\nGlauber was designed by Pat Langley as part of his work on discovery heuristics in an attempt to have a computer automatically review a host of values and characteristics and make independent analyses from them. In the case of Glauber, the goal was to have an autonomous application that could estimate, even perfectly describe, the nature of a given chemical compound by comparing it to related substances. Langley formalized and compiled Glauber in 1983.\nThe software were supplied with information about a variety of materials as they had been described by 17-18th century chemists, before most of modern chemical knowledge had been uncovered or invented. Qualitative descriptions like taste, rather than numerical data such as molecular weight, were programmed into the application. Chemical reactions that were known in that era and the distinction between reactants and products were also provided. From this knowledge, Glauber was to figure out which substances were acids, bases, and salts without any quantitative information. The system examined chemical substances and all of their most likely reactions and correlates the expected taste and related acidity or saltiness according to the rule that acids and bases produce salts.\nGlauber was a very successful advance in theoretical chemistry as performed by computer and it, along with similar systems developed by Herbert A. Simon including Stahl (which examines oxidation) and DALTON (which calculates atomic weight), helped form the groundwork of all current automated chemical analysis.\nThe Glauber method\nInformation representation (data structures)\nGlauber uses two predicates: Reacts and Has-Quality, represented in Lisp lists as follows:\n:(Reacts Inputs {reactant1 reactant2 ...} Outputs {product1 product2 ...})\n:(Has-Quality Object {substance} quality  {value})\nFor their experiment the authors used the following facts:\n:(Reacts Inputs {HCl NaOH} Outputs {NaCl})\n:(Reacts Inputs {HCl KOH} Outputs {KCl})\n:(Reacts Inputs {HNO3 NaOH} Outputs {NaNO3})\n:(Reacts Inputs {HNO3 KOH} Outputs {KNO3 })\n:(Has-Quality Object {HCl} Tastes {Sour})\n:(Has-Quality Object {HNO3} Tastes {Sour })\n:(Has-Quality Object {NaOH} Tastes {Bitter})\n:(Has-Quality Object {KOH} Tastes {Bitter})\n:(Has-Quality Object {NaCl} Tastes {Salty})\n:(Has-Quality Object {NaNO3} Tastes {Salty})\n:(Has-Quality Object {KCl} Tastes {Salty})\n:(Has-Quality Object {KNO3} Tastes {Salty})\nDiscovering the following law and equivalence classes:\n:Salts: {KNO3, KCl, NaNO3, NaCl}\n:Acids: {HCl, HNO3}\n:Alkalis: {NaOH, KOH}\n:∀ alkali ∀ acid ∃ salt (Reacts Inputs {acid, alkali} Outputs {salt})\n:∀ salt (Has-Quality Object {salt} Tastes {Salty})\n:∀ acid (Has-Quality Object {acid} Tastes {Sour})\n:∀ alkali (Has-Quality Object {alkali} Tastes {Bitter})\nThe modern notation with strings like: NaOH, HCl, etc., is used just as short substance names. Here they do not mean the chemical structure of the substances, which was not known at the time of the discovery; the program works with any name used in the 17th century like aqua regia, muriatic acid, etc.\nProcedures\nGlauber is based in two procedures: Form-Class and Determine-Quantifier.\nThe procedure Form-Class generalize the Reacts predicates by replacing the substance names by variables ranging on equivalence classes determined by a quality whose value distinguishes the substances in each class.\nIn the experiment designed by its authors, the substances are partitioned in three classes based in the value of the taste quality based on their values: acids (sour), alkalis (bitter) and salts (salty).\nGlauber main procedure\n: Input: Reacts and Has-Quality predicate sets\n: Output: On success returns a generalized version of the Reacts predicate whose variables range over the equivalence classes and a new Class predicate which is like Has-Quality having a name-class instead of substance name: (Has-Quality {class-name} quality {value})\n# If there are no more substance names in the Reacts predicates then finish\n# process the Reacts predicates with the Form-Class procedure\n# process the result of the previous step with Determine-Quantifier\n# go to step 3\nForm-Class\n: Input:  the Reacts and Has-Quality predicate sets\n: Output: a new substances class, a new Has-Quality and a new Reacts predicate set\n# Count the number of occurrences of each quality {value} in the Has-Quality predicates\n# Select the quality value with the largest number of occurrences, which substances are in the Reacts predicates\n# Create a name for the class\n# Generate a new Has-Quality predicate set removing all the predicates in Has-Quality with the selected quality {value} and adding the predicate (Has-Quality {class-name} quality {value}) to the Class predicates where class-name is the name obtained in step 3\n# Generate a new Reacts predicate set by replacing the name of the substance in the class formed in the step 2 by the name created in step 3\n# Create a new class extension by associating the name generated on step 3 with the set of all substances on the class selected on step 2\nDetermine-Quantifier\n:Input: the Reacts, Has-Quality and Class (generated by Form-Class) predicate sets\n:Output: An intentional quantified class corresponding to the extensional class generated by Form-Class, a new Reacts predicate set extended with the appropriate quantifier of the last discovered class received from Form-Class\n# Universally quantify the rule to determine the class\n#:(Has-Quality {class-name} quality {value}) => (∀ class-name (Has-Quality {class-name} quality {value}))\n# Generate Reacts predicates replacing each substance in the new class for its class-name in the Reacts predicates\n# if all the predicates generated in the previous step are contained in the original set\n#: then quantify universally\n#: else quantify existentially\nReferences"
    }
  ]
}