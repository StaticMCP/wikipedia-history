{
  "content": [
    {
      "type": "text",
      "text": "# Session hijacking__disambig_1\n\nIn computer science, session hijacking, sometimes also known as cookie hijacking, is the exploitation of a valid computer session—sometimes also called a session key—to gain unauthorized access to information or services in a computer system. In particular, it is used to refer to the theft of a magic cookie used to authenticate a user to a remote server. It has particular relevance to web developers, as the HTTP cookies used to maintain a session on many websites can be easily stolen by an attacker using an intermediary computer or with access to the saved cookies on the victim's computer (see HTTP cookie theft). After successfully stealing appropriate session cookies an adversary might use the Pass the Cookie technique to perform session hijacking. Cookie hijacking is commonly used against client authentication on the internet. Modern web browsers use cookie protection mechanisms to protect the web from being attacked.\nA popular method is using source-routed IP packets. This allows an attacker at point B on the network to participate in a conversation between A and C by encouraging the IP packets to pass through ''B's machine.\nIf source-routing is turned off, the attacker can use \"blind\" hijacking, whereby it guesses the responses of the two machines. Thus, the attacker can send a command, but can never see the response. However, a common command would be to set a password allowing access from elsewhere on the net.\nAn attacker can also be \"inline\" between A and C'' using a sniffing program to watch the conversation. This is known as a \"man-in-the-middle attack\".\nHistory of HTTP\nHTTP protocol versions 0.8 and 0.9 lacked cookies and other features necessary for session hijacking. Version 0.9beta of Mosaic Netscape, released on October 13, 1994, supported cookies.\nEarly versions of HTTP 1.0 did have some security weaknesses relating to session hijacking, but they were difficult to exploit due to the vagaries of most early HTTP 1.0 servers and browsers. As HTTP 1.0 has been designated as a fallback for HTTP 1.1 since the early 2000s—and as HTTP 1.0 servers are all essentially HTTP 1.1 servers the session hijacking problem has evolved into a nearly permanent security risk.\nThe introduction of supercookies and other features with the modernized HTTP 1.1 has allowed for the hijacking problem to become an ongoing security problem. Webserver and browser state machine standardization has contributed to this ongoing security problem.\nMethods\nThere are four main methods used to perpetrate a session hijack. These are:\n* Session fixation, where the attacker sets a user's session ID to one known to them, for example by sending the user an email with a link that contains a particular session ID. The attacker now only has to wait until the user logs in.\n* Session side jacking, where the attacker uses packet sniffing to read network traffic between two parties to steal the session cookie.  Many websites use SSL encryption for login pages to prevent attackers from seeing the password, but do not use encryption for the rest of the site once authenticated.  This allows attackers that can read the network traffic to intercept all the data that is submitted to the server or web pages viewed by the client.  Since this data includes the session cookie, it allows them to impersonate the victim, even if the password itself is not compromised.  Unsecured Wi-Fi hotspots are particularly vulnerable, as anyone sharing the network will generally be able to read most of the web traffic between other nodes and the access point.\n* Cross-site scripting, where the attacker tricks the user's computer into running code which is treated as trustworthy because it appears to belong to the server, allowing the attacker to obtain a copy of the cookie or perform other operations.\n*Malware and unwanted programs can use browser hijacking to steal a browser's cookie files without a user's knowledge, and then perform actions (like installing Android apps) without the user's knowledge. An attacker with physical access can simply attempt to steal the session key by, for example, obtaining the file or memory contents of the appropriate part of either the user's computer or the server.\nAfter successfully acquiring appropriate session cookies an adversary would inject the session cookie into their browser to impersonate the victim user on the website from which the session cookie was stolen from.\nTools used by attackers\nAttackers often rely on specialized tools to execute session hijacking attacks. One such tool is Firesheep, a Firefox extension introduced in October 2010. Firesheep demonstrated session hijacking vulnerabilities in unsecured networks by capturing unencrypted cookies from popular websites, allowing users to take over active sessions of others on the same network. The tool worked by displaying potential targets in a sidebar, enabling session access without password theft.\nAnother widely used tool is Wireshark, a network protocol analyzer that allows attackers to monitor and intercept data packets on unsecured networks. If a website does not encrypt its session cookies or authentication tokens, attackers can extract them and use them to gain unauthorized access to a victim’s account.\nExploits\nFiresheep\nFiresheep, a Firefox extension introduced in October 2010, demonstrated session hijacking vulnerabilities in unsecured networks. It captured unencrypted cookies from popular websites, allowing users to take over active sessions of others on the same network. The tool worked by displaying potential targets in a sidebar, enabling session access without password theft.  The websites supported included Facebook, Twitter, Flickr, Amazon, Windows Live and Google, with the ability to use scripts to add other websites. Only months later, Facebook and Twitter responded by offering (and later requiring) HTTP Secure throughout.\nDroidSheep\nDroidSheep is a simple Android tool for web session hijacking (sidejacking). It listens for HTTP packets sent via a wireless (802.11) network connection and extracts the session id from these packets in order to reuse them. DroidSheep can capture sessions using the libpcap library and supports: open (unencrypted) networks, WEP encrypted networks, and WPA/WPA2 encrypted networks (PSK only). This software uses libpcap and arpspoof. The apk was made available on Google Play but it has been taken down by Google.\nCookieCadger\nCookieCadger is a graphical Java app that automates sidejacking and replay of HTTP requests, to help identify information leakage from applications that use unencrypted GET requests. It is a cross-platform open-source utility based on the Wireshark suite which can monitor wired Ethernet, insecure Wi-Fi, or load a packet capture file for offline analysis. Cookie Cadger has been used to highlight the weaknesses of youth team sharing sites such as Shutterfly (used by AYSO soccer league) and TeamSnap.\nCookieMonster\nCookieMonster is a man-in-the-middle exploit where a third party can gain HTTPS cookie data when the \"Encrypted Sessions Only\" property is not properly set. This could allow access to sites with sensitive personal or financial information.  In 2008, this could affect major websites, including Gmail, Google Docs, eBay, Netflix, CapitalOne, Expedia.\nIt is a Python based tool, developed by security researcher Mike Perry.  Perry originally announced the vulnerability exploited by CookieMonster on BugTraq in 2007. A year later, he demonstrated CookieMonster as a proof of concept tool at Defcon 16.\nPrevention\nMethods to prevent session hijacking include:\n* Encryption of the data traffic passed between the parties by using SSL/TLS; in particular the session key (though ideally all traffic for the entire session). This technique is widely relied-upon by web-based banks and other e-commerce services, because it completely prevents sniffing-style attacks. However, it could still be possible to perform some other kind of session hijack. In response, scientists from the Radboud University Nijmegen proposed in 2013 a way to prevent session hijacking by correlating the application session with the SSL/TLS credentials\n* Use of a long random number or string as the session key. This reduces the risk that an attacker could simply guess a valid session key through trial and error or brute force attacks.\n* Regenerating the session id after a successful login. This prevents session fixation because the attacker does not know the session id of the user after they have logged in.\n* Some services make secondary checks against the identity of the user. For instance, a web server could check with each request made that the IP address of the user matched the one last used during that session. This does not prevent attacks by somebody who shares the same IP address, however, and could be frustrating for users whose IP address is liable to change during a browsing session.\n* Alternatively, some services will change the value of the cookie with each and every request. This dramatically reduces the window in which an attacker can operate and makes it easy to identify whether an attack has taken place, but can cause other technical problems (for example, two legitimate, closely timed requests from the same client can lead to a token check error on the server).\n* Users may also wish to log out of websites whenever they are finished using them. However this will not protect against attacks such as Firesheep.\nSee also\n*ArpON\n*Cross-site request forgery\n*HTTP cookie\n*TCP sequence prediction attack\nReferences"
    }
  ]
}