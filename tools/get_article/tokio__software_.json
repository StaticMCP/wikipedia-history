{
  "content": [
    {
      "type": "text",
      "text": "# Tokio (software)\n\n| discontinued =\n| latest release version =\n| latest release date =\n| latest preview version =\n| latest preview date =\n| programming language = Rust\n| operating system = Windows, Linux, macOS, FreeBSD, WebAssembly\n| size =\n| genre = Asynchronous runtime\n| license = MIT License\n| standard =\n| website =\n}}\nTokio is a software library for the Rust programming language. It provides a runtime and functions that enable the use of asynchronous I/O, allowing for concurrency in regards to task completion.\nTokio was released in August 2016 for Rust, a general-purpose programming language. Developed by Carl Lerche, Tokio began as a network application framework and supports features such as socket listening and broadcasting, allowing messages to be transferred between computers.\nHistory\nTokio began in August 2016 by Carl Lerche as a network application framework for Rust built on futures, allowing for network-based middleware and a non-blocking, or asynchronous, implementation of readiness interest to the reactor. Tokio was inspired by Finagle, a Scala-based asynchronous remote procedure call (RPC) system developed at Twitter for Java virtual machines (JVM), allowing distributed systems to communicate within a JVM. Tokio utilizes the lower-level Rust crate mio, itself using system calls such as epoll (Linux), kqueue (FreeBSD), and the input/output completion port (IOCP) API (Windows). For Linux it can also use io_uring via [https://github.com/tokio-rs/tokio-uring tokio-uring]. The name \"Tokio\" is derived from Tokyo and mio, and the Tokio logo vaguely resembles the city emblem of Tokyo. The preliminary version of Tokio was released in January 2017, followed by a full release in December 2020. In 2017, Tokio received a grant from the Mozilla Open Source Support fund. In April 2021, Tokio funded its first paid contributor, Alice Ryhl, for her work both developing the project and assisting its users.\nWhile Rust has supported asynchronous functions since version 1.39, released in November 2019, it provides no facilities to execute them, requiring an external runtime for that purpose. Tokio provides a runtime that uses a multi-threaded work stealing scheduler. Rust's futures are lazily evaluated, requiring functions to call .await before they do any work. When .await is invoked, Tokio's runtime may pause the original future until its I/O completes, and unpauses a different task that is ready for further processing.\nUsers of Tokio include the development teams behind Discord and AWS Lambda. The JavaScript and TypeScript runtime Deno uses Tokio under the hood, in comparison to the JavaScript runtime Node.js, which uses the libuv library.\nFeatures\nRuntime\nTokio allows for the execution of asynchronous functions in Rust through its built-in runtime, which may be initialized via the #[tokio::main] macro. For example:\nuse std::error::Error;\n#[tokio::main]\nasync fn main() -> Result> {\nlet url = \"https://en.wikipedia.org/\";\nlet text = reqwest::get(url).await?.text().await?;\nprintln!(\"{}\", text);\nOk(())\n}\nHere, the reqwest crate is used to request the HyperText Markup Language (HTML) for English Wikipedia. After reqwest::get is called to initialize the asynchronous request, .await will hand over control to the runtime, which then drives all the I/O operations of the request to completion before resuming the main function after the .await.\nA simple example of a TCP echo server is as follows:\nuse std::error::Error;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::net::TcpListener;\n#[tokio::main]\nasync fn main() -> Result> {\n// Run a server on port 8080.\nlet listener = TcpListener::bind(\"localhost:8080\").await?;\nloop {\n// Wait for a new connection from a client.\nlet (mut stream, _remote_addr) = listener.accept().await?;\n// Spawn a new asynchronous task to handle the connection.\ntokio::spawn(async move {\nlet (reader, mut writer) = stream.split();\nlet mut reader = BufReader::new(reader);\n// While there is data to be read from the stream…\nwhile !reader.fill_buf().await.unwrap().is_empty() {\n// Write the data back.\nwriter.write_all(reader.buffer()).await.unwrap();\n}\n});\n}\n}\nThis code makes use of the tokio::spawn function to create an asynchronous task (implemented as a stackless coroutine), allowing each connection to be handled separately in the same process, as the runtime ensures that tasks run in the background automatically. Importantly however, the runtime multiplexes the tasks’ execution on a single thread pool (whose size is by default equal to the number of processors on the system), and so in comparison to the approach of spawning a separate thread for each task, fewer resources are consumed.\nAsynchronous I/O and timers\nTokio provides several I/O and timing primitives that work natively inside its runtime. The TcpListener structure used above contains a Transmission Control Protocol (TCP) socket listener that is registered with the runtime, allowing it to be used asynchronously; similarly, the tokio::time::sleep function can be used to suspend a task’s execution for a certain duration of time, and again this is implemented by registration with the runtime.\nSynchronization primitives\nTokio also provides several generic synchronization primitives suitable for use in an asynchronous context, including locks, semaphores, barriers and channels. Unlike the I/O and timer primitives, these work even outside of the runtime context.\nBlocking thread pool\nTo facilitate interopability with traditional synchronous code, Tokio provides as part of its runtime a thread pool on which synchronous I/O operations may run. In particular, tokio::task::spawn_blocking creates a task which runs in this pool, and is allowed to perform blocking operations—this is unlike tokio::spawn, which may only run asynchronous code. For example, this is used to implement filesystem operations, as many platforms do not provide native asynchronous filesystem APIs (an exception to this is Linux’s io_uring, however support for this exists only in the external tokio_uring library and is not yet built in).\nReferences\nExternal links\n*\n*\n* [https://crates.io/crates/tokio Tokio] on crates.io"
    }
  ]
}