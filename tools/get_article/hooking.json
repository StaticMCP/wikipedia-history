{
  "content": [
    {
      "type": "text",
      "text": "# Hooking\n\nHook-up}}\nIn computer programming, hooking is a range of techniques used to alter or augment the behaviour of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a hook.\nHook methods are of particular importance in the template method pattern where common code in an abstract class can be augmented by custom code in a subclass. In this case each hook method is defined in the abstract class with an empty implementation which then allows a different implementation to be supplied in each concrete subclass.\nHooking is used for many purposes, including debugging and extending functionality.\nExamples might include intercepting keyboard or mouse event messages before they reach an application, or intercepting operating system calls in order to monitor behavior or modify the function of an application or other component. It is also widely used in benchmarking programs, for example frame rate measuring in 3D games, where the output and input is done through hooking.\nHooking can also be used by malicious code. For example, rootkits, pieces of software that try to make themselves invisible by faking the output of API calls that would otherwise reveal their existence, often use hooking techniques.\nMethods\nTypically hooks are inserted while software is already running, but hooking is a tactic that can also be employed prior to the application being started. Both these techniques are described in greater detail below.\nSource modification\nHooking can be achieved by modifying the source of the executable or library before an application is running, through techniques of reverse engineering. This is typically used to intercept function calls to either monitor or replace them entirely.\nFor example, by using a disassembler, the entry point of a function within a module can be found. It can then be altered to instead dynamically load some other library module and then have it execute desired methods within that loaded library. If applicable, another related approach by which hooking can be achieved is by altering the import table of an executable. This table can be modified to load any additional library modules as well as changing what external code is invoked when a function is called by the application.\nAn alternative method for achieving function hooking is by intercepting function calls through a wrapper library. A wrapper is a version of a library that an application loads, with all the same functionality of the original library that it will replace. That is, all the functions that are accessible are essentially the same between the original and the replacement. This wrapper library can be designed to call any of the functionality from the original library, or replace it with an entirely new set of logic.\nRuntime modification\nOperating systems and software may provide the means to easily insert event hooks at runtime. It is available provided that the process inserting the hook is granted enough permission to do so. Microsoft Windows for example, allows users to insert hooks that can be used to process or modify system events and application events for dialogs, scrollbars, and menus as well as other items.  It also allows a hook to insert, remove, process or modify keyboard and mouse events.  Linux provides another example where hooks can be used in a similar manner to process network events within the kernel through NetFilter.\nWhen such functionality is not provided, a special form of hooking employs intercepting the library function calls made by a process. Function hooking is implemented by changing the very first few code instructions of the target function to jump to an injected code. Alternatively on systems using the shared library concept, the interrupt vector table or the import descriptor table can be modified in memory. Essentially these tactics employ the same ideas as those of source modification, but instead altering instructions and structures located in the memory of a process once it is already running.\nSample code\nVirtual method table hooking\nWhenever a class defines/inherits a virtual function (or method), compilers add a hidden member variable to the class which points to a virtual method table (VMT or Vtable). Most compilers place the hidden VMT pointer at the first 4 bytes of every instance of the class. A VMT is basically an array of pointers to all the virtual functions that instances of the class may call. At runtime these pointers are set to point to the right functions, because at compile time, it is not yet known if the base function is to be called or if an overridden version of the function from a derived class is to be called (thereby allowing for polymorphism). Therefore, virtual functions can be hooked by replacing the pointers to them within any VMT that they appear. The code below shows an example of a typical VMT hook in Microsoft Windows, written in C++.\n#include\n#include \"windows.h\"\nusing namespace std;\nclass VirtualClass\n{\npublic:\nint number;\nvirtual void VirtualFn1() //This is the virtual function that will be hooked.\n{\ncout (myClass); //Find the address that points to the base of VirtualClass' VMT (which then points to VirtualFn1) and store it in vTablePtr.\nDWORD oldProtection;\nVirtualProtect(vTablePtr, 4, PAGE_EXECUTE_READWRITE, &oldProtection); //Removes page protection at the start of the VMT so we can overwrite its first pointer.\norig_VirtualFn1 = reinterpret_cast(*vTablePtr); //Stores the pointer to VirtualFn1 from the VMT in a global variable so that it can be accessed again later after its entry in the VMT has been\n//overwritten with our hook function.\n*vTablePtr = &hkVirtualFn1; //Overwrite the pointer to VirtualFn1 within the virtual table to a pointer to our hook function (hkVirtualFn1).\nVirtualProtect(vTablePtr, 4, oldProtection, 0); //Restore old page protection.\nmyClass->VirtualFn1(); //Call the virtual function from our class instance. Because it is now hooked, this will actually call our hook function (hkVirtualFn1).\nmyClass->VirtualFn1();\nmyClass->VirtualFn1();\ndelete myClass;\nreturn 0;\n}\nAll virtual functions must be class member functions, and all (non-static) class member functions are called with the __thiscall calling convention (unless the member function takes a variable number of arguments, in which case it is called with __cdecl). The __thiscall calling convention passes a pointer to the calling class instance (commonly referred to as a \"this\" pointer) via the ECX register (on the x86 architecture). Therefore, in order for a hook function to properly intercept the \"this\" pointer that is passed and take it as an argument, it must look into the ECX register. In the above example, this is done by setting the hook function (hkVirtualFn1) to use the __fastcall calling convention, which causes the hook function to look into the ECX register for one of its arguments.\nAlso note that, in the above example, the hook function (hkVirtualFn1) is not a member function itself so it cannot use the __thiscall calling convention. __fastcall has to be used instead because it is the only other calling convention that looks into the ECX register for an argument.\nC# keyboard event hook\nThe following example will hook into   keyboard events in Microsoft Windows using the Microsoft .NET Framework.\nusing System.Runtime.InteropServices;\nnamespace Hooks;\npublic class KeyHook\n{\n/* Member variables */\nprotected static int Hook;\nprotected static LowLevelKeyboardDelegate Delegate;\nprotected static readonly object Lock = new object();\nprotected static bool IsRegistered = false;\n/* DLL imports */\n[DllImport(\"user32\")]\nprivate static extern int SetWindowsHookEx(int idHook, LowLevelKeyboardDelegate lpfn,\nint hmod, int dwThreadId);\n[DllImport(\"user32\")]\nprivate static extern int CallNextHookEx(int hHook, int nCode, int wParam, KBDLLHOOKSTRUCT lParam);\n[DllImport(\"user32\")]\nprivate static extern int UnhookWindowsHookEx(int hHook);\n/* Types & constants */\nprotected delegate int LowLevelKeyboardDelegate(int nCode, int wParam, ref KBDLLHOOKSTRUCT lParam);\nprivate const int HC_ACTION = 0;\nprivate const int WM_KEYDOWN = 0x0100;\nprivate const int WM_KEYUP = 0x0101;\nprivate const int WH_KEYBOARD_LL = 13;\n[StructLayout(LayoutKind.Sequential)]\npublic struct KBDLLHOOKSTRUCT\n{\npublic int vkCode;\npublic int scanCode;\npublic int flags;\npublic int time;\npublic int dwExtraInfo;\n}\n/* Methods */\nstatic private int LowLevelKeyboardHandler(int nCode, int wParam, ref KBDLLHOOKSTRUCT lParam)\n{\nif (nCode  HC_ACTION)\n{\nif (wParam  WM_KEYDOWN)\nSystem.Console.Out.WriteLine(\"Key Down: \" + lParam.vkCode);\nelse if (wParam == WM_KEYUP)\nSystem.Console.Out.WriteLine(\"Key Up: \" + lParam.vkCode);\n}\nreturn CallNextHookEx(Hook, nCode, wParam, lParam);\n}\npublic static bool RegisterHook()\n{\nlock (Lock)\n{\nif (IsRegistered)\nreturn true;\nDelegate = LowLevelKeyboardHandler;\nHook = SetWindowsHookEx(\nWH_KEYBOARD_LL, Delegate,\nMarshal.GetHINSTANCE(\nSystem.Reflection.Assembly.GetExecutingAssembly().GetModules()[0]\n).ToInt32(), 0\n);\nif (Hook != 0)\nreturn IsRegistered = true;\nDelegate = null;\nreturn false;\n}\n}\npublic static bool UnregisterHook()\n{\nlock (Lock)\n{\nreturn IsRegistered = (UnhookWindowsHookEx(Hook) != 0);\n}\n}\n}\nAPI/function hooking/interception using JMP instruction aka splicing\nThe following source code is an example of an API/function hooking method which hooks by overwriting the first six bytes of a destination function with a JMP instruction to a new function. The code is compiled into a DLL file then loaded into the target process using any method of DLL injection. Using a backup of the original function one might then restore the first six bytes again so the call will not be interrupted. In this example the win32 API function MessageBoxW is hooked.\n/*\nThis idea is based on chrom-lib approach, Distributed under GNU LGPL License.\nSource chrom-lib: https://github.com/linuxexp/chrom-lib\nCopyright (C) 2011  Raja Jamwal\n*/\n#include\n#define SIZE 6\ntypedef int (WINAPI *pMessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT);  // Messagebox prototype\nint WINAPI MyMessageBoxW(HWND, LPCWSTR, LPCWSTR, UINT);            // Our detour\nvoid BeginRedirect(LPVOID);\npMessageBoxW pOrigMBAddress = NULL;                                // address of original\nBYTE oldBytes[SIZE] = {0};                                         // backup\nBYTE JMP[SIZE] = {0};                                              // 6 byte JMP instruction\nDWORD oldProtect, myProtect = PAGE_EXECUTE_READWRITE;\nINT APIENTRY DllMain(HMODULE hDLL, DWORD Reason, LPVOID Reserved)\n{\nswitch (Reason)\n{\ncase DLL_PROCESS_ATTACH:                                        // if attached\npOrigMBAddress = (pMessageBoxW)\nGetProcAddress(GetModuleHandleA(\"user32.dll\"),              // get address of original\n\"MessageBoxW\");\nif (pOrigMBAddress != NULL)\nBeginRedirect(MyMessageBoxW);                               // start detouring\nbreak;\ncase DLL_PROCESS_DETACH:\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE, myProtect, &oldProtect);   // assign read write protection\nmemcpy(pOrigMBAddress, oldBytes, SIZE);                                 // restore backup\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE, oldProtect, &myProtect);   // reset protection\ncase DLL_THREAD_ATTACH:\ncase DLL_THREAD_DETACH:\nbreak;\n}\nreturn TRUE;\n}\nvoid BeginRedirect(LPVOID newFunction)\n{\nBYTE tempJMP[SIZE] = {0xE9, 0x90, 0x90, 0x90, 0x90, 0xC3};              // 0xE9 = JMP 0x90 = NOP 0xC3 = RET\nmemcpy(JMP, tempJMP, SIZE);                                             // store jmp instruction to JMP\nDWORD JMPSize = ((DWORD)newFunction - (DWORD)pOrigMBAddress - 5);       // calculate jump distance\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE,                            // assign read write protection\nPAGE_EXECUTE_READWRITE, &oldProtect);\nmemcpy(oldBytes, pOrigMBAddress, SIZE);                                 // make backup\nmemcpy(&JMP[1], &JMPSize, 4);                                           // fill the nop's with the jump distance (JMP,distance(4bytes),RET)\nmemcpy(pOrigMBAddress, JMP, SIZE);                                      // set jump instruction at the beginning of the original function\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE, oldProtect, &myProtect);   // reset protection\n}\nint WINAPI MyMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uiType)\n{\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE, myProtect, &oldProtect);   // assign read write protection\nmemcpy(pOrigMBAddress, oldBytes, SIZE);                                 // restore backup\nint retValue = MessageBoxW(hWnd, lpText, lpCaption, uiType);            // get return value of original function\nmemcpy(pOrigMBAddress, JMP, SIZE);                                      // set the jump instruction again\nVirtualProtect((LPVOID)pOrigMBAddress, SIZE, oldProtect, &myProtect);   // reset protection\nreturn retValue;                                                        // return original return value\n}\nNetfilter hook\nThis example shows how to use hooking to alter network traffic in the Linux kernel using Netfilter.\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n#include\n/* Port we want to drop packets on */\nstatic const uint16_t port = 25;\n/* This is the hook function itself */\nstatic unsigned int hook_func(unsigned int hooknum,\nstruct sk_buff **pskb,\nconst struct net_device *in,\nconst struct net_device *out,\nint (*okfn)(struct sk_buff *))\n{\nstruct iphdr *iph = ip_hdr(*pskb);\nstruct tcphdr *tcph, tcpbuf;\nif (iph->protocol != IPPROTO_TCP)\nreturn NF_ACCEPT;\ntcph = skb_header_pointer(*pskb, ip_hdrlen(*pskb), sizeof(*tcph), &tcpbuf);\nif (tcph  NULL)\nreturn NF_ACCEPT;\nreturn (tcph->dest  port) ? NF_DROP : NF_ACCEPT;\n}\n/* Used to register our hook function */\nstatic struct nf_hook_ops nfho = {\n.hook     = hook_func,\n.hooknum  = NF_IP_PRE_ROUTING,\n.pf       = NFPROTO_IPV4,\n.priority = NF_IP_PRI_FIRST,\n};\nstatic __init int my_init(void)\n{\nreturn nf_register_hook(&nfho);\n}\nstatic __exit void my_exit(void)\n{\nnf_unregister_hook(&nfho);\n}\nmodule_init(my_init);\nmodule_exit(my_exit);\nInternal IAT hooking\nThe following code demonstrates how to hook functions that are imported from another module.\nThis can be used to hook functions in a different process from the calling process. For this the code must be compiled into a DLL file then loaded into the target process using any method of DLL injection.\nThe advantage of this method is that it is less detectable by antivirus software and/or anti-cheat software, one might make this into an external hook that doesn't make use of any malicious calls.\nThe Portable Executable header contains the Import Address Table (IAT), which can be manipulated as shown in the source below. The source below runs under Microsoft Windows.\n#include\ntypedef int(__stdcall *pMessageBoxA) (HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); //This is the 'type' of the MessageBoxA call.\npMessageBoxA RealMessageBoxA; //This will store a pointer to the original function.\nvoid DetourIATptr(const char* function, void* newfunction, HMODULE module);\nint __stdcall NewMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) { //Our fake function\nprintf(\"The String Sent to MessageBoxA Was : %s\\n\", lpText);\nreturn RealMessageBoxA(hWnd, lpText, lpCaption, uType); //Call the real function\n}\nint main(int argc, CHAR *argv[]) {\nDetourIATptr(\"MessageBoxA\",(void*)NewMessageBoxA,0); //Hook the function\nMessageBoxA(NULL, \"Just A MessageBox\", \"Just A MessageBox\", 0); //Call the function -- this will invoke our fake hook.\nreturn 0;\n}\nvoid **IATfind(const char *function, HMODULE module) { //Find the IAT (Import Address Table) entry specific to the given function.\nint ip = 0;\nif (module == 0)\nmodule = GetModuleHandle(0);\nPIMAGE_DOS_HEADER pImgDosHeaders = (PIMAGE_DOS_HEADER)module;\nPIMAGE_NT_HEADERS pImgNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pImgDosHeaders + pImgDosHeaders->e_lfanew);\nPIMAGE_IMPORT_DESCRIPTOR pImgImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)pImgDosHeaders + pImgNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\nif (pImgDosHeaders->e_magic != IMAGE_DOS_SIGNATURE)\nprintf(\"libPE Error : e_magic is no valid DOS signature\\n\");\nfor (IMAGE_IMPORT_DESCRIPTOR *iid = pImgImportDesc; iid->Name != NULL; iid++) {\nfor (int funcIdx = 0; *(funcIdx + (LPVOID*)(iid->FirstThunk + (SIZE_T)module)) != NULL; funcIdx++) {\nchar *modFuncName = (char*)(*(funcIdx + (SIZE_T*)(iid->OriginalFirstThunk + (SIZE_T)module)) + (SIZE_T)module + 2);\nconst uintptr_t nModFuncName = (uintptr_t)modFuncName;\nbool isString = !(nModFuncName & (sizeof(nModFuncName) == 4 ? 0x80000000 : 0x8000000000000000));\nif (isString) {\nif (!_stricmp(function, modFuncName))\nreturn funcIdx + (LPVOID*)(iid->FirstThunk + (SIZE_T)module);\n}\n}\n}\nreturn 0;\n}\nvoid DetourIATptr(const char *function, void *newfunction, HMODULE module) {\nvoid **funcptr = IATfind(function, module);\nif (*funcptr == newfunction)\nreturn;\nDWORD oldrights, newrights = PAGE_READWRITE;\n//Update the protection to READWRITE\nVirtualProtect(funcptr, sizeof(LPVOID), newrights, &oldrights);\nRealMessageBoxA = (pMessageBoxA)*funcptr; //Some compilers require the cast (like \"MinGW\"), not sure about MSVC though\n*funcptr = newfunction;\n//Restore the old memory protection flags.\nVirtualProtect(funcptr, sizeof(LPVOID), oldrights, &newrights);\n}\nSee also\n* Callback (computer science)\n* Delegation (programming)\n* Terminate-and-stay-resident program\n* User exit\nReferences\n*\n*\n*  [2012-06-29:  Link appears to be dead]\nExternal links\nWindows\n* [http://sandsprite.com/CodeStuff/IAT_Hooking.html Information on Import Address Table function hooking.]\n* [http://msdn.microsoft.com/en-us/library/ms632589(VS.85).aspx Information from Microsoft on hooking]\n* [http://jbremer.org/x86-api-hooking-demystified/ Information and various techniques regarding x86 hooking.]\n* [http://www.internals.com/ APISpy32] is an application used to hook win32 API.\n* [http://research.microsoft.com/sn/detours Detours] is a general purpose function hooking library created by Microsoft Research which works in C / C++.\n* [http://www.codeproject.com/KB/threads/winspy.aspx winspy] Three ways to inject code into another process.\n* [http://www.codeproject.com/KB/system/hooksys.aspx HookTool SDK (ACF SDK)] Provides a comprehensive overview on API hooking and code injection. A commercial product available too.\n* [http://help.madshi.net/ApiCodeHooking.htm madCodeHook] is a commercial x86 and x64 API hooking and DLL injection library for C++ and Delphi.\n* [https://easyhook.github.io/ EasyHook] is an open source hooking engine supporting x86 and x64 in Windows in both user and kernel land.\n* [http://www.nektra.com/products/spystudio-api-monitor/ SpyStudio Application Trace] SpyStudio is an Application tracer which hook calls, displaying the results in a structured way.\n* [http://www.rohitab.com/apimonitor rohitab.com API Monitor] is a freeware application that can hook and display 10,000+ Windows APIs and COM Interfaces in 32-bit and 64-bit applications and services.\n* [http://www.nektra.com/products/deviare-api-hook-windows/ Deviare API Hook] Deviare is a freeware inter-process hook framework that can be used to intercept other processes' API calls and show full-parameter information or create API monitors.\n* [http://jacquelin.potier.free.fr/winapioverride32/ WinAPIOverride] WinAPIOverride is a freeware for non commercial use. It can hook win32 API, COM, OLE, ActiveX, .NET in 32-bit and 64-bit processes. It includes monitoring post analysis tools.\n* [https://github.com/urShadow/urmem urmem] C++11 cross-platform library (x86) for working with memory (hooks, patches, pointer's wrapper, signature scanner etc.)\nLinux\n* [https://web.archive.org/web/20070610083142/http://rtg.informatik.tu-chemnitz.de/docs/da-sa-txt/sa-dienelt.pdf] A student research project that utilizes hooking.\n* [https://web.archive.org/web/20090317112907/http://www.linuxmanpages.com/man2/ptrace.2.php] Functionality that allows a piece of software to observe and control the execution of another process.\n* [http://securityvulns.ru/articles/reveng/] Use of LD_PRELOAD to hook shared library calls.\nEmacs\n* [https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html Emacs Hooks] Hooks are an important mechanism for customization of Emacs. A hook is a Lisp variable which holds a list of functions, to be called on some well-defined occasion. (This is called running the hook.)\nOS X and iOS\n* [http://cydiasubstrate.com Cydia Substrate] is a framework for jailbroken iOS devices allowing developers to hook into any other framework or application.\n* [https://github.com/jndok/harpoon harpoon] is an OS X library for runtime function hooking.\nIn Depth API Hooking\n* [http://jbremer.org/x86-api-hooking-demystified/ x86 API Hooking Demystified] Article on various API Hooking methods, for the x86 architecture."
    }
  ]
}