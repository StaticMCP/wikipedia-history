{
  "content": [
    {
      "type": "text",
      "text": "# Software testability\n\nSoftware testability is the degree to which a software artifact (e.g. a software system, module, requirement, or design document) supports testing in a given test context. If the testability of an artifact is high, then finding faults in the system (if any) by means of testing is easier.\nFormally, some systems are testable, and some are not. This classification can be achieved by noticing that, to be testable, for a functionality of the system under test \"S\", which takes input \"I\", a computable functional predicate \"V\" must exists such that V(S,I) is true when S, given input I, produce a valid output, false otherwise. This function \"V\" is known as the verification function for the system with input I.\nMany software systems are untestable, or not immediately testable. For example, Google's ReCAPTCHA, without having any metadata about the images is not a testable system. Recaptcha, however, can be immediately tested if for each image shown, there is a tag stored elsewhere. Given this meta information, one can test the system.\nTherefore, testability is often thought of as an extrinsic property which results from interdependency of the software to be tested and the test goals, test methods used, and test resources (i.e., the test context). Even though testability can not be measured directly (such as software size) it should be considered an intrinsic property of a software artifact because it is highly correlated with other key software qualities such as encapsulation, coupling, cohesion, and redundancy.\nThe correlation of 'testability' to good design can be observed by seeing that code that has weak cohesion, tight coupling, redundancy and lack of encapsulation is difficult to test.\nA lower degree of testability results in increased test effort. In extreme cases a lack of testability may hinder testing parts of the software or software requirements at all.\nBackground\nTestability, a property applying to empirical hypothesis, involves two components.\nThe effort and effectiveness of software tests depends on numerous factors including:\n* Properties of the software requirements\n* Properties of the software itself (such as size, complexity and testability)\n* Properties of the test methods used\n* Properties of the development- and testing processes\n* Qualification and motivation of the persons involved in the test process\nTestability of software components\nThe testability of software components (modules, classes) is determined by factors such as:\n* Controllability: The degree to which it is possible to control the state of the component under test (CUT) as required for testing.\n* Observability: The degree to which it is possible to observe (intermediate and final) test results.\n* Isolateability: The degree to which the component under test (CUT) can be tested in isolation.\n* Separation of concerns: The degree to which the component under test has a single, well defined responsibility.\n* Understandability: The degree to which the component under test is documented or self-explaining.\n* Automatability: The degree to which it is possible to automate testing of the component under test.\n* Heterogeneity: The degree to which the use of diverse technologies requires to use diverse test methods and tools in parallel.\nThe testability of software components can be improved by:\n* Test-driven development\n* Design for testability (similar to design for test in the hardware domain)\nTestability of requirements\nRequirements need to fulfill the following criteria in order to be testable:\n* consistent\n* complete\n* unambiguous\n* quantitative (a requirement like \"fast response time\" can not be verification/verified)\n* verification/verifiable in practice (a test is feasible not only in theory but also in practice with limited resources)\nTreating the requirement as axioms, testability can be treated via asserting existence of a function  F_S (software)\nsuch that input I_k generates output O_k, therefore F_S : I \\to O. Therefore, the ideal software generates the tuple (I_k,O_k) which is the input-output set \\Sigma,\nstanding for specification.\nNow, take a test input  I_t , which generates the output O_t, that is the test tuple \\tau = (I_t,O_t) . Now, the question is whether or not  \\tau \\in \\Sigma  or  \\tau \\not \\in \\Sigma . If it is in the set, the test tuple  \\tau  passes, else the system fails the test input. Therefore, it is of imperative importance to figure out : can we or can we not create a function  that effectively translates into the notion of the set indicator function for the specification set  \\Sigma .\nBy the notion, 1_{\\Sigma} is the testability function for the specification \\Sigma.\nThe existence should not merely be asserted, should be proven rigorously. Therefore, obviously without algebraic consistency, no such function can be found, and therefore, the specification cease to be termed as testable.\nSee also\n* Testability\nReferences\n* Robert V. Binder:  Testing Object-Oriented Systems: Models, Patterns, and Tools,\n* Stefan Jungmayr: [https://web.archive.org/web/20071009021801/http://www.dissertation.de/index.php3?active_document=%2FFDP%2Fsj929.pdf Improving testability of object-oriented systems],\n* Wanderlei Souza: [http://grace-center.jp/wp-content/uploads/2012/06/GRACE-TR-2009-07.pdf Abstract Testability Patterns], ISSN 1884-0760\n* Boris Beizer: [https://books.google.com/books?id=Ixf97h356zcC], Software Testing Techniques"
    }
  ]
}