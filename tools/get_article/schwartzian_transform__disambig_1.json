{
  "content": [
    {
      "type": "text",
      "text": "# Schwartzian transform__disambig_1\n\nIn computer programming, the Schwartzian transform is a technique used to improve the efficiency of sorting a list of items. This idiom is appropriate for comparison-based sorting when the ordering is actually based on the ordering of a certain property (the key) of the elements, where computing that property is an intensive operation that should be performed a minimal number of times. The Schwartzian transform is notable in that it does not use named temporary arrays.\nThe Schwartzian transform is a version of a Lisp idiom known as decorate-sort-undecorate, which avoids recomputing the sort keys by temporarily associating them with the input items. This approach is similar to , which avoids repeating the calculation of the key corresponding to a specific input value. By comparison, this idiom assures that each input item's key is calculated exactly once, which may still result in repeating some calculations if the input data contains duplicate items.\nThe idiom is named after Randal L. Schwartz, who first demonstrated it in Perl shortly after the release of Perl 5 in 1994. The term \"Schwartzian transform\" applied solely to Perl programming for a number of years, but it has later been adopted by some users of other languages, such as Python, to refer to similar idioms in those languages. However, the algorithm was already in use in other languages (under no specific name) before it was popularized among the Perl community in the form of that particular idiom by Schwartz. The term \"Schwartzian transform\" indicates a specific idiom, and not the algorithm in general.\nFor example, to sort the word list (\"aaaa\",\"a\",\"aa\") according to word length: first build the list ([\"aaaa\",4],[\"a\",1],[\"aa\",2]), then sort it according to the numeric values getting ([\"a\",1],[\"aa\",2],[\"aaaa\",4]), then strip off the numbers and you get (\"a\",\"aa\",\"aaaa\"). That was the algorithm in general, so it does not count as a transform. To make it a true Schwartzian transform, it would be done in Perl like this:\n@sorted = map  { $_->[0] }\nsort { $a->[1]  $b->[1] or $a->[0] cmp $b->[0] } # Use numeric comparison, fall back to string sort on original\nmap  { [$_, length($_)] }    # Calculate the length of the string\n@unsorted;\nThe Perl idiom\nThe general form of the Schwartzian transform is:\n@sorted = map  { $_->[0] }\nsort { $a->[1] cmp $b->[1] or $a->[0] cmp $b->[0] }\nmap  { [$_, foo($_)] }\n@unsorted;\nHere foo($_) represents an expression that takes $_ (each item of the list in turn) and produces the corresponding value that is to be compared in its stead.\nReading from right to left (or from the bottom to the top):\n* the original list @unsorted is fed into a map operation that wraps each item into a (reference to an anonymous 2-element) array consisting of itself and the calculated value that will determine its sort order (list of item becomes a list of [item, value]);\n* then the list of lists produced by map is fed into sort, which sorts it according to the values previously calculated (list of [item, value] ⇒ sorted list of [item, value]);\n* finally, another map operation unwraps the values (from the anonymous array) used for the sorting, producing the items of the original list in the sorted order (sorted list of [item, value] ⇒ sorted list of item).\nThe use of anonymous arrays ensures that memory will be reclaimed by the Perl garbage collector immediately after the sorting is done.\nEfficiency analysis\nWithout the Schwartzian transform, the sorting in the example above would be written in Perl like this:\n@sorted = sort { foo($a) cmp foo($b) } @unsorted;\nWhile it is shorter to code, the naive approach here could be much less efficient if the key function (called  in the example above) is expensive to compute. This is because the code inside the brackets is evaluated each time two elements need to be compared. An optimal comparison sort performs O(n log n) comparisons (where n is the length of the list), with 2 calls to  every comparison, resulting in O(n log n) calls to . In comparison, using the Schwartzian transform, we only make 1 call to  per element, at the beginning  stage, for a total of n calls to .\nHowever, if the function  is relatively simple, then the extra overhead of the Schwartzian transform may be unwarranted.\nExample\nFor example, to sort a list of files by their modification times, a naive approach might be as follows:\nfunction naiveCompare(file a, file b) {\nreturn modificationTime(a)\n#!/usr/bin/env perl\nrequire 5; # New features, new bugs!\nprint\nmap { $_->[0] }\nsort { $a->[1] cmp $b->[1] }\nmap { [$_, /(\\S+)$/] }\n;\nThis code produces the result:\nadmg:Mahalingam Gobieramanan\nadktk:KaLap Timothy Kwong\nadmln:Martha L. Nangalama\nadjn:Joshua Ng\nSchwartz noted in the post that he was \"Speak[ing] with a lisp in Perl\", a reference to the idiom's Lisp origins.\nThe term \"Schwartzian transform\" itself was coined by Tom Christiansen in a follow-up reply. Later posts by Christiansen made it clear that he had not intended to name the construct, but merely to refer to it from the original post: his attempt to finally name it \"The Black Transform\" did not take hold (\"Black\" here being a pun on \"schwar[t]z\", which means black in German).\nComparison to other languages\nSome other languages provide a convenient interface to the same optimization as the Schwartzian transform:\n* In Python 2.4 and above, both the  function and the in-place  method take a  parameter that allows the user to provide a \"key function\" (like  in the examples above). In Python 3 and above, use of the key function is the only way to specify a custom sort order (the previously supported  parameter that allowed the user to provide a \"comparison function\" was removed). Before Python 2.4, developers would use the lisp-originated decorate–sort–undecorate (DSU) idiom, usually by wrapping the objects in a (sortkey, object) tuple.\n* In Ruby 1.8.6 and above, the  abstract class (which includes s) contains a  method, which allows specifying the \"key function\" (like  in the examples above) as a code block.\n* In D 2 and above, the  function is available. It might require less temporary data and be faster than the Perl idiom or the decorate–sort–undecorate idiom present in Python and Lisp. This is because sorting is done in-place, and only minimal extra data (one array of transformed elements) is created.\n* Racket's core sort function accepts a #:key keyword argument with a function that extracts a key, and an additional #:cache-keys? requests that the resulting values are cached during sorting. For example, a convenient way to shuffle a list is .\n* In PHP 5.3 and above the transform can be implemented by use of , e.g. to work around the limitations of the unstable sort algorithms in PHP.\nfunction spaceballs_sort(array& $a): void\n{\narray_walk($a, function(&$v, $k) { $v = array($v, $k); });\nasort($a);\narray_walk($a, function(&$v, $_) { $v = $v[0]; });\n}\n* In Elixir, the  and  methods allow users to perform a Schwartzian transform for any module that implements the  protocol.\n* In Raku, one needs to supply a comparator lambda that only takes 1 argument to perform a Schwartzian transform under the hood: @a.sort( { $^a.Str } ) # or shorter: @a.sort(*.Str) would sort on the string representation using a Schwartzian transform, @a.sort( { $^a.Str cmp $^b.Str } ) would do the same converting the elements to compare just before each comparison.\n* In Rust, somewhat confusingly, the  method does not perform a Schwartzian transform as it will not allocate additional storage for the key, it will call the key function for each value for each comparison. The  method will compute the keys once per element.\n* In Haskell, the sortOn function from the base library performs a Schwartzian transform.\nReferences\nExternal links\n* [http://www.stonehenge.com/merlyn/UnixReview/col64.html Sorting with the Schwartzian Transform by Randal L. Schwartz]\n* [http://perl.plover.com/TPC/1998/Hardware-notes.html#Schwartzian_Transform Mark-Jason Dominus explains the Schwartzian Transform]\n* http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52234\n* Python Software Foundation (2005). [https://www.python.org/doc/faq/programming/#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python 1.5.2   I want to do a complicated sort: can you do a Schwartzian Transform in Python?]. Retrieved June 22, 2005.\n* [https://metacpan.org/module/Memoize Memoize Perl module - making expensive functions faster by caching their results.]"
    }
  ]
}