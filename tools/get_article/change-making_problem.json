{
  "content": [
    {
      "type": "text",
      "text": "# Change-making problem\n\nThe change-making problem addresses the question of finding the minimum number of coins (of certain denominations) that add up to a given amount of money. It is a special case of the integer knapsack problem, and has applications wider than just currency.\nIt is also the most common variation of the coin change problem, a general case of partition in which, given the available denominations of an infinite set of coins, the objective is to find out the number of possible ways of making a change for a specific amount of money, without considering the order of the coins.\nIt is weakly NP-hard, but may be solved optimally in pseudo-polynomial time by dynamic programming.\nMathematical definition\nCoin values can be modeled by a set of  distinct positive integer values (whole numbers), arranged in increasing order as  through . The problem is: given an amount , also a positive integer, to find a set of non-negative (positive or zero) integers }, with each  representing how often the coin with value  is used, which minimize the total number of coins\n: f(W)=\\sum_{j=1}^n x_j\nsubject to\n: \\sum_{j=1}^n w_j x_j = W.\nNon-currency examples\nAn application of change-making problem can be found in computing the ways one can make a nine dart finish in a game of darts.\nAnother application is computing the possible atomic (or isotopic) composition of a given mass/charge peak in mass spectrometry.\nMethods of solving\nSimple dynamic programming\nA classic dynamic programming strategy works upward by finding the combinations of all smaller values that would sum to the current threshold. Thus, at each threshold, all previous thresholds are potentially considered to work upward to the goal amount W. For this reason, this dynamic programming approach requires a number of steps that is O(nW), where n is the number of types of coins.\nImplementation\nThe following is a dynamic programming implementation (with Python 3) which uses a matrix to keep track of the optimal solutions to sub-problems, and returns the minimum number of coins, or \"Infinity\" if there is no way to make change with the coins given. A second matrix may be used to obtain the set of coins for the optimal solution.\ndef _get_change_making_matrix(set_of_coins, r: int):\nm = [[0 for _ in range(r + 1)] for _ in range(len(set_of_coins) + 1)]\nfor i in range(1, r + 1):\nm[0][i] = float(\"inf\")  # By default there is no way of making change\nreturn m\ndef change_making(coins, n: int):\n\"\"\"This function assumes that all coins are available infinitely.\nif coins are only to be used once, change m[c][r - coin] to m[c - 1][r - coin].\nn is the number to obtain with the fewest coins.\ncoins is a list or tuple with the available denominations.\n\"\"\"\nm = _get_change_making_matrix(coins, n)\nfor c, coin in enumerate(coins, 1):\nfor r in range(1, n + 1):\n# Just use the coin\nif coin == r:\nm[c][r] = 1\n# coin cannot be included.\n# Use the previous solution for making r,\n# excluding coin\nelif coin > r:\nm[c][r] = m[c - 1][r]\n# coin can be used.\n# Decide which one of the following solutions is the best:\n# 1. Using the previous solution for making r (without using coin).\n# 2. Using the previous solution for making r - coin (without\n#      using coin) plus this 1 extra coin.\nelse:\nm[c][r] = min(m[c - 1][r], 1 + m[c][r - coin])\nreturn m[-1][-1]\nGreedy method\nFor many real-world coin systems, such as those used in the US and many other countries, a greedy algorithm of picking the largest denomination of coin which is not greater than the remaining amount to be made will produce the optimal result. This is not the case for arbitrary coin systems or even some real world systems, though. For instance, if we consider the old (now withdrawn) Indian coin denominations of 5, 10, 20 and 25 paise, then to make 40 paise, the greedy algorithm would choose three coins (25, 10, 5) whereas the optimal solution is two coins (20, 20). Another example is attempting to make 40 US cents without nickels (denomination 25, 10, 1) with similar result — the greedy chooses seven coins (25, 10, and 5 × 1), but the optimal is four (4 × 10). A coin system is called \"canonical\" if the greedy algorithm always solves its change-making problem optimally. It is possible to test whether a coin system is canonical in polynomial time.\nRelated problems\nThe \"optimal denomination problem\" is a problem for people who design entirely new currencies. It asks what denominations should be chosen for the coins in order to minimize the average cost of making change, that is, the average number of coins needed to make change. The version of this problem assumed that the people making change will use the minimum number of coins (from the denominations available). One variation of this problem assumes that the people making change will use the \"greedy algorithm\" for making change, even when that requires more than the minimum number of coins. Most current currencies use a 1-2-5 series, but some other set of denominations would require fewer denominations of coins or a smaller average number of coins to make change or both.\nSee also\n* List of knapsack problems\n* Coin problem\n* The coin collector's problem\nReferences\nFurther reading\n*"
    }
  ]
}